
<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Goot Player</title>
<link rel="icon" type="image/svg+xml" href="https://www.gstatic.com/classroom/logo_square_rounded.svg">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&family=Roboto+Mono&display=swap');
:root {
    --md-sys-color-primary: #ff4d4d;
    --md-sys-color-primary-container: rgba(255, 77, 77, 0.15);
    --md-sys-color-surface: #0b0d0e;
    --md-sys-color-surface-variant: #1a1c1e;
    --md-sys-color-on-surface: #e2e2e6;
    --md-sys-color-outline: #42474e;
    --md-sys-color-on-primary: #ffffff;
    --md-sys-color-background: #060809;
    --md-sys-color-on-background: #e2e2e6;
    --motion-standard: cubic-bezier(0.2, 0, 0, 1);
    --nav-height: 0px;
}
[data-theme="light"] {
    --md-sys-color-primary: #b71c1c;
    --md-sys-color-primary-container: rgba(183, 28, 28, 0.12);
    --md-sys-color-surface: #f8f9fa;
    --md-sys-color-surface-variant: #e8eaed;
    --md-sys-color-on-surface: #1f1f1f;
    --md-sys-color-outline: #757575;
    --md-sys-color-on-primary: #ffffff;
    --md-sys-color-background: #ffffff;
    --md-sys-color-on-background: #212121;
}
* { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-thumb { background: var(--md-sys-color-primary); border-radius: 10px; }
body {
    font-family: 'Google Sans', sans-serif;
    background: var(--md-sys-color-background);
    color: var(--md-sys-color-on-background);
    margin: 0; height: 100vh; display: flex;
    flex-direction: column; overflow: hidden;
    transition: background-color 0.4s ease, color 0.4s ease;
}
.app-shell { display: flex; flex: 1; overflow: hidden; position: relative; }
.nav-rail {
    width: 88px; background: var(--md-sys-color-surface);
    border-right: 1px solid var(--md-sys-color-outline);
    display: flex; flex-direction: column; align-items: center;
    padding: 24px 0; gap: 12px; z-index: 100; flex-shrink: 0;
}
.main-container { flex: 1; padding: 40px 60px; overflow-y: auto; position: relative; padding-bottom: 120px; }
.side-sheet {
    width: 380px; background: var(--md-sys-color-surface);
    border-left: 1px solid var(--md-sys-color-outline);
    display: flex; flex-direction: column;
    transition: transform 0.4s var(--motion-standard);
    z-index: 300;
}
.side-sheet.collapsed { transform: translateX(100%); width: 0; border: none; }
.player-bar {
    height: 110px; background: rgba(11,13,14,0.98);
    backdrop-filter: blur(20px); border-top: 1px solid var(--md-sys-color-outline);
    display: flex; align-items: center; padding: 0 40px; gap: 24px; z-index: 200;
    transition: all 0.3s ease;
}

/* Player bar button hover effects */
#btnShuffle:hover,
#btnRepeat:hover {
    opacity: 1 !important;
    transform: scale(1.15);
}

.player-bar .fa-backward-step:hover,
.player-bar .fa-forward-step:hover {
    transform: scale(1.15);
}

.player-bar .play-btn:hover {
    background: var(--md-sys-color-primary) !important;
    color: white !important;
    transform: scale(1.12);
}

.player-bar .play-btn:active {
    transform: scale(0.95);
}

body.playing .player-bar .play-btn {
    animation: playerHeartbeat 2.4s infinite ease-in-out;
}

@keyframes playerHeartbeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.12); }
}

[data-theme="light"] .player-bar { background: rgba(255,255,255,0.95); }
.screen { display: none; opacity: 0; transform: translateY(24px) scale(0.98); transition: opacity 0.6s cubic-bezier(0.16,1,0.3,1), transform 0.6s cubic-bezier(0.16,1,0.3,1); }
.screen.active { display: block; opacity: 1; transform: translateY(0) scale(1); }
img { opacity: 0; transition: opacity 0.6s var(--motion-standard); }
img.loaded { opacity: 1; }
.folder-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px,1fr)); gap: 24px; }
.folder-card {
    background: #000; aspect-ratio: 1/1; border-radius: 20px; cursor: pointer; overflow: hidden; position: relative;
    border: 1px solid var(--md-sys-color-outline);
    opacity: 0; transform: translateY(30px) scale(0.92);
    transition: all 0.7s var(--motion-standard), box-shadow 0.4s ease;
}
.folder-card.loaded { opacity: 1; transform: translateY(0) scale(1); }
.folder-card:hover { transform: translateY(-4px) scale(1.04); box-shadow: 0 16px 32px rgba(0,0,0,0.4); border-color: var(--md-sys-color-primary); }
.folder-art { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 1; background: #000; }
.folder-art img { width: 100%; height: 100%; object-fit: cover; position: absolute; inset: 0; }
.folder-info { position: absolute; inset: 0; z-index: 2; padding: 12px; display: flex; align-items: flex-end; background: linear-gradient(to top, rgba(0,0,0,0.8) 0%, transparent 60%); }
.folder-info span { font-weight: 600; font-size: 14px; color: white; }
.playlist-card .play-overlay {
    position: absolute; inset: 0; display: flex; flex-direction: column; justify-content: flex-end; align-items: flex-end;
    padding: 16px; opacity: 0; transition: opacity 0.4s var(--motion-standard); pointer-events: none;
    background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, transparent 60%); z-index: 3;
}
.playlist-card:hover .play-overlay { opacity: 1; pointer-events: auto; }
.play-overlay .control-group { display: flex; flex-direction: column; gap: 12px; align-items: center; }
.play-overlay .control-btn {
    width: 56px; height: 56px; border-radius: 50%; background: var(--md-sys-color-primary); color: white;
    display: flex; align-items: center; justify-content: center; font-size: 22px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.5); transition: transform 0.3s ease;
}
.play-overlay .control-btn.shuffle { background: color-mix(in srgb, var(--md-sys-color-primary) 70%, #333); }
.play-overlay .control-btn:hover { transform: scale(1.15); }
.play-overlay .btn-label { color: white; font-size: 13px; font-weight: 500; text-shadow: 0 1px 4px rgba(0,0,0,0.8); }
.playlist-header { display: flex; align-items: center; gap: 32px; margin-bottom: 32px; flex-wrap: wrap; }
.playlist-cover {
    width: 240px; height: 240px; border-radius: 16px; overflow: hidden; background: var(--md-sys-color-surface-variant);
    box-shadow: 0 8px 32px rgba(0,0,0,0.4); position: relative; cursor: pointer;
}

.playlist-cover img { width: 100%; height: 100%; object-fit: cover; }
.playlist-cover .no-art { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 80px; opacity: 0.25; }

.playlist-info { flex: 1; min-width: 300px; }
.playlist-controls { display: flex; gap: 16px; margin-top: 16px; }
.playlist-management { display: flex; gap: 12px; margin-top: 24px; flex-wrap: wrap; }
.playlist-breadcrumb { display: flex; align-items: center; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; }
.playlist-breadcrumb .chip {
    padding: 8px 16px; background: var(--md-sys-color-surface-variant); border-radius: 100px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;
}
.playlist-breadcrumb .chip:hover { background: var(--md-sys-color-primary-container); color: var(--md-sys-color-primary); }
.song-row { transition: background 0.25s var(--motion-standard); cursor: pointer; }
.song-row:hover td { background: var(--md-sys-color-primary-container); }
.song-row td:first-child { border-radius: 12px 0 0 12px; }
.song-row td:last-child { border-radius: 0 12px 12px 0; }
.song-row { cursor: grab; }
.song-row:active { cursor: grabbing; }

/* Playlist drag handle */
.playlist-drag-handle {
    opacity: 0.3;
    cursor: grab;
    padding: 4px 8px;
    transition: opacity 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}
.playlist-drag-handle:hover { opacity: 1; }
.playlist-drag-handle:active { cursor: grabbing; }
.sortable-ghost { opacity: 0.4; background: var(--md-sys-color-primary-container); }
.queue-item {
    display: flex; align-items: center; gap: 12px; padding: 12px 16px;
    cursor: pointer; border-bottom: 1px solid rgba(255,255,255,0.05);
}
.queue-item.visible { opacity: 1; transform: translateX(0); }
.queue-item:hover { background: var(--md-sys-color-primary-container); transform: translateX(6px); }
.queue-item.active { background: var(--md-sys-color-primary-container); border-left: 4px solid var(--md-sys-color-primary); }

/* Disable transitions during drag for smooth animation */
.queue-item.sortable-chosen { transition: none; }
.queue-item.sortable-ghost { transition: none; opacity: 0.4; background: var(--md-sys-color-primary-container); }

/* Queue drag handle */
.queue-drag-handle {
    opacity: 0.3;
    cursor: grab;
    padding: 4px;
    transition: opacity 0.2s;
}
.queue-drag-handle:hover { opacity: 1; }
.queue-drag-handle:active { cursor: grabbing; }

/* Queue drag animations - matching playlist style */
.queue-sort-drag {
    opacity: 1;
    transform: scale(1.02);
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    z-index: 100;
}
.nav-item { width: 100%; display: flex; flex-direction: column; align-items: center; cursor: pointer; gap: 4px; opacity: 0.6; transition: all 0.4s var(--motion-standard); }
.nav-item.active { opacity: 1; color: var(--md-sys-color-primary); transform: scale(1.08); }
.nav-icon-wrapper { width: 56px; height: 32px; border-radius: 16px; display: flex; align-items: center; justify-content: center; transition: all 0.4s var(--motion-standard); }
.nav-item.active .nav-icon-wrapper { background: var(--md-sys-color-primary-container); transform: scale(1.1); }
.play-btn {
    width: 56px; height: 56px; border-radius: 50%; background: var(--md-sys-color-primary); color: white;
    display: flex; align-items: center; justify-content: center; font-size: 20px; cursor: pointer;
    transition: all 0.4s cubic-bezier(0.175,0.885,0.32,1.275);
}
.play-btn:hover { transform: scale(1.12); filter: brightness(1.15); }
body.playing .play-btn,
body.playing .clean-btn.play-btn-large {
    animation: heartbeat 2.4s infinite ease-in-out;
}

@keyframes heartbeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.12); }
}

@keyframes fadeInOut {
    0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
    15% { opacity: 1; transform: translateX(-50%) translateY(0); }
    85% { opacity: 1; transform: translateX(-50%) translateY(0); }
    100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
}
.action-btn {
    background: var(--md-sys-color-surface-variant); color: white; border: 1px solid var(--md-sys-color-outline);
    padding: 10px 20px; border-radius: 12px; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; font-size: 14px;
    transition: all 0.3s var(--motion-standard);
}
.action-btn:hover { border-color: var(--md-sys-color-primary); background: var(--md-sys-color-primary-container); transform: translateY(-2px); }

/* Material 3 Expressive Buttons */
.m3-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 10px 16px;
    border-radius: 16px;
    border: none;
    cursor: pointer;
    font-family: inherit;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s var(--motion-standard);
}

.m3-btn i {
    font-size: 18px;
}

.m3-btn span {
    font-weight: 500;
}

/* Filled button - accent color background */
.m3-btn-filled {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.m3-btn-filled:hover {
    background: var(--md-sys-color-primary);
    filter: brightness(1.1);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.m3-btn-filled:active {
    transform: translateY(0);
    filter: brightness(0.95);
}

/* Tonal button - secondary with accent tint */
.m3-btn-tonal {
    background: var(--md-sys-color-secondary-container);
    color: var(--md-sys-color-on-secondary-container);
    border: 1px solid var(--md-sys-color-outline);
}

.m3-btn-tonal:hover {
    background: var(--md-sys-color-primary-container);
    border-color: var(--md-sys-color-primary);
    transform: translateY(-2px);
}

.m3-btn-tonal:active {
    transform: translateY(0);
}

/* Text button style */
.m3-btn-text {
    background: transparent;
    color: var(--md-sys-color-primary);
    border: 1px solid transparent;
}
.m3-btn-text:hover {
    background: var(--md-sys-color-primary-container);
}
.m3-btn-text:active {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
}

/* Modal selection button style (None/All buttons) */
.m3-btn-modal-action {
    background: var(--md-sys-color-surface-variant);
    color: var(--md-sys-color-on-surface);
    border: 1px solid var(--md-sys-color-outline);
    border-radius: 20px;
    min-width: 72px;
    font-weight: 500;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}
.m3-btn-modal-action:hover {
    background: var(--md-sys-color-outline);
    border-color: var(--md-sys-color-outline);
    color: var(--md-sys-color-on-surface);
}
.m3-btn-modal-action:active {
    background: var(--md-sys-color-primary);
    border-color: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
}

/* Delete button specific styling */
.m3-btn.playlist-delete-btn {
    --md-sys-color-on-secondary-container: #ff4444;
    --md-sys-color-secondary-container: rgba(255, 68, 68, 0.15);
}

.m3-btn.playlist-delete-btn:hover {
    background: rgba(255, 68, 68, 0.25);
    border-color: #ff4444;
    transform: translateY(-2px);
}

/* New Playlist Big Square Card */
.new-playlist-card {
    cursor: pointer;
}

.new-playlist-icon {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--md-sys-color-surface-variant);
    border: 2px dashed var(--md-sys-color-outline);
    border-radius: 20px;
    transition: all 0.3s ease;
}

.new-playlist-card:hover .new-playlist-icon {
    border-color: var(--md-sys-color-primary);
    background: var(--md-sys-color-primary-container);
}

.new-playlist-icon i {
    font-size: 48px;
    color: var(--md-sys-color-on-surface);
    opacity: 0.4;
    transition: all 0.3s ease;
}

.new-playlist-card:hover .new-playlist-icon i {
    opacity: 1;
    color: var(--md-sys-color-primary);
    transform: scale(1.1);
}

.new-playlist-label {
    position: absolute;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 13px;
    font-weight: 600;
    color: var(--md-sys-color-on-surface);
    opacity: 0.8;
    white-space: nowrap;
    text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
}

/* Light mode new playlist card */
[data-theme="light"] .new-playlist-icon {
    background: #f5f5f5;
}

[data-theme="light"] .new-playlist-label {
    text-shadow: 0 1px 4px rgba(255, 255, 255, 0.8);
}

/* Track actions container */
.track-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
}

.track-actions .m3-btn {
    padding: 8px 14px;
    border-radius: 12px;
}

.track-actions .m3-btn i {
    font-size: 14px;
}

.track-actions .m3-btn span {
    font-size: 12px;
}

/* Icon-only button for queue items */
.m3-btn-icon {
    padding: 8px;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Queue hover menu - slides in from the left when hovering ellipsis */
.queue-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    cursor: pointer;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    position: relative;
    overflow: hidden;
}

.queue-item-content {
    display: flex;
    align-items: center;
    gap: 12px;
    flex: 1;
    transition: opacity 0.25s var(--motion-standard);
    z-index: 1;
}

.queue-hover-menu {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 8px;
    padding: 12px 16px;
    background: var(--md-sys-color-surface-variant);
    transform: translateX(-100%);
    opacity: 0;
    z-index: 10;
    transition: transform 0.3s var(--motion-standard), opacity 0.2s ease;
}

/* Trigger hover menu from ellipsis button hover */
.queue-item:has(.queue-ellipsis:hover) .queue-hover-menu {
    transform: translateX(0);
    opacity: 1;
}

/* Also show menu when directly hovering the menu itself */
.queue-item:has(.queue-hover-menu:hover) .queue-hover-menu {
    transform: translateX(0);
    opacity: 1;
}

/* Fade out main content when menu is visible */
.queue-item:has(.queue-ellipsis:hover) .queue-item-content,
.queue-item:has(.queue-hover-menu:hover) .queue-item-content {
    opacity: 0;
}

.queue-hover-menu .m3-btn {
    padding: 8px 12px;
}

.queue-hover-menu .m3-btn i {
    font-size: 14px;
}

.queue-hover-menu .m3-btn span {
    font-size: 12px;
    font-weight: 500;
}

/* Light mode queue hover menu */
[data-theme="light"] .queue-hover-menu {
    background: #e8eaed;
}
[data-theme="light"] .queue-hover-menu .m3-btn {
    color: var(--md-sys-color-on-surface);
}

/* --- VOLUME NORMALIZATION STYLES --- */

.norm-container {
    background: var(--md-sys-color-surface-variant);
    border-radius: 24px;
    padding: 24px;
    border: 1px solid var(--md-sys-color-outline);
    margin-top: 24px;
}

.norm-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
}

.norm-title {
    font-size: 16px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 10px;
}

.norm-title i {
    color: var(--md-sys-color-primary);
}

.norm-toggle-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 0;
    border-bottom: 1px solid var(--md-sys-color-outline);
}

.norm-toggle-label {
    font-size: 14px;
    font-weight: 500;
}

.norm-target-row {
    padding: 16px 0;
    border-bottom: 1px solid var(--md-sys-color-outline);
}

.norm-target-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    font-size: 14px;
    font-weight: 500;
}

.norm-target-value {
    color: var(--md-sys-color-primary);
    font-weight: 600;
    font-variant-numeric: tabular-nums;
}

.norm-slider-container {
    display: flex;
    align-items: center;
    gap: 16px;
}

.norm-slider {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    background: rgba(255,255,255,0.12);
    border-radius: 3px;
    cursor: pointer;
}

.norm-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: var(--md-sys-color-primary);
    border-radius: 50%;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    cursor: pointer;
    transition: transform 0.15s ease;
}

.norm-slider::-webkit-slider-thumb:hover {
    transform: scale(1.15);
}

.norm-slider::-webkit-slider-runnable-track {
    height: 6px;
    background: rgba(255,255,255,0.12);
    border-radius: 3px;
}

.norm-loudness-labels {
    display: flex;
    justify-content: space-between;
    margin-top: 8px;
    font-size: 11px;
    opacity: 0.6;
}

.norm-status {
    margin-top: 16px;
    padding: 12px 16px;
    background: rgba(0,0,0,0.2);
    border-radius: 12px;
    font-size: 13px;
    display: flex;
    align-items: center;
    gap: 10px;
}

.norm-status i {
    color: var(--md-sys-color-primary);
}

.norm-indicator {
    position: absolute;
    bottom: 8px;
    right: 8px;
    font-size: 10px;
    padding: 4px 8px;
    background: var(--md-sys-color-primary-container);
    color: var(--md-sys-color-primary);
    border-radius: 100px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.norm-indicator.visible {
    opacity: 1;
}

.norm-gain-value {
    font-size: 11px;
    opacity: 0.8;
    margin-left: 4px;
}

/* Light mode normalization styles */
[data-theme="light"] .norm-container {
    background: var(--md-sys-color-surface);
}
[data-theme="light"] .norm-slider {
    background: rgba(0,0,0,0.12);
}
[data-theme="light"] .norm-slider::-webkit-slider-runnable-track {
    background: rgba(0,0,0,0.12);
}
[data-theme="light"] .norm-status {
    background: rgba(0,0,0,0.06);
}

/* --- SIMPLE SETTINGS MENU --- */

.settings-header {
    margin-bottom: 32px;
}

.settings-title {
    font-size: 48px;
    font-weight: 700;
    margin: 0;
    color: var(--md-sys-color-on-background);
    letter-spacing: -1px;
}

.simple-settings-section {
    background: var(--md-sys-color-surface-variant);
    border-radius: 28px;
    padding: 24px;
    margin-bottom: 20px;
    border: 1px solid var(--md-sys-color-outline);
}

.simple-section-title {
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--md-sys-color-on-surface);
    opacity: 0.6;
    margin: 0 0 16px 0;
}

.simple-setting-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px;
    border-radius: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.simple-setting-row:hover {
    background: rgba(255,255,255,0.05);
}

.simple-setting-info {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.simple-setting-label {
    font-size: 16px;
    font-weight: 500;
    color: var(--md-sys-color-on-surface);
}

.simple-setting-desc {
    font-size: 13px;
    color: var(--md-sys-color-on-surface);
    opacity: 0.6;
}

.simple-toggle {
    position: relative;
    width: 52px;
    height: 32px;
    cursor: pointer;
}

.simple-toggle-track {
    position: absolute;
    inset: 0;
    background: var(--md-sys-color-outline);
    border-radius: 16px;
    transition: all 0.3s ease;
}

.simple-toggle-thumb {
    position: absolute;
    top: 4px;
    left: 4px;
    width: 24px;
    height: 24px;
    background: white;
    border-radius: 50%;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.simple-toggle input:checked + .simple-toggle-track {
    background: var(--md-sys-color-primary);
}

.simple-toggle input:checked + .simple-toggle-track .simple-toggle-thumb {
    transform: translateX(20px);
}

/* Color grid */
.color-grid {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 12px;
}

.color-btn {
    aspect-ratio: 1;
    border-radius: 16px;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.2s ease;
}

.color-btn:hover {
    transform: scale(1.1);
    border-color: white;
}

.pencil-color-btn {
    background: linear-gradient(135deg, #ff0000, #ff7700, #ffdd00, #77ff00, #00ff00, #00ff77, #00ffff, #0077ff, #0000ff);
    background-size: 200% 200%;
    animation: rainbowSpiral 3s ease infinite;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid rgba(255,255,255,0.3);
}

.pencil-color-btn:hover {
    transform: scale(1.1);
    border-color: white;
    box-shadow: 0 0 20px rgba(255,255,255,0.5);
}

.pencil-color-btn i {
    color: white;
    font-size: 18px;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
}

@keyframes rainbowSpiral {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

.hidden-input {
    display: none;
}

/* Danger section */
.danger-section {
    background: transparent;
    border: none;
    padding: 0;
}

.danger-btn {
    width: 100%;
    padding: 18px 24px;
    border-radius: 16px;
    background: #dc2626;
    color: white;
    border: none;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    transition: all 0.2s ease;
}

.danger-btn:hover {
    background: #ef4444;
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(220, 38, 38, 0.4);
}

.danger-btn i {
    font-size: 18px;
}

/* Light mode */
[data-theme="light"] .simple-settings-section {
    background: white;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
}

[data-theme="light"] .simple-setting-row:hover {
    background: rgba(0,0,0,0.03);
}

/* Mobile responsive */
@media (max-width: 768px) {
    .settings-title {
        font-size: 36px;
    }
    
    .simple-settings-section {
        padding: 20px;
        border-radius: 24px;
    }
    
    .color-grid {
        grid-template-columns: repeat(4, 1fr);
    }
}

/* --- ALBUM MODAL STYLES --- */

/* Modal overlay */
.album-modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.6);
    z-index: 2000;
    display: none;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(8px);
    transition: opacity 0.3s cubic-bezier(0.2, 0, 0, 1);
}

.album-modal-overlay.visible {
    display: flex;
    opacity: 1;
}

/* Modal container - Material 3 Expressive */
.album-modal {
    background: var(--md-sys-color-surface-variant);
    width: 90%;
    max-width: 480px;
    max-height: 80vh;
    border-radius: 28px;
    display: flex;
    flex-direction: column;
    border: 1px solid var(--md-sys-color-outline);
    box-shadow: 0 24px 48px rgba(0, 0, 0, 0.4);
    transform: scale(0.92) translateY(20px);
    transition: transform 0.3s cubic-bezier(0.2, 0, 0, 1);
    overflow: hidden;
}

.album-modal-overlay.visible .album-modal {
    transform: scale(1) translateY(0);
}

/* Modal header */
.album-modal-header {
    padding: 20px 24px 16px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid var(--md-sys-color-outline);
}

.album-modal-title {
    font-size: 20px;
    font-weight: 600;
    color: var(--md-sys-color-on-surface);
    margin: 0;
    line-height: 1.2;
}

.album-modal-subtitle {
    font-size: 14px;
    font-weight: 500;
    color: var(--md-sys-color-on-surface);
    opacity: 0.7;
    padding: 0 24px;
    margin-bottom: 12px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.album-modal-close {
    width: 40px;
    height: 40px;
    border-radius: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    border: none;
    color: var(--md-sys-color-on-surface);
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.2, 0, 0, 1);
    opacity: 0.7;
}

.album-modal-close:hover {
    background: var(--md-sys-color-primary-container);
    opacity: 1;
}

.album-modal-close:active {
    transform: scale(0.9);
}

/* Modal content area */
.album-modal-content {
    flex: 1;
    overflow-y: auto;
    padding: 12px 16px;
}

/* Individual track item in album modal */
.album-modal-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 12px;
    border-radius: 16px;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.2, 0, 0, 1);
    position: relative;
    margin-bottom: 4px;
}

.album-modal-item:hover {
    background: var(--md-sys-color-surface-variant);
    transform: translateX(4px);
}

.album-modal-item.selected {
    background: var(--md-sys-color-primary-container);
}

.album-modal-item-art {
    width: 56px;
    height: 56px;
    border-radius: 12px;
    overflow: hidden;
    flex-shrink: 0;
    background: var(--md-sys-color-surface);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
}

.album-modal-item-art img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.album-modal-item-art img.loaded {
    opacity: 1;
}

.album-modal-item-art .no-art {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--md-sys-color-on-surface);
    opacity: 0.4;
    font-size: 22px;
    background: var(--md-sys-color-surface-variant);
}

.album-modal-item-info {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.album-modal-item-title {
    font-size: 15px;
    font-weight: 500;
    color: var(--md-sys-color-on-surface);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.album-modal-item-artist {
    font-size: 13px;
    color: var(--md-sys-color-on-surface);
    opacity: 0.7;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Custom checkbox styling */
.album-modal-checkbox {
    width: 24px;
    height: 24px;
    border-radius: 8px;
    border: 2px solid var(--md-sys-color-outline);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all 0.2s cubic-bezier(0.2, 0, 0, 1);
}

.album-modal-item.selected .album-modal-checkbox {
    background: var(--md-sys-color-primary);
    border-color: var(--md-sys-color-primary);
}

.album-modal-checkbox i {
    color: white;
    font-size: 12px;
    opacity: 0;
    transform: scale(0.8);
    transition: all 0.2s cubic-bezier(0.2, 0, 0, 1);
}

.album-modal-item.selected .album-modal-checkbox i {
    opacity: 1;
    transform: scale(1);
}

/* Modal footer */
.album-modal-footer {
    padding: 16px 24px 24px 24px;
    display: flex;
    justify-content: flex-end;
    gap: 12px;
}

/* Light mode album modal */
[data-theme="light"] .album-modal {
    background: var(--md-sys-color-surface);
    box-shadow: 0 24px 48px rgba(0, 0, 0, 0.15);
}

[data-theme="light"] .album-modal-item:hover {
    background: rgba(0, 0, 0, 0.04);
}

[data-theme="light"] .album-modal-item.selected {
    background: var(--md-sys-color-primary-container);
}

[data-theme="light"] .album-modal-close:hover {
    background: rgba(0, 0, 0, 0.08);
}

/* Goot v3.5 Welcome Modal */
.v35-modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.6);
    z-index: 3000;
    display: none;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(8px);
    transition: opacity 0.3s ease;
}

.v35-modal-overlay.visible {
    display: flex;
    opacity: 1;
}

.v35-modal {
    background: var(--md-sys-color-surface-variant);
    width: 90%;
    max-width: 420px;
    border-radius: 28px;
    padding: 32px 28px;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    border: 1px solid var(--md-sys-color-outline);
    box-shadow: 0 24px 48px rgba(0, 0, 0, 0.4);
    transform: scale(0.92) translateY(20px);
    transition: transform 0.3s cubic-bezier(0.2, 0, 0, 1);
}

.v35-modal-overlay.visible .v35-modal {
    transform: scale(1) translateY(0);
}

.v35-modal-icon {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    background: var(--md-sys-color-primary-container);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-bottom: 20px;
}

.v35-modal-icon i {
    font-size: 28px;
    color: var(--md-sys-color-primary);
}

.v35-modal-title {
    font-size: 22px;
    font-weight: 600;
    color: var(--md-sys-color-on-surface);
    margin: 0 0 12px 0;
}

.v35-modal-text {
    font-size: 14px;
    color: var(--md-sys-color-on-surface);
    opacity: 0.8;
    line-height: 1.5;
    margin: 0 0 24px 0;
}

.v35-modal-actions {
    display: flex;
    flex-direction: column;
    gap: 12px;
    width: 100%;
}

.v35-btn {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 14px 20px;
    border-radius: 16px;
    border: none;
    font-family: inherit;
    font-size: 15px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
}

.v35-btn i {
    font-size: 16px;
}

.v35-btn-danger {
    background: #dc2626;
    color: white;
}

.v35-btn-danger:hover {
    background: #ef4444;
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(220, 38, 38, 0.4);
}

.v35-btn-secondary {
    background: var(--md-sys-color-surface-variant);
    color: var(--md-sys-color-on-surface);
    border: 1px solid var(--md-sys-color-outline);
}

.v35-btn-secondary:hover {
    background: rgba(255, 255, 255, 0.05);
    transform: translateY(-2px);
}

/* Light mode v35 modal */
[data-theme="light"] .v35-modal {
    background: var(--md-sys-color-surface);
    box-shadow: 0 24px 48px rgba(0, 0, 0, 0.15);
}

[data-theme="light"] .v35-btn-secondary {
    background: white;
}

[data-theme="light"] .v35-btn-secondary:hover {
    background: rgba(0, 0, 0, 0.04);
}

.search-container { position: relative; margin-bottom: 24px; }
.search-input {
    width: 100%; background: var(--md-sys-color-surface-variant); border: 1px solid var(--md-sys-color-outline);
    padding: 14px 20px; border-radius: 16px; color: var(--md-sys-color-on-surface); font-family: inherit; transition: all 0.4s var(--motion-standard);
}
.search-input:focus {
    border-color: var(--md-sys-color-primary); box-shadow: 0 0 0 3px color-mix(in srgb, var(--md-sys-color-primary) 40%, transparent); transform: scale(1.01);
}
.search-results {
    position: absolute; top: 100%; left: 0; right: 0; background: var(--md-sys-color-surface);
    border: 1px solid var(--md-sys-color-outline);
    border-radius: 0 0 28px 28px; z-index: 500; max-height: 450px; overflow-y: auto; display: none;
    box-shadow: 0 12px 48px rgba(0,0,0,0.4);
    padding: 8px;
}

/* Material 3 Expressive search result item */
.search-result-item {
    display: flex; align-items: center; gap: 16px; cursor: pointer;
    border-radius: 16px; padding: 12px 16px; transition: all 0.2s cubic-bezier(0.2, 0, 0, 1);
    position: relative; overflow: hidden;
}
.search-result-item:hover {
    background: var(--md-sys-color-surface-variant);
    transform: translateX(4px);
}
.search-result-item::before {
    content: ''; position: absolute; inset: 0; background: var(--md-sys-color-primary);
    opacity: 0; transition: opacity 0.2s ease;
}
.search-result-item:active::before {
    opacity: 0.1;
}
.search-result-content {
    flex: 1; min-width: 0; position: relative; z-index: 1;
}
.search-result-add-btn {
    width: 44px; height: 44px; border-radius: 16px;
    display: flex; align-items: center; justify-content: center;
    background: var(--md-sys-color-primary-container); color: var(--md-sys-color-primary);
    border: none; cursor: pointer; flex-shrink: 0;
    transition: all 0.2s cubic-bezier(0.2, 0, 0, 1);
    position: relative; z-index: 1;
}
.search-result-add-btn:hover {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
    transform: scale(1.1) rotate(90deg);
    box-shadow: 0 4px 16px color-mix(in srgb, var(--md-sys-color-primary) 40%, transparent);
}
.search-result-add-btn:active {
    transform: scale(0.95);
}
.truncate { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
.breadcrumb-chip {
    padding: 8px 16px; background: var(--md-sys-color-surface-variant); border-radius: 100px; font-size: 13px; cursor: pointer;
    transition: all 0.4s cubic-bezier(0.34,1.56,0.64,1);
}
.breadcrumb-chip:hover { color: var(--md-sys-color-primary); background: var(--md-sys-color-primary-container); transform: scale(1.14) translateY(-2px); }
#npArt img, #fsArt img { width: 100%; height: 100%; object-fit: cover; border-radius: 12px; }
.progress-container { margin-top: 12px; width: 100%; height: 8px; background: rgba(255,255,255,0.15); border-radius: 4px; overflow: hidden; display: none; }
.progress-bar { height: 100%; width: 0%; background: var(--md-sys-color-primary); transition: width 0.3s ease; box-shadow: 0 0 12px var(--md-sys-color-primary); }
#loadControls { display: flex; gap: 12px; align-items: center; margin-top: 8px; }
#logOverlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 2000; backdrop-filter: blur(10px); }
#logModal {
    background: var(--md-sys-color-surface-variant); width: 90%; max-width: 900px; height: 80%; border-radius: 24px; padding: 32px;
    overflow: hidden; display: flex; flex-direction: column; border: 1px solid var(--md-sys-color-outline);
}
#logHeader { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
#logContent { flex: 1; overflow-y: auto; background: #111; border-radius: 12px; padding: 16px; font-family: 'Roboto Mono', monospace; font-size: 13px; white-space: pre-wrap; color: #ccc; line-height: 1.5; }
.theme-toggle-container {
    display: flex; align-items: center; justify-content: space-between; background: var(--md-sys-color-surface-variant);
    padding: 16px 20px; border-radius: 16px; margin-top: 24px; border: 1px solid var(--md-sys-color-outline);
}
.theme-toggle-label { font-size: 15px; font-weight: 500; }
.theme-switch { position: relative; display: inline-block; width: 54px; height: 28px; }
.theme-switch input { opacity: 0; width: 0; height: 0; }
.slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 28px; }
.slider:before { position: absolute; content: ""; height: 24px; width: 24px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
input:checked + .slider { background-color: var(--md-sys-color-primary); }
input:checked + .slider:before { transform: translateX(26px); }

/* --- EQUALIZER STYLES --- */
.eq-container {
    max-width: 800px; margin: 0 auto;
    background: var(--md-sys-color-surface-variant);
    border-radius: 24px; padding: 32px;
    border: 1px solid var(--md-sys-color-outline);
}
.eq-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 40px; }
.eq-presets select {
    background: var(--md-sys-color-background);
    color: var(--md-sys-color-on-background);
    border: 1px solid var(--md-sys-color-outline);
    padding: 10px 16px; border-radius: 8px; font-size: 14px;
    cursor: pointer;
}
.eq-dials-area {
    display: flex; flex-direction: column; gap: 20px; margin-bottom: 32px;
    padding: 24px 0; 
    border-bottom: 1px solid var(--md-sys-color-outline);
}
.tone-slider-row {
    display: flex; align-items: center; gap: 16px;
}
.tone-label {
    width: 70px; font-weight: 600; font-size: 13px; text-transform: uppercase; letter-spacing: 1px;
}
.tone-range {
    -webkit-appearance: none; appearance: none;
    flex: 1; height: 6px;
    background: rgba(255,255,255,0.12);
    border-radius: 3px; cursor: pointer;
}
.tone-range::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px; height: 18px;
    background: var(--md-sys-color-primary);
    border-radius: 50%;
    border: 2px solid white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    cursor: pointer;
}
.tone-range::-webkit-slider-runnable-track {
    height: 6px; background: rgba(255,255,255,0.12); border-radius: 3px;
}
.tone-range::-moz-range-thumb {
    width: 18px; height: 18px;
    background: var(--md-sys-color-primary);
    border-radius: 50%; border: 2px solid white;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3); cursor: pointer;
}
.tone-range::-moz-range-track {
    height: 6px; background: rgba(255,255,255,0.12); border-radius: 3px;
}
.tone-value {
    width: 45px; text-align: right; font-size: 14px; font-weight: 500;
    opacity: 0.8; font-variant-numeric: tabular-nums;
}

.eq-sliders-grid {
    display: grid; grid-template-columns: repeat(10, 1fr); gap: 8px; height: 220px; align-items: flex-end;
}
.eq-slider-col {
    display: flex; flex-direction: column; align-items: center; height: 100%;
}
.eq-slider-track {
    flex: 1; width: 8px; background: rgba(255,255,255,0.08);
    border-radius: 8px; position: relative;
    display: flex; justify-content: center;
    box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
    border: 1px solid rgba(255,255,255,0.05);
}
/* Vertical range input trick */
.eq-range {
    -webkit-appearance: none;
    appearance: none;
    width: 200px; height: 28px;
    background: transparent;
    transform: rotate(-90deg);
    transform-origin: center;
    position: absolute;
    top: 86px;
    cursor: pointer;
}
.eq-range::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 22px; height: 22px;
    background: linear-gradient(145deg, var(--md-sys-color-primary), color-mix(in srgb, var(--md-sys-color-primary) 70%, #000));
    border-radius: 50%;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 0 12px color-mix(in srgb, var(--md-sys-color-primary) 50%, transparent);
    border: 3px solid white;
    margin-top: -9px;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
}
.eq-range::-webkit-slider-thumb:hover {
    transform: scale(1.15);
    box-shadow: 0 2px 12px rgba(0,0,0,0.5), 0 0 20px color-mix(in srgb, var(--md-sys-color-primary) 70%, transparent);
}
.eq-range::-webkit-slider-thumb:active {
    transform: scale(1.1);
}
.eq-range::-moz-range-thumb {
    width: 22px; height: 22px;
    background: linear-gradient(145deg, var(--md-sys-color-primary), color-mix(in srgb, var(--md-sys-color-primary) 70%, #000));
    border-radius: 50%;
    box-shadow: 0 2px 8px rgba(0,0,0,0.4), 0 0 12px color-mix(in srgb, var(--md-sys-color-primary) 50%, transparent);
    border: 3px solid white;
    cursor: pointer;
}
.eq-range::-webkit-slider-runnable-track {
    width: 100%; height: 6px;
    background: linear-gradient(90deg, rgba(255,255,255,0.15), rgba(255,255,255,0.08));
    border-radius: 3px;
}
.eq-range::-moz-range-track {
    width: 100%; height: 6px;
    background: linear-gradient(90deg, rgba(255,255,255,0.15), rgba(255,255,255,0.08));
    border-radius: 3px;
}
.eq-freq-label {
    margin-top: 12px; font-size: 10px; opacity: 0.6;
    transform: rotate(-45deg); white-space: nowrap;
}

.mobile-player-overlay {
    position: fixed; inset: 0; background: var(--md-sys-color-background);
    z-index: 2500; display: flex; flex-direction: column; padding: 24px 32px;
    transform: translateY(100%); transition: transform 0.4s cubic-bezier(0.2, 0, 0, 1);
}
.mobile-player-overlay.active { transform: translateY(0); }
.mp-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 32px; margin-top: env(safe-area-inset-top); }
.mp-art-container {
    width: 100%; aspect-ratio: 1/1; border-radius: 24px; background: var(--md-sys-color-surface-variant);
    overflow: hidden; margin-bottom: 40px; box-shadow: 0 12px 48px rgba(0,0,0,0.6); align-self: center; max-width: 400px;
    display: flex; align-items: center; justify-content: center;
}
#fsArt i { font-size: 80px; opacity: 0.3; }
.mp-info-container { margin-bottom: 32px; display: flex; flex-direction: column; gap: 4px; }
.mp-progress-container { display: flex; align-items: center; gap: 16px; margin-bottom: 32px; }
.mp-controls-container { display: flex; align-items: center; justify-content: space-between; padding: 0 16px; margin-top: auto; margin-bottom: 40px; }
.mp-btn { font-size: 24px; color: var(--md-sys-color-on-background); background: none; border: none; cursor: pointer; transition: all 0.2s; }
.mp-btn:active { transform: scale(0.9); }
.mp-play-btn {
    width: 72px; height: 72px; background: var(--md-sys-color-primary); border-radius: 50%;
    color: white; display: flex; align-items: center; justify-content: center; font-size: 28px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
}

.mobile-nav { display: none; position: fixed; bottom: 0; left: 0; right: 0; height: 64px; background: var(--md-sys-color-surface); border-top: 1px solid var(--md-sys-color-outline); z-index: 1000; justify-content: space-around; align-items: center; padding-bottom: env(safe-area-inset-bottom); }
.mobile-nav-item { display: flex; flex-direction: column; align-items: center; justify-content: center; flex: 1; height: 100%; color: var(--md-sys-color-on-surface); opacity: 0.6; transition: all 0.3s ease; }
.mobile-nav-item.active { opacity: 1; color: var(--md-sys-color-primary); }
.mobile-nav-item i { font-size: 20px; margin-bottom: 4px; }
.mobile-nav-item span { font-size: 10px; font-weight: 500; }

@media (max-width: 768px) {
    :root { --nav-height: 64px; }
    .nav-rail { display: none; }
    .mobile-nav { display: flex; }
    .main-container { padding: 20px 16px; padding-bottom: 140px; }
    .folder-grid { grid-template-columns: repeat(2, 1fr); gap: 12px; }
    .playlist-card:hover .play-overlay { opacity: 1; pointer-events: auto; }
    
    .side-sheet { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; z-index: 3000; transform: translateY(100%); border-left: none; }
    .side-sheet.collapsed { transform: translateY(100%); width: 100%; }
    .side-sheet:not(.collapsed) { transform: translateY(0); }

    .player-bar {
        bottom: var(--nav-height); left: 0; right: 0; height: 68px; padding: 0 12px; position: fixed;
        border-top: 1px solid var(--md-sys-color-outline); background: var(--md-sys-color-surface-variant);
        align-items: center; z-index: 1000;
    }
    
    .player-bar > div:first-child { flex: 1; min-width: 0; gap: 12px; }
    #npArt { width: 48px; height: 48px; box-shadow: none; border-radius: 8px; }
    #npTitle { font-size: 14px; }
    #npArtist { font-size: 12px; }
    #npAlbum { display: none; }

    .player-bar > div:nth-child(2) { flex: 0 0 auto; width: auto; flex-direction: row; gap: 0; position: static; }
    .player-bar > div:nth-child(2) > div:first-child { gap: 12px; flex-direction: row; }
    
    #btnShuffle, #btnRepeat, #curTime, #durTime, .fa-backward-step { display: none; }
    
    .play-btn { width: 42px; height: 42px; font-size: 18px; background: transparent; color: var(--md-sys-color-on-surface); border: 1px solid var(--md-sys-color-outline); }
    .fa-forward-step { font-size: 20px; padding: 8px; }

    .player-bar > div:nth-child(2) > div:last-child {
        position: absolute; top: -4px; left: 0; right: 0; width: 100%; max-width: none !important;
        height: 4px; background: transparent; margin: 0;
    }
    .player-bar > div:nth-child(2) > div:last-child > div:nth-child(2) {
        border-radius: 0; background: rgba(255,255,255,0.1);
    }
    #progFill { border-radius: 0; box-shadow: none; }
    #progScrub { top: -10px; height: 20px; }

    .player-bar > div:last-child { display: none !important; }

    h1 { font-size: 32px !important; }
    .playlist-header { flex-direction: column; align-items: flex-start; gap: 16px; }
    .playlist-cover { width: 160px; height: 160px; align-self: center; }
    .playlist-info { width: 100%; min-width: 0; text-align: center; }
    .playlist-controls, .playlist-management { justify-content: center; }
    #playlistBreadcrumb { justify-content: center; }
    
    /* Hide extended view button on mobile */
    #playerBarExtendedBtn { display: none !important; }
    
    /* Adjust EQ for mobile */
    .eq-dials-area { gap: 20px; }
    .eq-slider-col { width: 20px; }
    .eq-range { width: 160px; top: 70px; }
    .eq-sliders-grid { gap: 4px; }
    
    /* Mobile playlist table adjustments */
    .song-row td.meta-album { display: none; }
    .song-row td:first-child { width: 48px; }
    .playlist-drag-handle { padding: 8px 12px !important; }
    .song-row { cursor: pointer; }
}

/* === DESKTOP EXPANDED VIEW === */
.desktop-extended {
	position: fixed;
	inset: 0;
	z-index: 1600;
	overflow-y: auto;
	overflow-x: hidden;
	transition: transform 0.4s cubic-bezier(0.2, 0, 0, 1);
	background: var(--md-sys-color-primary-dark);
}

.desktop-extended.collapsed {
	transform: translateY(100%);
}

/* Art container at top */
.desktop-extended-art {
	position: relative;
	width: 100%;
	display: flex;
	justify-content: center;
	padding: 60px 0 0 0;
	min-height: 60vh;
}

/* Blurred background layer */
.desktop-extended-art-bg {
	position: absolute;
	inset: 0;
	background-size: cover;
	background-position: center center;
	filter: blur(35px);
	transform: scale(1.1);
	opacity: 0;
	transition: opacity 0.2s ease;
	z-index: 0;
}

/* Gradient overlay to fade into darker accent color at bottom */
.desktop-extended-art-bg::after {
	content: '';
	position: absolute;
	inset: 0;
	background: linear-gradient(to bottom, transparent 0%, var(--md-sys-color-primary-dark) 100%);
	pointer-events: none;
}

.desktop-extended-art-bg.visible {
	opacity: 1;
}



/* Main album art */
.desktop-extended-art-img {
	position: relative;
	width: min(450px, 45vw);
	height: min(450px, 45vw);
	object-fit: cover;
	border-radius: 24px;
	box-shadow: 0 30px 80px rgba(0, 0, 0, 0.6);
	z-index: 1;
	opacity: 0;
	transition: opacity 0.2s ease;
}

.desktop-extended-art-img.visible {
	opacity: 1;
}

/* Player controls area */
.clean-player {
	position: relative;
	z-index: 2;
	padding: 0 24px 60px 24px;
	text-align: center;
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 20px;
}

.clean-controls-panel {
	background: color-mix(in srgb, var(--md-sys-color-primary) 60%, black);
	border-radius: 24px;
	padding: 32px 24px 24px 24px;
	width: 100%;
	max-width: 500px;
	box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.clean-info-panel {
	text-align: center;
	width: 100%;
	max-width: 500px;
}

.clean-title {
	font-size: 28px;
	font-weight: 700;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	margin: 0;
	line-height: 1.3;
}

.clean-artist {
	opacity: 0.7;
	font-size: 18px;
	margin: 8px 0 0 0;
}

.clean-progress {
	width: 100%;
	max-width: 500px;
	margin: 24px auto 0 auto;
	display: flex;
	align-items: center;
	gap: 12px;
}

.clean-time {
	font-size: 12px;
	opacity: 0.9;
	min-width: 40px;
	text-align: center;
	font-variant-numeric: tabular-nums;
	text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.clean-bar-bg {
	flex: 1;
	height: 6px;
	background: rgba(0, 0, 0, 0.4);
	border-radius: 3px;
	position: relative;
	cursor: pointer;
	overflow: hidden;
}

.clean-bar-fill {
	height: 100%;
	background: linear-gradient(90deg, var(--md-sys-color-primary), color-mix(in srgb, var(--md-sys-color-primary) 70%, white));
	box-shadow: 0 0 12px var(--md-sys-color-primary);
	border-radius: 3px;
	width: 0%;
	position: absolute;
	top: 0;
	left: 0;
	transition: width 0.18s linear;
}

.clean-scrub {
	position: absolute;
	top: -14px;
	left: 0;
	width: 100%;
	height: 34px;
	opacity: 0;
	cursor: pointer;
}

.clean-controls {
	margin-top: 20px;
	display: flex;
	justify-content: center;
	align-items: center;
	gap: 24px;
}

.clean-btn {
	background: none;
	border: none;
	color: var(--desktop-extended-text, white);
	cursor: pointer;
	transition: all 0.3s ease;
	padding: 10px;
	border-radius: 50%;
}

.clean-btn:hover {
	opacity: 1;
	transform: scale(1.15);
}

.clean-btn:active {
	transform: scale(0.95);
}

.clean-btn.play-btn-large {
	width: 64px;
	height: 64px;
	background: var(--md-sys-color-primary);
	font-size: 28px;
	box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
}

.clean-btn.play-btn-large:hover {
	background: color-mix(in srgb, var(--md-sys-color-primary) 90%, white);
}

.clean-btn#deShuffleBtn,
.clean-btn#deRepeatBtn {
	font-size: 18px;
	opacity: 0.6;
}

.clean-btn#deShuffleBtn.active,
.clean-btn#deRepeatBtn.active {
	opacity: 1;
	color: var(--md-sys-color-primary);
}

.clean-btn#deShuffleBtn:hover,
.clean-btn#deRepeatBtn:hover {
	opacity: 0.9;
}

.clean-btn.on-play-btn-large {
	animation: none;
}

/* Skip buttons in expanded view */
.clean-controls .fa-backward-step,
.clean-controls .fa-forward-step {
	font-size: 22px;
}

.clean-controls .fa-backward-step:hover,
.clean-controls .fa-forward-step:hover {
	transform: scale(1.15);
}

.clean-volume {
	display: flex;
	align-items: center;
	justify-content: center;
	gap: 12px;
	margin-top: 20px;
	color: var(--desktop-extended-text, white);
}

.clean-queue {
	position: relative;
	z-index: 2;
	width: 100%;
	max-width: 600px;
	margin: 0 auto;
	padding: 24px 24px 100px 24px;
}

.clean-queue h3 {
	opacity: 0.8;
	letter-spacing: 1.5px;
	font-size: 11px;
	margin: 0 0 16px 0;
	text-transform: uppercase;
	font-weight: 700;
	color: white;
}

.clean-queue-item {
	padding: 12px 16px;
	border-radius: 8px;
	display: flex;
	justify-content: space-between;
	align-items: center;
	cursor: pointer;
	transition: all 0.2s ease;
	margin-bottom: 4px;
	background: rgba(255, 255, 255, 0.1);
	backdrop-filter: blur(10px);
}

.clean-queue-item:hover {
	background: rgba(255, 255, 255, 0.2);
	transform: translateX(4px) scale(1.01);
}

.clean-queue-item.active {
	background: rgba(255, 255, 255, 0.25);
	border-left: 3px solid white;
}

/* Desktop Extended View Queue - using same structure as sidebar */
.clean-queue .queue-item {
	padding: 12px 16px;
	border-radius: 8px;
	margin-bottom: 4px;
	background: rgba(255, 255, 255, 0.1);
	backdrop-filter: blur(10px);
}

.clean-queue .queue-item:hover {
	background: rgba(255, 255, 255, 0.2);
	transform: translateX(6px);
}

.clean-queue .queue-item.active {
	background: rgba(255, 255, 255, 0.25);
	border-left: 4px solid white;
}

.clean-queue .queue-item .queue-drag-handle {
	opacity: 0.6;
	color: white;
}

.clean-queue .queue-item .queue-drag-handle:hover {
	opacity: 1;
}

.clean-queue .queue-item .q-artist {
	opacity: 0.8 !important;
}

.clean-queue .queue-item .queue-ellipsis {
	color: white !important;
	opacity: 0.6 !important;
}

/* Queue ellipsis button */
.queue-ellipsis {
	cursor: pointer;
	padding: 6px 10px;
	border-radius: 4px;
	transition: all 0.2s ease;
	color: white;
	background: transparent;
	border: none;
	font-size: 16px;
	opacity: 0.6;
	z-index: 20;
}

.queue-ellipsis:hover {
	opacity: 1 !important;
	background: rgba(255, 255, 255, 0.2);
	transform: scale(1.1);
}
	transform: scale(1.1);
}

.clean-queue .queue-ellipsis {
	color: white;
	opacity: 0.7 !important;
}

/* Light mode ellipsis */
[data-theme="light"] .queue-ellipsis {
    color: rgba(0, 0, 0, 0.5);
}
[data-theme="light"] .queue-ellipsis:hover {
	background: rgba(0, 0, 0, 0.1);
}
[data-theme="light"] .queue-ellipsis:hover i {
    color: black;
}

/* Light Mode Fixes */
[data-theme="light"] .folder-card {
	background: var(--md-sys-color-surface);
}
[data-theme="light"] .folder-card:hover {
	box-shadow: 0 16px 32px rgba(0,0,0,0.15);
}
[data-theme="light"] .folder-info {
	background: linear-gradient(to top, rgba(0,0,0,0.6) 0%, transparent 60%);
}
[data-theme="light"] .folder-info span {
	color: white;
	text-shadow: 0 1px 4px rgba(0,0,0,0.8);
}
[data-theme="light"] .playlist-card:hover .play-overlay {
	background: linear-gradient(to top, rgba(0,0,0,0.5) 0%, transparent 60%);
}
[data-theme="light"] .play-overlay .control-btn {
	box-shadow: 0 4px 16px rgba(0,0,0,0.3);
}
[data-theme="light"] .play-overlay .btn-label {
	text-shadow: 0 1px 4px rgba(0,0,0,0.8);
}
[data-theme="light"] .playlist-cover {
	box-shadow: 0 8px 32px rgba(0,0,0,0.2);
}
[data-theme="light"] .play-btn {
	color: white;
}
[data-theme="light"] .action-btn {
	color: white;
}
[data-theme="light"] .search-results {
    background: white;
    box-shadow: 0 12px 48px rgba(0,0,0,0.15);
    border-color: rgba(0,0,0,0.12);
}
[data-theme="light"] .search-result-item:hover {
    background: rgba(0,0,0,0.04);
}
[data-theme="light"] .search-result-item::before {
    background: #000;
}
[data-theme="light"] .search-result-item:active::before {
    opacity: 0.05;
}
[data-theme="light"] .search-result-add-btn {
    background: var(--md-sys-color-primary-container);
    color: var(--md-sys-color-primary);
}
[data-theme="light"] .search-result-add-btn:hover {
    background: var(--md-sys-color-primary);
    color: white;
}
[data-theme="light"] .search-result-add-btn:active {
    transform: scale(0.95);
}
[data-theme="light"] .progress-container {
	background: rgba(0,0,0,0.1);
}
[data-theme="light"] .progress-container .progress-bar {
	box-shadow: 0 0 8px var(--md-sys-color-primary);
}
[data-theme="light"] #buffFill {
	background: rgba(0,0,0,0.2);
}
[data-theme="light"] #progFill {
	background: linear-gradient(90deg, var(--md-sys-color-primary), color-mix(in srgb, var(--md-sys-color-primary) 60%, black));
	box-shadow: 0 0 8px var(--md-sys-color-primary);
}
[data-theme="light"] .clean-bar-bg {
	background: rgba(255, 255, 255, 0.4);
}
[data-theme="light"] .clean-queue-item:hover {
	background: rgba(0, 0, 0, 0.1);
}
[data-theme="light"] .clean-close-fab {
	background: rgba(0,0,0,0.2);
	color: white;
}
[data-theme="light"] .clean-close-fab:hover {
	background: rgba(0,0,0,0.3);
}
[data-theme="light"] #logContent {
	background: #f5f5f5;
	color: #333;
}
[data-theme="light"] .mp-art-container {
	box-shadow: 0 12px 48px rgba(0,0,0,0.2);
}
[data-theme="light"] .mp-play-btn {
	color: white;
	box-shadow: 0 8px 24px rgba(0,0,0,0.3);
}
[data-theme="light"] .eq-range::-webkit-slider-runnable-track {
	background: linear-gradient(90deg, rgba(0,0,0,0.15), rgba(0,0,0,0.08));
}
[data-theme="light"] .eq-range::-moz-range-track {
	background: linear-gradient(90deg, rgba(0,0,0,0.15), rgba(0,0,0,0.08));
}
[data-theme="light"] .tone-range {
	background: rgba(0,0,0,0.12);
}
[data-theme="light"] #playerBarProgressBg {
	--progress-bg: rgba(0,0,0,0.15);
}
[data-theme="light"] #buffFill {
	background: rgba(0,0,0,0.25);
}
[data-theme="light"] #fsProgressBg {
	--progress-bg: rgba(0,0,0,0.15);
}
[data-theme="light"] #fsBuffFill {
	background: rgba(0,0,0,0.25);
}
[data-theme="light"] .clean-bar-bg {
	--progress-bg: rgba(255,255,255,0.4);
}
[data-theme="light"] .eq-range::-webkit-slider-thumb {
	border-color: var(--md-sys-color-surface);
}
[data-theme="light"] .eq-range::-moz-range-thumb {
	border-color: var(--md-sys-color-surface);
}
[data-theme="light"] #logOverlay,
[data-theme="light"] #modalOverlay,
[data-theme="light"] #albumModalOverlay {
	background: rgba(0,0,0,0.4);
}
[data-theme="light"] .album-modal {
    background: white;
    box-shadow: 0 24px 48px rgba(0,0,0,0.15);
}
[data-theme="light"] .album-modal .m3-btn-text {
    color: var(--md-sys-color-primary);
}
[data-theme="light"] .album-modal .m3-btn-text:hover {
    background: var(--md-sys-color-primary-container);
}
[data-theme="light"] .album-modal-item:hover {
    background: rgba(0,0,0,0.04);
}
[data-theme="light"] .album-modal-item.selected {
    background: var(--md-sys-color-primary-container);
}
[data-theme="light"] .album-modal-close:hover {
    background: rgba(0,0,0,0.08);
}
[data-theme="light"] .song-row td {
	color: var(--md-sys-color-on-surface);
}
[data-theme="light"] .queue-item {
	color: var(--md-sys-color-on-surface);
	border-bottom: 1px solid rgba(0, 0, 0, 0.08);
}
[data-theme="light"] .queue-item:hover {
	background: rgba(0,0,0,0.04);
}
[data-theme="light"] .queue-item.active {
	background: var(--md-sys-color-primary-container);
	border-left-color: var(--md-sys-color-primary);
}
[data-theme="light"] .queue-drag-handle {
	color: rgba(0, 0, 0, 0.4);
}
[data-theme="light"] .queue-drag-handle:hover {
	color: rgba(0, 0, 0, 0.7);
}
[data-theme="light"] .clean-queue-item {
	color: white;
}
[data-theme="light"] .clean-queue-item.active {
	background: rgba(255, 255, 255, 0.2);
	border-left-color: white;
}
[data-theme="light"] .clean-queue-item:hover {
	background: rgba(255, 255, 255, 0.15);
}
[data-theme="light"] .clean-q-artist {
	opacity: 0.9;
}
[data-theme="light"] .clean-time {
	opacity: 0.9;
	text-shadow: 0 1px 2px rgba(255, 255, 255, 0.3);
}
[data-theme="light"] .clean-btn {
	color: white;
}
[data-theme="light"] .nav-item {
	color: var(--md-sys-color-on-surface);
}
[data-theme="light"] .nav-item.active {
	color: var(--md-sys-color-primary);
}
[data-theme="light"] .modal h2 {
	color: var(--md-sys-color-on-surface);
}
[data-theme="light"] #modalList {
	color: var(--md-sys-color-on-surface);
}
[data-theme="light"] #logHeader h2 {
	color: var(--md-sys-color-on-surface);
}
[data-theme="light"] .mobile-nav-item {
	color: var(--md-sys-color-on-surface);
}
[data-theme="light"] .mobile-nav-item.active {
	color: var(--md-sys-color-primary);
}
[data-theme="light"] .mobile-player-overlay {
	color: var(--md-sys-color-on-background);
}
[data-theme="light"] .mp-info-container {
	color: var(--md-sys-color-on-background);
}
[data-theme="light"] .mp-btn {
	color: var(--md-sys-color-on-background);
}
[data-theme="light"] .desktop-extended {
	color: white;
}
[data-theme="light"] .desktop-extended-bg {
	background: var(--md-sys-color-primary);
}
[data-theme="light"] .clean-title {
	color: white;
	text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
[data-theme="light"] .clean-artist {
	color: rgba(255,255,255,0.9);
	text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}
[data-theme="light"] .clean-controls {
	color: white;
}

/* Extended view queue items in light mode */
[data-theme="light"] .clean-queue .queue-item {
	color: white;
	background: rgba(255, 255, 255, 0.1);
}
[data-theme="light"] .clean-queue .queue-item:hover {
	background: rgba(255, 255, 255, 0.2);
}
[data-theme="light"] .clean-queue .queue-item.active {
	background: rgba(255, 255, 255, 0.25);
	border-left-color: white;
}
[data-theme="light"] .clean-queue .queue-item .q-artist {
	opacity: 0.9 !important;
	color: rgba(255,255,255,0.9) !important;
}
[data-theme="light"] .clean-queue h3 {
	opacity: 0.9;
	color: white;
}
[data-theme="light"] .clean-volume {
	color: white;
}
[data-theme="light"] .clean-volume i {
	opacity: 0.9;
}

/* Light mode icon visibility */
[data-theme="light"] .fa-music {
    color: rgba(0, 0, 0, 0.3);
}
[data-theme="light"] .fa-bookmark {
    color: inherit;
}
[data-theme="light"] .fa-trash {
    color: inherit;
}
[data-theme="light"] .fa-grip-vertical {
    color: rgba(0, 0, 0, 0.4);
}
[data-theme="light"] .fa-ellipsis {
    color: rgba(0, 0, 0, 0.5);
}
.clean-close-fab {
	position: fixed;
	top: 24px;
	right: 24px;
	background: rgba(255, 255, 255, 0.2);
	backdrop-filter: blur(10px);
	border: none;
	color: white;
	width: 44px;
	height: 44px;
	border-radius: 50%;
	cursor: pointer;
	z-index: 10;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 18px;
	transition: all 0.2s ease;
	box-shadow: 0 2px 10px rgba(0,0,0,0.2);
}

.clean-close-fab:hover {
	background: rgba(255, 255, 255, 0.3);
	transform: scale(1.1);
}

.clean-close-fab:active {
	transform: scale(0.95);
}

/* Playlist Modal Styles */
.playlist-modal {
	background: var(--md-sys-color-surface-variant);
	width: 380px;
	max-height: 480px;
	border-radius: 28px;
	border: 1px solid var(--md-sys-color-outline);
	display: flex;
	flex-direction: column;
	overflow: hidden;
	box-shadow: 0 16px 48px rgba(0, 0, 0, 0.4);
}

.playlist-modal-header {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 20px 24px 16px 24px;
	border-bottom: 1px solid var(--md-sys-color-outline);
}

.playlist-modal-header h2 {
	margin: 0;
	font-size: 20px;
	font-weight: 600;
}

.modal-close-btn {
	background: transparent;
	border: none;
	color: var(--md-sys-color-on-surface);
	width: 36px;
	height: 36px;
	border-radius: 50%;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 18px;
	opacity: 0.7;
	transition: all 0.2s ease;
}

.modal-close-btn:hover {
	background: rgba(255, 255, 255, 0.1);
	opacity: 1;
}

.playlist-modal-content {
	flex: 1;
	overflow: hidden;
	display: flex;
	flex-direction: column;
}

.playlist-modal-list {
	flex: 1;
	overflow-y: auto;
	padding: 8px;
	max-height: 280px;
}

.playlist-modal-item {
	display: flex;
	align-items: center;
	gap: 14px;
	padding: 12px 16px;
	border-radius: 14px;
	cursor: pointer;
	transition: all 0.2s ease;
	margin-bottom: 4px;
}

.playlist-modal-item:hover {
	background: var(--md-sys-color-primary-container);
}

.playlist-modal-item-icon {
	width: 44px;
	height: 44px;
	border-radius: 10px;
	background: var(--md-sys-color-surface);
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 20px;
	color: var(--md-sys-color-primary);
	flex-shrink: 0;
}

.playlist-modal-item-info {
	flex: 1;
	min-width: 0;
}

.playlist-modal-item-name {
	font-weight: 500;
	font-size: 15px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}

.playlist-modal-item-count {
	font-size: 13px;
	opacity: 0.6;
	margin-top: 2px;
}

.playlist-modal-item-arrow {
	opacity: 0;
	transition: all 0.2s ease;
	color: var(--md-sys-color-primary);
}

.playlist-modal-item:hover .playlist-modal-item-arrow {
	opacity: 1;
	transform: translateX(4px);
}

.playlist-modal-footer {
	padding: 16px 24px 20px 24px;
	border-top: 1px solid var(--md-sys-color-outline);
}

[data-theme="light"] .clean-close-fab {
	background: rgba(0,0,0,0.25);
	color: white;
}
[data-theme="light"] .clean-close-fab:hover {
	background: rgba(0,0,0,0.35);
}

/* Hide the player bar button when the extended view is NOT collapsed */
body:has(.desktop-extended:not(.collapsed)) #playerBarExpandedBtn {
	display: none;
}

#playerBarExpandedBtn {
	background: none;
	border: none;
	color: var(--md-sys-color-on-surface);
	cursor: pointer;
	opacity: 0.7;
	transition: all 0.2s ease;
	padding: 8px;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 18px;
}

#playerBarExpandedBtn:hover {
	opacity: 1;
	transform: scale(1.1);
	color: var(--md-sys-color-primary);
}
</style>
</head>
<body>
<div id="modalOverlay" onclick="closeModal()" style="position:fixed;inset:0;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:2000;backdrop-filter:blur(8px);transition:opacity 0.3s ease;">
    <div class="playlist-modal" onclick="event.stopPropagation()">
        <div class="playlist-modal-header">
            <h2>Add to Playlist</h2>
            <button class="modal-close-btn" onclick="closeModal()">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
        <div class="playlist-modal-content">
            <div id="modalList" class="playlist-modal-list"></div>
        </div>
        <div class="playlist-modal-footer">
            <button class="m3-btn m3-btn-filled" onclick="createNewPlaylist(true)" style="width:100%;">
                <i class="fa-solid fa-plus"></i>
                <span>New Playlist</span>
            </button>
        </div>
    </div>
</div>

<!-- Goot v3.5 Welcome Modal -->
<div id="v35Modal" class="v35-modal-overlay" onclick="if(event.target === this) cancelV35DataReset()">
    <div class="v35-modal" onclick="event.stopPropagation()">
        <div class="v35-modal-icon">
            <i class="fa-solid fa-star"></i>
        </div>
        <h2 class="v35-modal-title">Welcome to Goot v3.5</h2>
        <p class="v35-modal-text">This version has significant changes. For the best experience and to avoid potential issues, we recommend resetting all your data.</p>
        <div class="v35-modal-actions">
            <button class="v35-btn v35-btn-danger" onclick="confirmV35DataReset()">
                <i class="fa-solid fa-trash"></i>
                Reset Data
            </button>
            <button class="v35-btn v35-btn-secondary" onclick="cancelV35DataReset()">
                Keep My Data
            </button>
        </div>
    </div>
</div>

<div id="logOverlay" onclick="closeLog()" style="position:fixed;inset:0;background:rgba(0,0,0,0.8);display:none;align-items:center;justify-content:center;z-index:2000;backdrop-filter:blur(10px);">
    <div id="logModal" onclick="event.stopPropagation()">
        <div id="logHeader">
            <h2 style="margin:0;">Load Log <small id="logStatus" style="opacity:0.7;"></small></h2>
            <div style="display:flex;gap:12px;align-items:center;">
                <label style="display:flex;align-items:center;gap:6px;font-size:13px;">
                    <input type="checkbox" id="autoScroll" checked> Auto-scroll
                </label>
                <button class="action-btn" onclick="closeLog()">Close</button>
            </div>
        </div>
        <div id="logContent"></div>
    </div>
</div>
<div id="albumModalOverlay" class="album-modal-overlay" onclick="closeAlbumModal()">
    <div class="album-modal" onclick="event.stopPropagation()">
        <div class="album-modal-header">
            <h2 class="album-modal-title">Add from Album</h2>
            <button class="album-modal-close" onclick="closeAlbumModal()">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
        <div id="albumModalTitle" class="album-modal-subtitle"></div>
        <div class="album-modal-content" id="albumSongList"></div>
        <div class="album-modal-footer">
            <button class="m3-btn m3-btn-modal-action" onclick="deselectAllAlbumSongs()"><i class="fa-solid fa-minus"></i><span>None</span></button>
            <button class="m3-btn m3-btn-modal-action" onclick="selectAllAlbumSongs()"><i class="fa-solid fa-check"></i><span>All</span></button>
            <div style="flex:1;"></div>
            <button class="m3-btn m3-btn-tonal" onclick="closeAlbumModal()">Cancel</button>
            <button class="m3-btn m3-btn-filled" onclick="addSelectedAlbumSongs()">Add</button>
        </div>
    </div>
</div>

<!-- Folder Add to Playlist Modal -->
<div id="folderAddModalOverlay" class="album-modal-overlay" onclick="closeFolderAddModal()">
    <div class="album-modal" style="max-width: 520px;" onclick="event.stopPropagation()">
        <div class="album-modal-header">
            <h2 class="album-modal-title">Add to Playlist</h2>
            <button class="album-modal-close" onclick="closeFolderAddModal()">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
        <div id="folderAddModalSubtitle" class="album-modal-subtitle"></div>
        <div class="album-modal-content" id="folderSongList"></div>
        <div class="album-modal-footer">
            <button class="m3-btn m3-btn-modal-action" onclick="deselectAllFolderSongs()"><i class="fa-solid fa-minus"></i><span>None</span></button>
            <button class="m3-btn m3-btn-modal-action" onclick="selectAllFolderSongs()"><i class="fa-solid fa-check"></i><span>All</span></button>
            <div style="flex:1;"></div>
            <button class="m3-btn m3-btn-tonal" onclick="closeFolderAddModal()">Cancel</button>
            <button class="m3-btn m3-btn-filled" onclick="openPlaylistSelectionForFolder()">Add</button>
        </div>
    </div>
</div>

<!-- Playlist Selection Modal (for folder add) -->
<div id="playlistSelectModalOverlay" class="album-modal-overlay" onclick="closePlaylistSelectModal()">
    <div class="album-modal" style="max-width: 400px;" onclick="event.stopPropagation()">
        <div class="album-modal-header">
            <h2 class="album-modal-title">Select Playlist</h2>
            <button class="album-modal-close" onclick="closePlaylistSelectModal()">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
        <div class="album-modal-content" id="playlistSelectList" style="padding: 8px 0;"></div>
        <div class="album-modal-footer" style="border-top: none; padding-top: 0;">
            <button class="m3-btn m3-btn-filled" style="width: 100%;" onclick="createNewPlaylistForFolder()">
                <i class="fa-solid fa-plus"></i>
                <span>New Playlist</span>
            </button>
        </div>
    </div>
</div>

<div id="mobilePlayer" class="mobile-player-overlay">
    <div class="mp-header">
        <button class="mp-btn" onclick="closeMobilePlayer()"><i class="fa-solid fa-chevron-down"></i></button>
        <span style="font-weight:600;text-transform:uppercase;letter-spacing:1px;font-size:12px;">Now Playing</span>
        <button class="mp-btn" onclick="toggleSidebar()" style="font-size:20px;"><i class="fa-solid fa-list-ul"></i></button>
    </div>
    <div class="mp-art-container" id="fsArt">
        <i class="fa-solid fa-music"></i>
    </div>
    <div class="mp-info-container">
        <h2 id="fsTitle" class="truncate" style="font-size:28px;margin:0;">No Track</h2>
        <h3 id="fsArtist" class="truncate" style="font-size:18px;margin:0;opacity:0.7;font-weight:400;">Select music</h3>
        <p id="fsAlbum" class="truncate" style="font-size:14px;margin:0;opacity:0.5;"></p>
    </div>
    <div class="mp-progress-container">
        <span id="fsCurTime" style="font-size:12px;font-variant-numeric:tabular-nums;opacity:0.7;">0:00</span>
        <div id="fsProgressBg" style="flex:1;height:4px;background:var(--progress-bg, rgba(255,255,255,0.15));border-radius:2px;position:relative;">
            <div id="fsBuffFill" style="position:absolute;height:100%;width:0%;background:rgba(255,255,255,0.25);border-radius:2px;"></div>
            <div id="fsProgFill" style="position:absolute;height:100%;width:0%;background:var(--md-sys-color-primary);border-radius:2px;z-index:2;"></div>
            <input type="range" id="fsProgScrub" value="0" step="0.1" oninput="scrub(this.value)" style="width:100%;position:absolute;top:-10px;height:24px;opacity:0;cursor:pointer;z-index:3;">
        </div>
        <span id="fsDurTime" style="font-size:12px;font-variant-numeric:tabular-nums;opacity:0.7;">0:00</span>
    </div>
    <div class="mp-controls-container">
        <button class="mp-btn" id="fsBtnShuffle" onclick="toggleShuffle()" style="opacity:0.5;"><i class="fa-solid fa-shuffle"></i></button>
        <button class="mp-btn" onclick="skip(-1)" style="font-size:32px;"><i class="fa-solid fa-backward-step"></i></button>
        <div class="mp-play-btn" onclick="togglePlay()"><i id="fsPlayIcon" class="fa-solid fa-play"></i></div>
        <button class="mp-btn" onclick="skip(1)" style="font-size:32px;"><i class="fa-solid fa-forward-step"></i></button>
        <button class="mp-btn" id="fsBtnRepeat" onclick="toggleRepeat()" style="opacity:0.5;"><i class="fa-solid fa-repeat"></i></button>
    </div>
</div>

<div class="app-shell">
    <nav class="nav-rail">
        <div class="nav-item active" data-screen="library" onclick="goHome(this)"><div class="nav-icon-wrapper"><i class="fa-solid fa-house"></i></div><div class="nav-label">Home</div></div>
        <div class="nav-item" data-screen="playlist" onclick="nav(this)"><div class="nav-icon-wrapper"><i class="fa-solid fa-compact-disc"></i></div><div class="nav-label">Playlists</div></div>
        <div class="nav-item" data-screen="equalizer" onclick="nav(this)"><div class="nav-icon-wrapper"><i class="fa-solid fa-sliders-h"></i></div><div class="nav-label">Equalizer</div></div>
        <div class="nav-item" onclick="toggleSidebar()"><div class="nav-icon-wrapper"><i class="fa-solid fa-list-ul"></i></div><div class="nav-label">Queue</div></div>
        <div class="nav-item" data-screen="settings" onclick="nav(this)" style="margin-top:auto;"><div class="nav-icon-wrapper"><i class="fa-solid fa-cog"></i></div><div class="nav-label">Settings</div></div>
    </nav>
    <main class="main-container">
        <div id="library-screen" class="screen active">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:24px;">
                <div>
                    <h1 id="viewTitle" style="font-size:48px;margin:0;">Library</h1>
                    <div id="folderActions" style="display:none;margin-top:16px;gap:12px;align-items:center;">
                        <button class="m3-btn m3-btn-filled" onclick="playCurrentFolderRecursive()">
                            <i class="fa-solid fa-play"></i>
                            <span>Play All</span>
                        </button>
                        <button class="m3-btn m3-btn-tonal" onclick="shuffleCurrentFolderRecursive()">
                            <i class="fa-solid fa-shuffle"></i>
                            <span>Shuffle Play</span>
                        </button>
                        <button class="m3-btn m3-btn-tonal" onclick="openFolderAddModal()">
                            <i class="fa-solid fa-bookmark"></i>
                            <span>Add to Playlist</span>
                        </button>
                    </div>
                </div>
                <div style="display:flex;flex-direction:column;align-items:flex-end;gap:8px;">
                    <div id="progressContainer" class="progress-container">
                        <div id="progressBar" class="progress-bar"></div>
                    </div>
                    <div id="loadControls" style="display:none;gap:12px;align-items:center;">
                        <button id="cancelBtn" class="action-btn" onclick="cancelLoad()" style="background:#ff4444;border:none;color:white;">
                            <i class="fa-solid fa-stop"></i> Cancel
                        </button>
                        <button class="action-btn" onclick="showLog()" style="background:#444;border:none;color:white;">
                            <i class="fa-solid fa-list"></i> View Log
                        </button>
                    </div>
                    <small id="progressText" style="color:#aaa;font-size:12px;opacity:0.8;"></small>
                </div>
            </div>
            <div id="breadcrumb" style="display:flex;gap:8px;margin-bottom:32px;align-items:center;flex-wrap:wrap;"></div>
            <div id="folderGrid" class="folder-grid"></div>
            <table style="width:100%;border-collapse:separate;border-spacing:0 4px;margin-top:20px;"><tbody id="libSongBody"></tbody></table>
        </div>
        
        <div id="equalizer-screen" class="screen">
            <h1 style="font-size:48px;margin:0 0 32px 0;">Equalizer</h1>
            
            <div class="eq-container">
                <div class="eq-header">
                    <span style="font-weight:600;font-size:14px;letter-spacing:1px;text-transform:uppercase;opacity:0.7;">Tone & EQ</span>
                    <div class="eq-presets">
                        <select onchange="applyEqPreset(this.value)">
                            <option value="flat">Flat</option>
                            <option value="rock">Rock</option>
                            <option value="pop">Pop</option>
                            <option value="jazz">Jazz</option>
                            <option value="classical">Classical</option>
                            <option value="bass">Bass Boost</option>
                            <option value="vocal">Vocal Boost</option>
                        </select>
                    </div>
                </div>

                <div class="eq-dials-area">
                    <div class="tone-slider-row">
                        <div class="tone-label">Bass</div>
                        <input type="range" id="bassSlider" class="tone-range" min="0" max="100" value="0">
                        <div id="bassValue" class="tone-value">0%</div>
                    </div>
                    
                    <div class="tone-slider-row">
                        <div class="tone-label">Treble</div>
                        <input type="range" id="trebleSlider" class="tone-range" min="0" max="100" value="0">
                        <div id="trebleValue" class="tone-value">0%</div>
                    </div>
                </div>

                <div class="eq-sliders-grid" id="eqSliders">
                    </div>
            </div>
        </div>

        <div id="playlist-screen" class="screen">
            <h1 style="font-size:48px;margin:0 0 24px 0;">Playlists</h1>
            <div id="playlistGridContainer">
                <div style="display:flex;justify-content:flex-end;align-items:center;margin-bottom:32px;gap:12px;">
                    <button class="m3-btn m3-btn-tonal" onclick="exportPlaylists()">
                        <i class="fa-solid fa-file-export"></i>
                        <span>Export</span>
                    </button>
                    <button class="m3-btn m3-btn-tonal" onclick="document.getElementById('importFile').click()">
                        <i class="fa-solid fa-file-import"></i>
                        <span>Import</span>
                    </button>
                    <input type="file" id="importFile" accept=".goot2" style="display:none" onchange="importPlaylists(this)">
                </div>
                <div id="playlistGrid" class="folder-grid"></div>
            </div>
            <div id="playlistContentView" style="display:none;">
                <div class="playlist-breadcrumb" id="playlistBreadcrumb"></div>
                <div class="playlist-header">
                    <div class="playlist-cover" id="playlistCover">
                        <div class="no-art"><i class="fa-solid fa-compact-disc"></i></div>
                    </div>
                    <div class="playlist-info">
                        <h2 id="currentPlaylistTitle" style="font-size:40px;margin:0 0 8px 0;"></h2>
                        <div class="playlist-controls">
                            <div class="play-btn control-btn" onclick="playPlaylist(currentPlaylistName)" style="width:64px;height:64px;font-size:28px;">
                                <i class="fa-solid fa-play"></i>
                            </div>
                            <div class="play-btn control-btn shuffle" onclick="shuffleAndPlayPlaylist(currentPlaylistName)" style="width:64px;height:64px;font-size:26px;">
                                <i class="fa-solid fa-shuffle"></i>
                            </div>
                        </div>
                        <div class="playlist-management">
                            <button class="m3-btn m3-btn-tonal" onclick="renameCurrentPlaylist()">
                                <i class="fa-solid fa-pen"></i>
                                <span>Rename</span>
                            </button>
                            <button class="m3-btn m3-btn-tonal playlist-delete-btn" onclick="deleteCurrentPlaylist()">
                                <i class="fa-solid fa-trash"></i>
                                <span>Delete</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="search-container">
                    <input type="text" class="search-input" placeholder="Search cache (title/artist/album/genre/etc)..." oninput="searchSongsToAdd(this.value)">
                    <div id="searchResults" class="search-results"></div>
                </div>
                <table style="width:100%;"><tbody id="playlistSongBody"></tbody></table>
            </div>
        </div>
        <div id="settings-screen" class="screen">
            <div class="settings-header">
                <h1 class="settings-title">Settings</h1>
            </div>

            <!-- Appearance Section -->
            <div class="simple-settings-section">
                <h2 class="simple-section-title">Appearance</h2>

                <!-- Dark Mode Toggle - Entire row is clickable -->
                <label class="simple-setting-row" style="cursor: pointer;">
                    <div class="simple-setting-info">
                        <span class="simple-setting-label" id="themeModeLabel">Dark Mode</span>
                        <span class="simple-setting-desc">Tap to switch themes</span>
                    </div>
                    <div class="simple-toggle">
                        <input type="checkbox" id="themeToggle" onchange="toggleTheme()" checked>
                        <span class="simple-toggle-track">
                            <span class="simple-toggle-thumb"></span>
                        </span>
                    </div>
                </label>
            </div>

            <!-- Accent Color Section -->
            <div class="simple-settings-section">
                <h2 class="simple-section-title">Accent Color</h2>
                <div class="color-grid">
                    <button class="color-btn" style="background:#FF4D4D;" onclick="updateTheme('#FF4D4D')"></button>
                    <button class="color-btn" style="background:#FF6B6B;" onclick="updateTheme('#FF6B6B')"></button>
                    <button class="color-btn" style="background:#F59E0B;" onclick="updateTheme('#F59E0B')"></button>
                    <button class="color-btn" style="background:#84CC16;" onclick="updateTheme('#84CC16')"></button>
                    <button class="color-btn" style="background:#22C55E;" onclick="updateTheme('#22C55E')"></button>
                    <button class="color-btn" style="background:#14B8A6;" onclick="updateTheme('#14B8A6')"></button>
                    <button class="color-btn" style="background:#0EA5E9;" onclick="updateTheme('#0EA5E9')"></button>
                    <button class="color-btn" style="background:#3B82F6;" onclick="updateTheme('#3B82F6')"></button>
                    <button class="color-btn" style="background:#6366F1;" onclick="updateTheme('#6366F1')"></button>
                    <button class="color-btn" style="background:#8B5CF6;" onclick="updateTheme('#8B5CF6')"></button>
                    <button class="color-btn" style="background:#EC4899;" onclick="updateTheme('#EC4899')"></button>
                    <button class="color-btn pencil-color-btn" onclick="document.getElementById('accentPicker').click()">
                        <i class="fa-solid fa-pencil"></i>
                    </button>
                </div>
                <input type="color" id="accentPicker" onchange="updateTheme(this.value)" class="hidden-input">
            </div>

            <!-- Match Album Art Toggle -->
            <div class="simple-settings-section">
                <label class="simple-setting-row" style="cursor: pointer;">
                    <div class="simple-setting-info">
                        <span class="simple-setting-label">Match Album Art</span>
                        <span class="simple-setting-desc">Extract colors from artwork</span>
                    </div>
                    <div class="simple-toggle">
                        <input type="checkbox" id="albumColorToggle" onchange="toggleAlbumColorMode()">
                        <span class="simple-toggle-track">
                            <span class="simple-toggle-thumb"></span>
                        </span>
                    </div>
                </label>
            </div>

            <!-- Audio Section -->
            <div class="simple-settings-section">
                <h2 class="simple-section-title">Audio</h2>
                <label class="simple-setting-row" style="cursor: pointer;">
                    <div class="simple-setting-info">
                        <span class="simple-setting-label">Volume Normalization</span>
                        <span class="simple-setting-desc">Consistent volume across tracks</span>
                    </div>
                    <div class="simple-toggle">
                        <input type="checkbox" id="normToggle" onchange="toggleNormalization()">
                        <span class="simple-toggle-track">
                            <span class="simple-toggle-thumb"></span>
                        </span>
                    </div>
                </label>

                <!-- Target Loudness Slider -->
                <div style="padding: 16px 0 8px 0;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                        <span style="font-size: 14px; font-weight: 500;">Target Loudness</span>
                        <span style="font-size: 14px; font-weight: 600; color: var(--md-sys-color-primary);" id="normTargetValue">-14 LUFS</span>
                    </div>
                    <input type="range" id="normTargetSlider" class="norm-slider" min="-23" max="-8" value="-14" step="1" oninput="document.getElementById('normTargetValue').textContent = this.value + ' LUFS'" onchange="updateNormTarget(this.value)" style="width: 100%;">
                    <div style="display: flex; justify-content: space-between; margin-top: 8px; font-size: 11px; opacity: 0.6;">
                        <span>-23</span>
                        <span>-18</span>
                        <span>-14</span>
                        <span>-10</span>
                        <span>-8</span>
                    </div>
                </div>
            </div>

            <!-- Danger Zone - Remove All Metadata Button Only -->
            <div class="simple-settings-section danger-section">
                <h2 class="simple-section-title" style="color: #dc2626;">Danger Zone</h2>
                <button class="danger-btn" onclick="clearAllCache()">
                    <i class="fa-solid fa-trash"></i>
                    Remove All Metadata
                </button>
            </div>
        </div>
    </main>
    <aside class="side-sheet" id="sidebar">
        <div style="padding:24px;border-bottom:1px solid var(--md-sys-color-outline);display:flex;justify-content:space-between;align-items:center;">
            <b style="letter-spacing:1px;text-transform:uppercase;font-size:12px;opacity:0.6;">Current Queue</b>
            <button onclick="toggleSidebar()" style="background:none;border:none;color:inherit;cursor:pointer;"><i class="fa-solid fa-xmark"></i></button>
        </div>
        <div id="queueList" style="flex:1;overflow-y:auto;padding:8px 0;"></div>
    </aside>
    
    <nav class="mobile-nav">
        <div class="mobile-nav-item active" onclick="goHome(this)" data-screen="library">
            <i class="fa-solid fa-house"></i>
            <span>Home</span>
        </div>
        <div class="mobile-nav-item" onclick="nav(this)" data-screen="playlist">
            <i class="fa-solid fa-compact-disc"></i>
            <span>Playlists</span>
        </div>
        <div class="mobile-nav-item" onclick="nav(this)" data-screen="equalizer">
            <i class="fa-solid fa-sliders-h"></i>
            <span>EQ</span>
        </div>
        <div class="mobile-nav-item" onclick="toggleSidebar()">
            <i class="fa-solid fa-list-ul"></i>
            <span>Queue</span>
        </div>
        <div class="mobile-nav-item" onclick="nav(this)" data-screen="settings">
            <i class="fa-solid fa-sliders"></i>
            <span>Settings</span>
        </div>
    </nav>
</div>
<footer class="player-bar" onclick="openMobilePlayer()">
    <div style="width:340px;display:flex;align-items:center;gap:16px;">
        <div id="npArt" style="width:64px;height:64px;border-radius:12px;background:var(--md-sys-color-surface-variant);overflow:hidden;box-shadow:0 4px 16px rgba(0,0,0,0.5);transition:all 0.3s ease;">
            <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;">
                <i class="fa-solid fa-music" style="opacity:0.35;font-size:28px;"></i>
            </div>
        </div>
        <div style="flex:1;overflow:hidden;">
            <div id="npTitle" class="truncate" style="font-weight:700;font-size:15px;line-height:1.3;">No Track</div>
            <div id="npArtist" class="truncate" style="font-size:13px;opacity:0.8;margin:2px 0;">Select music</div>
            <div id="npAlbum" class="truncate" style="font-size:12px;opacity:0.6;"></div>
        </div>
    </div>
    <div style="flex:1;display:flex;flex-direction:column;align-items:center;gap:8px;">
        <div style="display:flex;align-items:center;gap:24px;">
            <i class="fa-solid fa-shuffle" id="btnShuffle" onclick="event.stopPropagation(); toggleShuffle()" style="cursor:pointer;font-size:18px;opacity:0.5;transition:all 0.3s;"></i>
            <i class="fa-solid fa-backward-step" onclick="event.stopPropagation(); skip(-1)" style="cursor:pointer;font-size:22px;"></i>
            <div class="play-btn" onclick="event.stopPropagation(); togglePlay()"><i id="playIcon" class="fa-solid fa-play"></i></div>
            <i class="fa-solid fa-forward-step" onclick="event.stopPropagation(); skip(1)" style="cursor:pointer;font-size:22px;"></i>
            <i class="fa-solid fa-repeat" id="btnRepeat" onclick="event.stopPropagation(); toggleRepeat()" style="cursor:pointer;font-size:18px;opacity:0.5;transition:all 0.3s;"></i>
        </div>
        <div style="width:100%;max-width:700px;display:flex;align-items:center;gap:14px;">
            <span id="curTime" style="font-size:12px;min-width:40px;">0:00</span>
            <div id="playerBarProgressBg" style="flex:1;height:6px;background:var(--progress-bg, rgba(255,255,255,0.15));border-radius:3px;position:relative;overflow:hidden;">
                <div id="buffFill" style="position:absolute;height:100%;width:0%;background:rgba(255,255,255,0.25);border-radius:3px;"></div>
                <div id="progFill" style="position:absolute;height:100%;width:0%;background:linear-gradient(90deg,var(--md-sys-color-primary),color-mix(in srgb,var(--md-sys-color-primary) 70%,white));border-radius:3px;box-shadow:0 0 12px var(--md-sys-color-primary);transition:width 0.18s linear;z-index:2;"></div>
                <input type="range" id="progScrub" value="0" step="0.1" oninput="event.stopPropagation(); scrub(this.value)" onclick="event.stopPropagation()" style="width:100%;position:absolute;top:-8px;opacity:0;cursor:pointer;z-index:3;">
            </div>
            <span id="durTime" style="font-size:12px;min-width:40px;">0:00</span>
        </div>
    </div>
    <div style="width:200px;display:flex;align-items:center;justify-content:flex-end;gap:12px;padding-right:20px;">
        
        <button id="playerBarExtendedBtn" class="mp-btn" onclick="event.stopPropagation(); toggleDesktopExtended()" title="Open Extended View">
            <i class="fa-solid fa-up-right-and-down-left-from-center"></i>
        </button>

        <i id="volIcon" class="fa-solid fa-volume-high" onclick="event.stopPropagation(); toggleMute()" style="cursor:pointer;width:24px;text-align:center;font-size:16px;opacity:0.8;"></i>
        <div style="width:100px;display:flex;align-items:center;">
            <input type="range" id="volSlider" min="0" max="1" step="0.01" value="1" oninput="event.stopPropagation(); setVolume(this.value)" onclick="event.stopPropagation()" style="width:100%;cursor:pointer;height:4px;accent-color:var(--md-sys-color-primary);">
        </div>
    </div>
</footer>

<audio id="player" crossorigin="anonymous" preload="auto"></audio>

<div id="desktopExtended" class="desktop-extended collapsed">
		<div id="desktopExtendedArtBg" class="desktop-extended-art-bg"></div>
		<div class="desktop-extended-art">
			<img id="desktopExtendedArtImg" class="desktop-extended-art-img" src="" alt="">
		</div>
		<button class="clean-close-fab" onclick="toggleDesktopExtended()">
			<i class="fa-solid fa-chevron-down"></i>
		</button>

		<div class="clean-player">
			<div class="clean-controls-panel">
				<div class="clean-info-panel">
					<div id="deTitle" class="clean-title">No Track</div>
					<div id="deArtist" class="clean-artist">Select music</div>

					<div class="clean-progress">
						<span id="deCurTime" class="clean-time">0:00</span>
						<div class="clean-bar-bg">
							<div id="deProgFill" class="clean-bar-fill"></div>
							<input type="range" id="deProgScrub" class="clean-scrub" value="0" step="0.1" oninput="scrub(this.value)">
						</div>
						<span id="deDurTime" class="clean-time">0:00</span>
					</div>

					<div class="clean-controls">
						<button class="clean-btn" id="deShuffleBtn" onclick="toggleShuffle()"><i class="fa-solid fa-shuffle"></i></button>
						<button class="clean-btn" onclick="skip(-1)"><i class="fa-solid fa-backward-step"></i></button>
						<button class="clean-btn play-btn-large" onclick="togglePlay()"><i id="dePlayIcon" class="fa-solid fa-play"></i></button>
						<button class="clean-btn" onclick="skip(1)"><i class="fa-solid fa-forward-step"></i></button>
						<button class="clean-btn" id="deRepeatBtn" onclick="toggleRepeat()"><i class="fa-solid fa-repeat"></i></button>
					</div>

					<div class="clean-volume">
						<i class="fa-solid fa-volume-high" id="deVolIcon" style="font-size:14px;opacity:0.7;"></i>
						<input type="range" id="deVolSlider" min="0" max="1" step="0.01" value="1" oninput="setVolume(this.value)" style="width:100px;cursor:pointer;accent-color:var(--md-sys-color-primary);">
					</div>
				</div>
			</div>

			<div class="clean-queue">
				<h3>Up Next</h3>
				<div id="deQueueList" style="text-align:left;"></div>
			</div>
		</div>
	</div>

<script>
const WORKER_URL = "https://gootapimask.jpm333678.workers.dev/";
const ROOT_ID = "1kje6wQMhMxvuI-2eYsAMVvs09JYLDo2s";

// Helper function to get image URL with proper MIME type override (for HEIC files)
function getImageUrl(id, mimeType = null) {
    if (mimeType) {
        return `${WORKER_URL}?id=${id}&mime=${encodeURIComponent(mimeType)}`;
    }
    return `${WORKER_URL}?id=${id}`;
}

// Helper function to check if a file is a HEIC/HEIF image
function isHeicFile(fileName) {
    const name = fileName.toLowerCase();
    return name.endsWith('.heic') || name.endsWith('.heif');
}

// Get appropriate MIME type for image files
function getImageMimeType(fileName, mimeType) {
    // If already a standard image type, use it as-is
    if (mimeType && (mimeType.startsWith('image/jpeg') || mimeType.startsWith('image/png') || 
        mimeType.startsWith('image/gif') || mimeType.startsWith('image/webp'))) {
        return mimeType;
    }
    // For HEIC/HEIF files, convert to JPEG for browser compatibility
    if (isHeicFile(fileName)) {
        return 'image/jpeg';
    }
    return mimeType;
}

let stack = [{id: ROOT_ID, name: "Home"}];
let queue = [], originalQueue = [];
let qIndex = -1;
let currentPlaylistName = "";
let currentQueueSource = null;
let trackMetadata = JSON.parse(localStorage.getItem('goot_meta_cache') || '{}');
let tempArtCache = {};
let albumArtCache = {};
let playlists = JSON.parse(localStorage.getItem('goot_playlists') || '{}');
let playlistCovers = JSON.parse(localStorage.getItem('goot_playlist_covers') || '{}');
let shuffleMode = false;
let repeatMode = 0;
let isLoadingAll = false;
let shouldCancelLoad = false;
let loadLog = [];
let totalFilesToLoad = 0;
let processedFiles = 0;
let logModalOpen = false;
let playlistSortable = null;
let currentAlbumMap = {};
let pendingMetadataLoads = new Set();

// Volume Normalization - Web Audio API
let audioContext = null;
let normEnabled = true;
let normTargetLUFS = -14;
let trackLoudnessCache = {};
let normGainNode = null;
let currentNormGain = 1.0;

const player = document.getElementById("player");

// ========== IndexedDB Image Cache (replaces localStorage for images) ==========
const DB_NAME = 'GootImageCache';
const DB_VERSION = 1;
const STORE_NAME = 'albumArt';
let db = null;

async function initImageDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => reject(request.error);
        request.onsuccess = () => {
            db = request.result;
            resolve(db);
        };
        
        request.onupgradeneeded = (e) => {
            const database = e.target.result;
            if (!database.objectStoreNames.contains(STORE_NAME)) {
                database.createObjectStore(STORE_NAME, { keyPath: 'key' });
            }
        };
    });
}

async function saveImageToDB(key, base64Data) {
    if (!db) await initImageDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            
            // Convert base64 to Blob for more efficient storage
            const byteCharacters = atob(base64Data.split(',')[1] || base64Data);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            const blob = new Blob([byteArray], { type: base64Data.split(';')[0].split(':')[1] || 'image/jpeg' });
            
            const request = store.put({ key, data: blob, timestamp: Date.now() });
            
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
                // If quota exceeded, try to clear old entries
                if (request.error.name === 'QuotaExceededError') {
                    clearOldImages().then(() => {
                        // Retry once
                        store.put({ key, data: blob, timestamp: Date.now() }).onsuccess = () => resolve(true);
                        store.put({ key, data: blob, timestamp: Date.now() }).onerror = () => reject(request.error);
                    }).catch(() => reject(request.error));
                } else {
                    reject(request.error);
                }
            };
        } catch (e) {
            reject(e);
        }
    });
}

async function loadImageFromDB(key) {
    if (!db) await initImageDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get(key);
            
            request.onsuccess = () => {
                if (request.result) {
                    // Convert Blob back to base64 data URL
                    const blob = request.result.data;
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(reader.error);
                    reader.readAsDataURL(blob);
                } else {
                    resolve(null);
                }
            };
            request.onerror = () => reject(request.error);
        } catch (e) {
            reject(e);
        }
    });
}

async function clearOldImages() {
    if (!db) await initImageDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.index('timestamp').openCursor();
            let deleted = 0;
            const toDelete = 50; // Delete oldest 50 entries when quota exceeded
            
            request.onsuccess = (e) => {
                const cursor = e.target.result;
                if (cursor && deleted < toDelete) {
                    cursor.delete();
                    deleted++;
                    cursor.continue();
                }
            };
            
            transaction.oncomplete = () => resolve(deleted);
            transaction.onerror = () => reject(transaction.error);
        } catch (e) {
            reject(e);
        }
    });
}

// Initialize IndexedDB on load
initImageDB().catch(console.error);

// Helper function to load album art from IndexedDB
async function loadAlbumArtFromDB(albumName) {
    try {
        const art = await loadImageFromDB(`album_${albumName}`);
        return art;
    } catch (e) {
        return null;
    }
}

// ========== End IndexedDB Image Cache ==========

// --- EQUALIZER VARS ---
let audioCtx;
let sourceNode;
let bassNode;
let trebleNode;
let eqBands = [];
let limiterNode = null;
const eqFrequencies = [60, 170, 310, 600, 1000, 3000, 6000, 12000, 14000, 16000];

// Initialize EQ state with defaults, reset if cached state is invalid
let eqState = JSON.parse(localStorage.getItem('goot_eq_state') || '{"bass":0,"treble":0,"bands":[0,0,0,0,0,0,0,0,0,0]}');

// Validate and reset EQ state if it has invalid values
if (eqState.bass < 0 || eqState.bass > 100 || eqState.treble < 0 || eqState.treble > 100) {
    eqState = { bass: 0, treble: 0, bands: [0,0,0,0,0,0,0,0,0,0] };
    localStorage.setItem('goot_eq_state', JSON.stringify(eqState));
}

// Reset EQ state to ensure clean start (fixes random audio fluctuation)
function resetEqState() {
    eqState = { bass: 0, treble: 0, bands: [0,0,0,0,0,0,0,0,0,0] };
    localStorage.setItem('goot_eq_state', JSON.stringify(eqState));
    return eqState;
}

// Call reset on first load if no valid saved state
if (!localStorage.getItem('goot_eq_state')) {
    resetEqState();
}

// Helper function to filter out m3u playlist files
function filterM3uFiles(items) {
    return items.filter(item => !item.id?.toLowerCase()?.endsWith('.m3u') && !item.name?.toLowerCase()?.endsWith('.m3u'));
}

const EQ_PRESETS = {
    flat: { bass: -12, treble: -12, bands: [0,0,0,0,0,0,0,0,0,0] },
    rock: { bass: -6, treble: -6, bands: [1,1,0,0,0,0,0,0,1,1] },
    pop: { bass: -12, treble: -12, bands: [1,1,1,0,0,0,0,0,0,0] },
    jazz: { bass: -6, treble: -12, bands: [1,1,0,0,0,0,0,0,0,1] },
    classical: { bass: -6, treble: -12, bands: [1,1,0,0,0,0,0,0,1,1] },
    bass: { bass: -3, treble: -12, bands: [2,1,1,0,0,0,0,0,0,0] },
    vocal: { bass: -12, treble: -6, bands: [-1,-1,0,0,1,1,1,0,0,0] }
};

// --- Added Spacebar Listener ---
document.addEventListener('keydown', (e) => {
    // Don't trigger if user is typing in an input field
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    if (e.key === ' ' || e.code === 'Space') {
        e.preventDefault(); // Prevent scrolling
        togglePlay();
    }
});

function initEqualizerUI() {
    // Restore sliders
    document.getElementById('bassSlider').value = eqState.bass;
    document.getElementById('bassValue').innerText = eqState.bass + '%';
    
    document.getElementById('trebleSlider').value = eqState.treble;
    document.getElementById('trebleValue').innerText = eqState.treble + '%';
    
    // Generate sliders
    const container = document.getElementById('eqSliders');
    container.innerHTML = '';
    eqFrequencies.forEach((freq, index) => {
        const val = eqState.bands[index] || 0;
        const col = document.createElement('div');
        col.className = 'eq-slider-col';
        col.innerHTML = `
            <div class="eq-slider-track">
                <input type="range" class="eq-range" min="-12" max="12" step="0.5" value="${val}" 
                       oninput="updateEqBand(${index}, this.value)">
            </div>
            <div class="eq-freq-label">${freq >= 1000 ? (freq/1000)+'k' : freq}</div>
        `;
        container.appendChild(col);
    });
}

function initAudioContext() {
    if (audioCtx) return;
    try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        sourceNode = audioCtx.createMediaElementSource(player);
        
        // 1. Bass Node (Low Shelf)
        bassNode = audioCtx.createBiquadFilter();
        bassNode.type = 'lowshelf';
        bassNode.frequency.value = 100;
        // Maps 0-100% to 0-12dB
        bassNode.gain.value = (eqState.bass / 100) * 12;
        
        // 2. Treble Node (High Shelf)
        trebleNode = audioCtx.createBiquadFilter();
        trebleNode.type = 'highshelf';
        trebleNode.frequency.value = 10000;
        // Maps 0-100% to 0-12dB
        trebleNode.gain.value = (eqState.treble / 100) * 12;

        // Chain Source -> Bass -> Treble
        sourceNode.connect(bassNode);
        bassNode.connect(trebleNode);
        
        let prevNode = trebleNode;

        // 3. EQ Bands (Peaking)
        eqBands = [];
        eqFrequencies.forEach((freq, idx) => {
            const band = audioCtx.createBiquadFilter();
            band.type = 'peaking';
            band.frequency.value = freq;
            band.Q.value = 1;
            band.gain.value = eqState.bands[idx] || 0;
            
            prevNode.connect(band);
            prevNode = band;
            eqBands.push(band);
        });

        // 4. Limiter (DynamicsCompressor) to prevent clipping
        limiterNode = audioCtx.createDynamicsCompressor();
        limiterNode.threshold.setValueAtTime(-12, audioCtx.currentTime);   // Less aggressive threshold (-12dB instead of -8dB)
        limiterNode.knee.setValueAtTime(12, audioCtx.currentTime);         // Wider knee for smoother limiting
        limiterNode.ratio.setValueAtTime(12, audioCtx.currentTime);        // Higher ratio for stronger limiting
        limiterNode.attack.setValueAtTime(0.001, audioCtx.currentTime);   // Faster attack for better clipping protection
        limiterNode.release.setValueAtTime(0.1, audioCtx.currentTime);   // Faster release to reduce pumping
        
        // 5. Makeup gain to compensate for limiter reduction
        const makeupGain = audioCtx.createGain();
        makeupGain.gain.value = 1.0;  // Keep at unity, limiter handles excess

        // 6. Connect Last Band -> Limiter -> Makeup Gain -> Destination
        prevNode.connect(limiterNode);
        limiterNode.connect(makeupGain);
        makeupGain.connect(audioCtx.destination);
    } catch(e) {
        console.warn("Web Audio API failed or not supported:", e);
    }
}

function updateBass(val) {
    val = parseInt(val);
    eqState.bass = val;
    if(bassNode) {
        // Map 0-100% to 0-12dB
        bassNode.gain.setTargetAtTime((val / 100) * 12, audioCtx.currentTime, 0.01);
    }
    document.getElementById('bassValue').innerText = val + '%';
    saveEqState();
}

function updateTreble(val) {
    val = parseInt(val);
    eqState.treble = val;
    if(trebleNode) {
        // Map 0-100% to 0-12dB
        trebleNode.gain.setTargetAtTime((val / 100) * 12, audioCtx.currentTime, 0.01);
    }
    document.getElementById('trebleValue').innerText = val + '%';
    saveEqState();
}

function updateEqBand(index, val) {
    val = parseFloat(val);
    eqState.bands[index] = val;
    if(eqBands[index]) eqBands[index].gain.value = val;
    saveEqState();
}

function applyEqPreset(name) {
    const p = EQ_PRESETS[name];
    if(!p) return;
    
    // Map preset dB values to 0-100% for bass/treble
    // Using reduced range (0-6dB) to prevent clipping
    const bassPercent = Math.round(((p.bass + 12) / 24) * 100);
    const treblePercent = Math.round(((p.treble + 12) / 24) * 100);
    
    // Update State
    eqState.bass = bassPercent;
    eqState.treble = treblePercent;
    eqState.bands = [...p.bands];
    
    // Update UI
    document.getElementById('bassSlider').value = bassPercent;
    document.getElementById('bassValue').innerText = bassPercent + '%';
    document.getElementById('trebleSlider').value = treblePercent;
    document.getElementById('trebleValue').innerText = treblePercent + '%';
    
    const sliders = document.querySelectorAll('#eqSliders .eq-range');
    sliders.forEach((input, i) => {
        if(i < eqState.bands.length) input.value = eqState.bands[i];
    });

    // Update Audio
    if(bassNode) bassNode.gain.setTargetAtTime((bassPercent / 100) * 12, audioCtx.currentTime, 0.01);
    if(trebleNode) trebleNode.gain.setTargetAtTime((treblePercent / 100) * 12, audioCtx.currentTime, 0.01);
    eqBands.forEach((b, i) => {
        if(b) b.gain.value = eqState.bands[i];
    });
    
    saveEqState();
}

function saveEqState() {
    localStorage.setItem('goot_eq_state', JSON.stringify(eqState));
}

async function getFolderContents(parentId) {
    const res = await fetch(`${WORKER_URL}?list=${parentId}`);
    if (!res.ok) {
        throw new Error(`Failed to fetch folder contents (status ${res.status})`);
    }
    const json = await res.json();
    return json.files || json || [];
}

function setTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('goot_theme', theme);
    
    const toggle = document.getElementById('themeToggle');
    if (toggle) toggle.checked = (theme === 'light');
    
    const label = document.getElementById('themeModeLabel');
    if (label) {
        label.textContent = theme === 'dark' ? 'Light Mode' : 'Dark Mode';
    }
}
function toggleTheme() {
    const current = document.documentElement.getAttribute('data-theme') || 'dark';
    const newTheme = current === 'dark' ? 'light' : 'dark';
    setTheme(newTheme);
    
    // Update toggle visual state
    const toggle = document.getElementById('themeToggle');
    const track = toggle?.parentElement.querySelector('.simple-toggle-track');
    if (toggle) toggle.checked = (newTheme === 'light');
}
const savedTheme = localStorage.getItem('goot_theme') || 'dark';
setTheme(savedTheme);

function initPlaylistSortable() {
    if (playlistSortable) playlistSortable.destroy();
    playlistSortable = new Sortable(document.getElementById('playlistSongBody'), {
        animation: 200,
        handle: '.playlist-drag-handle',
        ghostClass: 'sortable-ghost',
        onEnd: (evt) => {
            if (evt.oldIndex === evt.newIndex) return;
            const tracks = playlists[currentPlaylistName];
            const movedItem = tracks.splice(evt.oldIndex, 1)[0];
            tracks.splice(evt.newIndex, 0, movedItem);
            localStorage.setItem('goot_playlists', JSON.stringify(playlists));
            const currentId = queue[qIndex]?.id;
            renderTrackTable(tracks, document.getElementById("playlistSongBody"), true, currentPlaylistName);
            if (tracks.length > 0) {
                loadMetaAndArt(tracks[0].id, '');
            }
            if (currentQueueSource === `playlist:${currentPlaylistName}`) {
                queue = tracks.map(e => ({id: e.id}));
                const newIdx = currentId ? queue.findIndex(t => t.id === currentId) : -1;
                if (newIdx !== -1) qIndex = newIdx;
                // Defer renderQueue for smoother UI
                setTimeout(() => renderQueue(), 0);
            }
            initPlaylistSortable();
        }
    });
}

// ========== Goot v3.5 First Run Detection ==========
const GOOT_VERSION = '3.5';

// Check if this is the first time opening Goot v3.5
function checkFirstTimeV35() {
    const lastVersion = localStorage.getItem('goot_version');

    if (lastVersion !== GOOT_VERSION) {
        // Show the v3.5 welcome modal after a short delay
        setTimeout(() => {
            document.getElementById('v35Modal').classList.add('visible');
        }, 800);
    }
}

// Handle v3.5 modal confirmation
function confirmV35DataReset() {
    clearAllDataForV35();
    localStorage.setItem('goot_version', GOOT_VERSION);
    document.getElementById('v35Modal').classList.remove('visible');
}

// Handle v3.5 modal cancellation
function cancelV35DataReset() {
    // Just close the modal but still mark version as seen
    localStorage.setItem('goot_version', GOOT_VERSION);
    document.getElementById('v35Modal').classList.remove('visible');
}

// Clear all data for v3.5 upgrade
function clearAllDataForV35() {
    // Export playlists first before clearing
    if (Object.keys(playlists).length > 0) {
        exportPlaylists();
    }
    
    // Clear all Goot-related localStorage items
    const keys = [
        'goot_accent',
        'goot_album_color',
        'goot_album_accent_cache',
        'goot_meta_cache',
        'goot_album_art_cache',
        'goot_playlists',
        'goot_norm_enabled',
        'goot_norm_target',
        'goot_eq_presets',
        'goot_custom_eq'
    ];

    keys.forEach(key => localStorage.removeItem(key));

    // Clear in-memory caches
    trackMetadata = {};
    tempArtCache = {};
    albumArtCache = {};
    playlists = {};
    customEq = {};

    // Show notification and refresh after a short delay
    showNotification('Data reset! Refreshing...');
    setTimeout(() => {
        location.reload();
    }, 1500);
}

async function init() {
    // Check if first time opening v3.5
    checkFirstTimeV35();

    // Load normalization settings
    loadNormSettings();
    
    initEqualizerUI();
    updateTheme(localStorage.getItem('goot_accent') || '#ff0000');
    
    // Set album color toggle state (default to true if not set)
    const albumColorEnabled = localStorage.getItem('goot_album_color') !== 'false';
    document.getElementById('albumColorToggle').checked = albumColorEnabled;
    
    if (window.innerWidth <= 768) {
        document.getElementById("sidebar").classList.add("collapsed");
    }
    
    new Sortable(document.getElementById('queueList'), {
        animation: 200,
        handle: '.queue-drag-handle',
        ghostClass: 'sortable-ghost',
        dragClass: 'queue-sort-drag',
        onEnd: (evt) => {
            const item = queue.splice(evt.oldIndex, 1)[0];
            queue.splice(evt.newIndex, 0, item);
            if (qIndex === evt.oldIndex) qIndex = evt.newIndex;
            currentQueueSource = null;
            // Defer renderQueue for smoother drag end experience
            setTimeout(() => renderQueue(), 0);
        }
    });
    
    // Desktop extended view queue sorting
    new Sortable(document.getElementById('deQueueList'), {
        animation: 200,
        handle: '.queue-drag-handle',
        ghostClass: 'sortable-ghost',
        dragClass: 'queue-sort-drag',
        onEnd: (evt) => {
            const item = queue.splice(evt.oldIndex, 1)[0];
            queue.splice(evt.newIndex, 0, item);
            if (qIndex === evt.oldIndex) qIndex = evt.newIndex;
            currentQueueSource = null;
            // Defer renderQueue for smoother drag end experience
            setTimeout(() => renderQueue(), 0);
        }
    });
    
    renderPlaylists();
    await loadFolders(ROOT_ID);
}

async function loadFolders(id) {
    const grid = document.getElementById("folderGrid");
    const listBody = document.getElementById("libSongBody");
    
    grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:40px;opacity:0.6;"><i class="fa-solid fa-circle-notch fa-spin" style="font-size:32px;margin-bottom:12px;"></i><br>Loading Library...</div>';
    listBody.innerHTML = ''; 

    let files = [];
    try {
        files = await getFolderContents(id);
        files = files.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));
        
        // Auto-detect folder cover from images in folder
        const currentFolderName = stack[stack.length - 1].name;
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.heic', '.heif', '.bmp', '.svg'];
        const coverImage = files.find(f => {
            const name = f.name.toLowerCase();
            return f.mimeType.startsWith('image/') || 
                   imageExtensions.some(ext => name.endsWith(ext));
        });
        
        if (coverImage && currentFolderName) {
            const mimeType = getImageMimeType(coverImage.name, coverImage.mimeType);
            playlistCovers[currentFolderName] = getImageUrl(coverImage.id, mimeType);
            localStorage.setItem('goot_playlist_covers', JSON.stringify(playlistCovers));
        }
        
        grid.innerHTML = "";
        
        if (files.length === 0) {
            grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:40px;opacity:0.5;">Folder is empty</div>';
        }

        files.filter(f => f.mimeType === 'application/vnd.google-apps.folder').forEach(f => {
            const card = document.createElement("div");
            card.className = "folder-card playlist-card";
            card.dataset.folderId = f.id;
            card.dataset.folderName = f.name;

            // Check if this is a subfolder (not the root level)
            const isSubfolder = stack.length > 1;
            const playOverlay = isSubfolder ? `
                <div class="play-overlay">
                    <div class="control-group">
                        <div class="control-btn" onclick="playFolderFromCard(event, '${f.id}')">
                            <i class="fa-solid fa-play"></i>
                        </div>
                        <div class="control-btn shuffle" onclick="shuffleFolderFromCard(event, '${f.id}')">
                            <i class="fa-solid fa-shuffle"></i>
                        </div>
                        <div class="btn-label">Shuffle Play</div>
                    </div>
                </div>
            ` : '';

            card.innerHTML = `
                <div class="folder-art" id="f-art-${f.id}"><i class="fa-solid fa-folder" style="opacity:0.2;font-size:40px;"></i></div>
                <div class="folder-info"><span>${f.name}</span></div>
                ${playOverlay}
            `;
            card.onclick = (e) => {
                // Prevent navigating into folder if clicking on play/shuffle buttons
                const target = e.target;
                if (target.closest('.control-btn')) return;
                stack.push({id:f.id,name:f.name}); loadFolders(f.id);
            };
            grid.appendChild(card);
            // Small delay to ensure DOM is ready before fetching art
            setTimeout(() => fetchFolderArt(f.id), 10);
        });
        
        document.querySelectorAll('.folder-card').forEach((c,i) => setTimeout(() => c.classList.add('loaded'), 60*i));
        
        const tracks = files.filter(f => f.mimeType.includes('audio'));
        renderTrackTable(tracks, listBody);
        
        document.getElementById("viewTitle").innerText = stack[stack.length-1].name;
        updateBreadcrumbs();

        // Show folder actions if not at root level
        const folderActions = document.getElementById('folderActions');
        if (stack.length > 1) {
            folderActions.style.display = 'flex';
        } else {
            folderActions.style.display = 'none';
        }
    } catch(e) {
        console.error('Error loading folders:', e);
        grid.innerHTML = `<div style="grid-column:1/-1;text-align:center;padding:40px;color:#ff4444;"><i class="fa-solid fa-triangle-exclamation" style="font-size:32px;margin-bottom:12px;"></i><br>Error loading content.<br><small>${e.message || "Network Error"}</small><br><button class="action-btn" style="margin-top:16px;" onclick="loadFolders('${id}')">Retry</button></div>`;
    }
}

async function fetchFolderArt(fid) {
    const container = document.getElementById(`f-art-${fid}`);
    if (!container) {
        console.log('Container not found for folder:', fid);
        return;
    }
    
    try {
        const files = await getFolderContents(fid);
        // Look for any image file, not just files with "cover" in the name
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.heic', '.heif', '.bmp', '.svg'];
        const cover = files.find(f => {
            const name = f.name.toLowerCase();
            return f.mimeType.startsWith('image/') || 
                   imageExtensions.some(ext => name.endsWith(ext));
        });
        
        if (cover) {
            const mimeType = getImageMimeType(cover.name, cover.mimeType);
            const imageUrl = getImageUrl(cover.id, mimeType);
            console.log('Loading cover for folder', fid, ':', cover.name, '->', imageUrl);
            
            const img = new Image();
            img.onload = () => {
                console.log('Cover loaded for folder:', fid);
                img.classList.add('loaded');
                const icon = container.querySelector('i');
                if (icon) icon.style.opacity = "0";
            };
            img.onerror = () => {
                console.error('Failed to load cover for folder', fid, ':', imageUrl);
            };
            img.src = imageUrl;
            container.appendChild(img);
        } else {
            console.log('No cover image found for folder:', fid, '- files:', files.map(f => f.name));
        }
    } catch(e) {
        console.error('Error fetching folder art:', e);
    }
}

function renderTrackTable(tracks, container, isPlaylist = false, pName = "") {
    container.innerHTML = "";
    // Filter out m3u playlist files
    tracks = filterM3uFiles(tracks);
    
    tracks.forEach((t, i) => {
        const m = trackMetadata[t.id] || {title: t.name || "...", artist: "...", album: "..."};
        const tr = document.createElement("tr");
        tr.className = "song-row";
        tr.id = `row-${t.id}`;
        
        // Add drag handle column for playlist view
        const handleColumn = isPlaylist ? `<td class="playlist-drag-handle-cell" style="padding:0;"><div class="playlist-drag-handle"><i class="fa-solid fa-grip-vertical"></i></div></td>` : '';
        
        tr.innerHTML = `
            ${handleColumn}
            <td style="width:64px;"><div class="track-art-${t.id}" style="width:48px;height:48px;border-radius:8px;background:var(--md-sys-color-surface-variant);overflow:hidden;display:flex;align-items:center;justify-content:center;"><i class="fa-solid fa-music" style="opacity:0.2"></i></div></td>
            <td><div class="meta-title truncate" style="font-weight:600;font-size:14px;">${m.title}</div><div class="meta-artist" style="font-size:12px;opacity:0.5">${m.artist}</div></td>
            <td class="meta-album truncate" style="font-size:12px;opacity:0.5">${m.album}</td>
            <td style="text-align:right">
                <div class="track-actions" style="display:flex;gap:8px;justify-content:flex-end;">
                    <button class="m3-btn m3-btn-tonal" onclick="event.stopPropagation(); addToQueue('${t.id}')" title="Add to Queue">
                        <i class="fa-solid fa-list" style="font-size:16px;"></i>
                        <span>Add to Queue</span>
                    </button>
                    <button class="m3-btn m3-btn-tonal" onclick="event.stopPropagation(); ${isPlaylist ? `removeFromPlaylist(event, '${pName}', '${t.id}')` : `openPlaylistModal(event, '${t.id}')`}" title="${isPlaylist ? 'Remove from Playlist' : 'Add to Playlist'}">
                        <i class="fa-solid ${isPlaylist ? 'fa-minus' : 'fa-bookmark'}" style="font-size:16px;"></i>
                        <span>${isPlaylist ? 'Remove' : 'Add to Playlist'}</span>
                    </button>
                </div>
            </td>`;
        tr.onclick = e => {
            // Don't trigger if clicking on drag handle or action button
            if(!e.target.closest('button') && !e.target.closest('.playlist-drag-handle')) {
                queue = tracks.map(track => ({id: track.id}));
                qIndex = i;
                currentQueueSource = isPlaylist ? `playlist:${pName}` : null;
                // play() will handle renderQueue() deferred
                play(i);
            }
        };
        container.appendChild(tr);
    });
    
    // Load metadata in parallel (all at once)
    loadMetadataSequentially(tracks, 0);
}

async function loadMetadataSequentially(tracks, index) {
    // No longer sequential - load all at once in parallel
    if (index === 0 && tracks.length > 0) {
        Promise.all(tracks.map(t => loadMetaAndArt(t.id, t.name || ''))).catch(() => {});
    }
}

async function loadMetaAndArt(id, name) {
    if (pendingMetadataLoads.has(id)) return;
    
    const album = trackMetadata[id]?.album;
    if (album && albumArtCache[album]) {
        applyArtToUI(id, albumArtCache[album]);
        updateFolderModalArt(id);
        // Defer color extraction to not block UI
        setTimeout(() => extractColorFromAlbumArt(id), 50);
        return;
    }
    
    if (tempArtCache[id]) {
        applyArtToUI(id, tempArtCache[id]);
        updateFolderModalArt(id);
        // Defer color extraction to not block UI
        setTimeout(() => extractColorFromAlbumArt(id), 50);
        return;
    }
    
    // Try to load from IndexedDB if not in memory cache
    if (album && album !== "Unknown") {
        const dbArt = await loadImageFromDB(`album_${album}`);
        if (dbArt) {
            albumArtCache[album] = dbArt;
            applyArtToUI(id, dbArt);
            updateFolderModalArt(id);
            setTimeout(() => extractColorFromAlbumArt(id), 50);
            return;
        }
    }
    
    pendingMetadataLoads.add(id);
    
    try {
        const res = await fetch(`${WORKER_URL}?id=${id}`, {
            mode: 'cors',
            credentials: 'omit',
            cache: 'no-store',
            headers: { 'Range': 'bytes=0-4194303' }  // 4 MB
        });
        if(!res.ok) throw new Error("Fetch failed");
        const buf = await res.arrayBuffer();
        jsmediatags.read(new Blob([buf]), {
            onSuccess: tag => {
                const m = {
                    title: tag.tags.title || name || "Unknown",
                    artist: tag.tags.artist || "Unknown",
                    album: tag.tags.album || "Unknown",
                    genre: tag.tags.genre || "",
                    year: tag.tags.year || "",
                    composer: tag.tags.composer || "",
                    track: tag.tags.track || ""
                };
                trackMetadata[id] = m;
                localStorage.setItem('goot_meta_cache', JSON.stringify(trackMetadata));
                
                // Update Library/Playlist Table Rows
                document.querySelectorAll(`tr#row-${id}`).forEach(r => {
                    r.querySelector('.meta-title').innerText = m.title;
                    r.querySelector('.meta-artist').innerText = m.artist;
                    r.querySelector('.meta-album').innerText = m.album;
                });
                
                // Update Queue Items
                document.querySelectorAll(`.q-row-${id}`).forEach(qItem => {
                    const tEl = qItem.querySelector('.q-title');
                    const aEl = qItem.querySelector('.q-artist');
                    if(tEl) tEl.innerText = m.title;
                    if(aEl) aEl.innerText = m.artist;
                });
                
                // Update Player Bar / Mobile Player / Desktop Extended View if this is the current song
                if (queue[qIndex]?.id === id) {
                    document.getElementById("npTitle").innerText = m.title;
                    document.getElementById("npArtist").innerText = m.artist;
                    document.getElementById("npAlbum").innerText = m.album;
                    document.getElementById("fsTitle").innerText = m.title;
                    document.getElementById("fsArtist").innerText = m.artist;
                    document.getElementById("fsAlbum").innerText = m.album;
                    
                    // Update Desktop Extended View
                    const deTitle = document.getElementById("deTitle");
                    const deArtist = document.getElementById("deArtist");
                    if(deTitle) deTitle.innerText = m.title;
                    if(deArtist) deArtist.innerText = m.artist;
                }

                if (document.getElementById("searchResults")?.style.display === "block") {
                    searchSongsToAdd(document.querySelector(".search-input")?.value || "");
                }
                if (tag.tags.picture) {
                    const {data, format} = tag.tags.picture;
                    let s = ""; for(let i=0;i<data.length;i++) s+=String.fromCharCode(data[i]);
                    const base64 = `data:${format};base64,${btoa(s)}`;
                    tempArtCache[id] = base64;
                    
                    // Defer color extraction to not block UI
                    setTimeout(() => extractColorFromAlbumArt(id), 50);
                    
                    if (m.album && m.album !== "Unknown") {
                        albumArtCache[m.album] = base64;
                        // Save to IndexedDB (much larger capacity than localStorage)
                        saveImageToDB(`album_${m.album}`, base64).catch(() => {});
                        
                        // Defer color extraction for other tracks in same album
                        setTimeout(() => {
                            queue.forEach(qt => {
                                const qtMeta = trackMetadata[qt.id];
                                if (qtMeta && qtMeta.album === m.album) {
                                    extractColorFromAlbumArt(qt.id);
                                }
                            });
                        }, 100);
                        
                        // Also update UI for other tracks with same album
                        Object.keys(trackMetadata).forEach(otherId => {
                            if (trackMetadata[otherId].album === m.album && otherId !== id) {
                                applyArtToUI(otherId, base64);
                            }
                        });
                        
                        // Update currently playing track if it's on this album
                        if (queue[qIndex]?.id && trackMetadata[queue[qIndex].id]?.album === m.album) {
                            applyArtToUI(queue[qIndex].id, base64);
                            // Update player UI
                            const npArt = document.getElementById("npArt");
                            if (npArt) {
                                npArt.innerHTML = `<img src="${base64}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                            }
                            const fsArt = document.getElementById("fsArt");
                            if (fsArt) {
                                fsArt.innerHTML = `<img src="${base64}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                            }
                            const deArt = document.getElementById("desktopExtendedArtImg");
                            if (deArt) {
                                deArt.src = base64;
                                deArt.classList.add('visible');
                            }
                            const deBg = document.getElementById("desktopExtendedArtBg");
                            if (deBg) {
                                deBg.style.backgroundImage = `url(${base64})`;
                                deBg.classList.add('visible');
                            }
                        }
                    }
                    
                    applyArtToUI(id, base64);
                    updateFolderModalArt(id);
                    // Extract color for the current track
                    extractColorFromAlbumArt(id);
                    document.querySelectorAll('.playlist-card, #playlistCover').forEach(el => {
                        if (el.classList.contains('playlist-card')) {
                            const plName = el.dataset.name;
                        if (playlists[plName]?.[0]?.id === id) {
                                const art = el.querySelector('.folder-art');
                                if (art) art.innerHTML = `<img src="${base64}" class="loaded" style="width:100%;height:100%;object-fit:cover;position:absolute;inset:0;">`;
                            }
                        } else if (el.id === 'playlistCover' && currentPlaylistName) {
                            if (playlists[currentPlaylistName]?.[0]?.id === id) {
                                el.innerHTML = `<img src="${base64}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                            }
                        }
                    });
                }
                pendingMetadataLoads.delete(id);
            },
            onError: () => {
                pendingMetadataLoads.delete(id);
            }
        });
    } catch(e) {
        pendingMetadataLoads.delete(id);
    }
}

function applyArtToUI(id, base64) {
    document.querySelectorAll(`.track-art-${id}`).forEach(el => {
        el.innerHTML = `<img src="${base64}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
    });
    if (queue[qIndex]?.id === id) {
        document.getElementById("npArt").innerHTML = `<img src="${base64}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        document.getElementById("fsArt").innerHTML = `<img src="${base64}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        
        // Update desktop extended view album art
        const deArt = document.getElementById("desktopExtendedArtImg");
        const deBg = document.getElementById("desktopExtendedArtBg");
        if(deArt) {
            deArt.src = base64;
            deArt.classList.add('visible');
        }
        if(deBg) {
            deBg.style.backgroundImage = `url(${base64})`;
            deBg.classList.add('visible');
        }
        
        // Defer color extraction to not block UI
        setTimeout(() => extractColorFromAlbumArt(id), 50);
    }
}

function renderQueue() {
    const qList = document.getElementById("queueList");
    const deQList = document.getElementById("deQueueList");
    
    // Use document fragments to batch DOM insertions
    const sidebarFragment = document.createDocumentFragment();
    const deFragment = document.createDocumentFragment();
    
    qList.innerHTML = "";
    if (deQList) deQList.innerHTML = "";

    // Filter out m3u playlist files from queue display
    const filteredQueue = filterM3uFiles(queue);
    
    filteredQueue.forEach((t,i) => {
        // Find the actual index in the original queue for proper playback
        const actualIndex = queue.findIndex(qt => qt.id === t.id);
        const m = trackMetadata[t.id] || {title:"...",artist:"...",album:"..."};
        const isActive = actualIndex === qIndex;
        
        const album = m.album;
        let artHTML = '<i class="fa-solid fa-music" style="opacity:0.2"></i>';
        
        if (tempArtCache[t.id]) {
            artHTML = `<img src="${tempArtCache[t.id]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        } else if (album && album !== "Unknown" && albumArtCache[album]) {
            artHTML = `<img src="${albumArtCache[album]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        }
        
        // Create sidebar queue item
        const item = document.createElement("div");
        item.className = `queue-item ${isActive?'active':''}`;
        item.classList.add(`q-row-${t.id}`);
        
        item.innerHTML = `
            <div class="queue-hover-menu">
                <button class="m3-btn m3-btn-filled" onclick="event.stopPropagation(); openPlaylistModal(event, '${t.id}')">
                    <i class="fa-solid fa-bookmark" style="font-size:14px;"></i>
                    <span>Add to Playlist</span>
                </button>
                <button class="m3-btn m3-btn-tonal" onclick="event.stopPropagation(); removeFromQueue('${t.id}')">
                    <i class="fa-solid fa-trash" style="font-size:14px;"></i>
                    <span>Remove from Queue</span>
                </button>
            </div>
            <div class="queue-item-content">
                <div class="queue-drag-handle"><i class="fa-solid fa-grip-vertical"></i></div>
                <div style="width:44px;height:44px;border-radius:6px;background:var(--md-sys-color-surface-variant);overflow:hidden;display:flex;align-items:center;justify-content:center;" class="track-art-${t.id}">
                    ${artHTML}
                </div>
                <div style="flex:1;overflow:hidden;">
                    <div class="q-title" style="font-weight:600;font-size:14px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${m.title}</div>
                    <div class="q-artist" style="font-size:12px;opacity:0.7;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${m.artist}</div>
                </div>
            </div>
            <button class="queue-ellipsis" onclick="event.stopPropagation()">
                <i class="fa-solid fa-ellipsis"></i>
            </button>
        `;
        
        item.onclick = (e) => {
            if (!e.target.closest('.queue-drag-handle') && !e.target.closest('.m3-btn')) {
                play(actualIndex);
                currentQueueSource = null;
            }
        };
        sidebarFragment.appendChild(item);
        
        // Create desktop extended queue item
        if (deQList) {
            const deItem = document.createElement("div");
            deItem.className = `queue-item ${isActive?'active':''}`;
            deItem.classList.add(`q-row-${t.id}`);
            
            deItem.innerHTML = `
                <div class="queue-hover-menu">
                    <button class="m3-btn m3-btn-filled" onclick="event.stopPropagation(); openPlaylistModal(event, '${t.id}')">
                        <i class="fa-solid fa-bookmark" style="font-size:14px;"></i>
                        <span>Add to Playlist</span>
                    </button>
                    <button class="m3-btn m3-btn-tonal" onclick="event.stopPropagation(); removeFromQueue('${t.id}')">
                        <i class="fa-solid fa-trash" style="font-size:14px;"></i>
                        <span>Remove from Queue</span>
                    </button>
                </div>
                <div class="queue-item-content">
                    <div class="queue-drag-handle"><i class="fa-solid fa-grip-vertical"></i></div>
                    <div style="width:44px;height:44px;border-radius:6px;background:var(--md-sys-color-surface-variant);overflow:hidden;display:flex;align-items:center;justify-content:center;" class="track-art-${t.id}">
                        ${artHTML}
                    </div>
                    <div class="truncate" style="flex:1">
                        <div class="q-title" style="font-weight:600;font-size:14px;">${m.title}</div>
                        <div class="q-artist" style="font-size:12px;opacity:0.7;">${m.artist}</div>
                    </div>
                </div>
                <button class="queue-ellipsis" onclick="event.stopPropagation()">
                    <i class="fa-solid fa-ellipsis"></i>
                </button>
            `;
            
            deItem.onclick = (e) => {
                if (!e.target.closest('.queue-drag-handle') && !e.target.closest('.m3-btn')) {
                    play(actualIndex);
                    currentQueueSource = null;
                }
            };
            deFragment.appendChild(deItem);
        }

        if (!tempArtCache[t.id] && !(album && albumArtCache[album])) {
            loadMetaAndArt(t.id, '');
        }
    });
    
    // Batch append fragments to DOM
    qList.appendChild(sidebarFragment);
    if (deQList) deQList.appendChild(deFragment);
}

function play(idx) {
    if (idx<0 || idx>=queue.length) return;
    qIndex = idx;
    const t = queue[idx];
    player.src = WORKER_URL + "?id=" + t.id;
    player.play().catch(()=>{});
    
    // Init Audio Context on first play interaction
    initNormalizationAudio();
    
    const m = trackMetadata[t.id] || {title:"Unknown",artist:"Unknown",album:"Unknown"};
    
    document.getElementById("npTitle").innerText = m.title;
    document.getElementById("npArtist").innerText = m.artist;
    document.getElementById("npAlbum").innerText = m.album;
    
    // Clean UI
    const deTitle = document.getElementById("deTitle");
    const deArtist = document.getElementById("deArtist");
    if(deTitle) deTitle.innerText = m.title;
    if(deArtist) deArtist.innerText = m.artist;
    
    document.getElementById("fsTitle").innerText = m.title;
    document.getElementById("fsArtist").innerText = m.artist;
    document.getElementById("fsAlbum").innerText = m.album;

    const album = m.album;
    let artHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;"><i class="fa-solid fa-music" style="opacity:0.35;font-size:28px;"></i></div>';
    let fsArtHTML = '<i class="fa-solid fa-music"></i>';
    let rawSrc = "";
    
    // Priority 1: Use track-specific art if available
    if (tempArtCache[t.id]) {
        rawSrc = tempArtCache[t.id];
        const imgTag = `<img src="${rawSrc}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        artHTML = imgTag;
        fsArtHTML = imgTag;
    } 
    // Priority 2: Use cached album art from any track on same album
    else if (album && album !== "Unknown" && albumArtCache[album]) {
        rawSrc = albumArtCache[album];
        const imgTag = `<img src="${rawSrc}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        artHTML = imgTag;
        fsArtHTML = imgTag;
        // Track now uses album art, so apply it to this track's UI
        applyArtToUI(t.id, rawSrc);
    }
    // Priority 3: Try loading from IndexedDB
    else if (album && album !== "Unknown") {
        loadAlbumArtFromDB(album).then(dbArt => {
            if (dbArt) {
                albumArtCache[album] = dbArt;
                const imgTag = `<img src="${dbArt}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                document.getElementById("npArt").innerHTML = imgTag;
                document.getElementById("fsArt").innerHTML = imgTag;
                applyArtToUI(t.id, dbArt);
                
                // Update desktop extended view
                const deArt = document.getElementById("desktopExtendedArtImg");
                if (deArt) {
                    deArt.src = dbArt;
                    deArt.classList.add('visible');
                }
            }
        });
        // Also trigger metadata load
        if (!pendingMetadataLoads.has(t.id)) {
            loadMetaAndArt(t.id, '');
        }
    }
    // Priority 4: Load metadata for this track (will populate album cache)
    else if (!pendingMetadataLoads.has(t.id)) {
        loadMetaAndArt(t.id, '');
    }
    
    document.getElementById("npArt").innerHTML = artHTML;
    document.getElementById("fsArt").innerHTML = fsArtHTML;
    
    // Update desktop extended view album art
    const deArt = document.getElementById("desktopExtendedArtImg");
    if (deArt) {
        if(rawSrc) {
            deArt.src = rawSrc;
            deArt.classList.add('visible');
        } else {
            deArt.src = "";
            deArt.classList.remove('visible');
        }
    }
    
    // Update desktop extended view blurred background
    const deBg = document.getElementById("desktopExtendedArtBg");
    if(deBg) {
        if(rawSrc) {
            deBg.style.backgroundImage = `url(${rawSrc})`;
            deBg.classList.add('visible');
        } else {
            deBg.style.backgroundImage = '';
            deBg.classList.remove('visible');
        }
    }
    
    // Extract color from album art if feature is enabled - only if art is available
    // Defer to not block UI responsiveness
    if (rawSrc) {
        setTimeout(() => extractColorFromAlbumArt(t.id), 10);
    }
    
    document.body.classList.add('playing');
    // Defer queue rendering to prevent UI blocking
    setTimeout(() => renderQueue(), 0);
}

function playPlaylist(name) {
    const pl = playlists[name];
    if (!pl || pl.length === 0) return;
    currentQueueSource = `playlist:${name}`;
    // Filter out m3u playlist files
    const filtered = filterM3uFiles(pl);
    queue = filtered.map(entry => ({id: entry.id}));
    qIndex = 0;
    // play(0) will handle renderQueue() deferred
    play(0);
}

function shuffleAndPlayPlaylist(name) {
    const pl = playlists[name];
    if (!pl || pl.length === 0) return;
    currentQueueSource = null;
    // Filter out m3u playlist files
    const filtered = filterM3uFiles(pl);
    let shuffled = [...filtered];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    queue = shuffled.map(entry => ({id: entry.id}));
    qIndex = 0;
    // play(0) will handle renderQueue() deferred
    play(0);
}

function playPlaylistFromCard(e) {
    e.stopPropagation();
    const card = e.currentTarget.closest('.playlist-card');
    if (card) playPlaylist(card.dataset.name);
}

function shufflePlayFromCard(e) {
    e.stopPropagation();
    const card = e.currentTarget.closest('.playlist-card');
    if (card) shuffleAndPlayPlaylist(card.dataset.name);
}

// Play all tracks in a folder
async function playFolderFromCard(e, folderId) {
    e.stopPropagation();
    try {
        const files = await getFolderContents(folderId);
        const tracks = files.filter(f => f.mimeType.includes('audio'));
        // Sort tracks by file name (same as when navigating into folder)
        tracks.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));
        if (tracks.length === 0) {
            showNotification('No audio files in this folder');
            return;
        }

        // Build queue from folder tracks
        queue = tracks.map(f => ({
            id: f.id,
            name: f.name
        }));

        qIndex = 0;
        currentQueueSource = 'folder';

        // Load all metadata in parallel (same as renderTrackTable)
        loadMetadataSequentially(tracks, 0);

        await play(qIndex);
        renderQueue();

        showNotification(`Playing ${queue.length} tracks from folder`);
    } catch (error) {
        console.error('Error playing folder:', error);
        showNotification('Error playing folder');
    }
}

// Shuffle and play all tracks in a folder
async function shuffleFolderFromCard(e, folderId) {
    e.stopPropagation();
    try {
        const files = await getFolderContents(folderId);
        const tracks = files.filter(f => f.mimeType.includes('audio'));
        // Sort tracks by file name (same as when navigating into folder)
        tracks.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));
        if (tracks.length === 0) {
            showNotification('No audio files in this folder');
            return;
        }

        // Build queue from folder tracks
        queue = tracks.map(f => ({
            id: f.id,
            name: f.name
        }));

        // Shuffle queue
        for (let i = queue.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [queue[i], queue[j]] = [queue[j], queue[i]];
        }

        qIndex = 0;
        currentQueueSource = 'folder';

        // Load all metadata in parallel (same as renderTrackTable)
        loadMetadataSequentially(tracks, 0);

        await play(qIndex);
        renderQueue();

        showNotification(`Shuffling ${queue.length} tracks from folder`);
    } catch (error) {
        console.error('Error shuffling folder:', error);
        showNotification('Error playing folder');
    }
}

// Recursively get all audio files from a folder and its subfolders
async function getAllAudioFilesRecursive(folderId) {
    const allFiles = [];

    async function traverse(folderId) {
        const files = await getFolderContents(folderId);
        const subfolders = files.filter(f => f.mimeType === 'application/vnd.google-apps.folder');
        const audioFiles = files.filter(f => f.mimeType.includes('audio'));

        // Add audio files to the list
        allFiles.push(...audioFiles);

        // Recursively traverse subfolders
        for (const folder of subfolders) {
            await traverse(folder.id);
        }
    }

    await traverse(folderId);
    return allFiles;
}

// Play all tracks in current folder and subfolders recursively
async function playCurrentFolderRecursive() {
    const currentFolderId = stack[stack.length - 1].id;

    try {
        showNotification('Loading all tracks...');
        const tracks = await getAllAudioFilesRecursive(currentFolderId);

        if (tracks.length === 0) {
            showNotification('No audio files found');
            return;
        }

        // Sort tracks by file name
        tracks.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));

        // Build queue
        queue = tracks.map(f => ({
            id: f.id,
            name: f.name
        }));

        qIndex = 0;
        currentQueueSource = 'folder';

        // Load all metadata in parallel
        loadMetadataSequentially(tracks, 0);

        await play(qIndex);
        renderQueue();

        showNotification(`Playing ${queue.length} tracks from folder`);
    } catch (error) {
        console.error('Error playing folder recursively:', error);
        showNotification('Error playing folder');
    }
}

// Shuffle and play all tracks in current folder and subfolders recursively
async function shuffleCurrentFolderRecursive() {
    const currentFolderId = stack[stack.length - 1].id;

    try {
        showNotification('Loading all tracks...');
        const tracks = await getAllAudioFilesRecursive(currentFolderId);

        if (tracks.length === 0) {
            showNotification('No audio files found');
            return;
        }

        // Sort tracks by file name first
        tracks.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));

        // Build queue
        queue = tracks.map(f => ({
            id: f.id,
            name: f.name
        }));

        // Shuffle queue
        for (let i = queue.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [queue[i], queue[j]] = [queue[j], queue[i]];
        }

        qIndex = 0;
        currentQueueSource = 'folder';

        // Load all metadata in parallel
        loadMetadataSequentially(tracks, 0);

        await play(qIndex);
        renderQueue();

        showNotification(`Shuffling ${queue.length} tracks from folder`);
    } catch (error) {
        console.error('Error shuffling folder recursively:', error);
        showNotification('Error playing folder');
    }
}

function renderPlaylists() {
    const grid = document.getElementById("playlistGrid");
    grid.innerHTML = "";

    // Add big square "New Playlist" card at the beginning
    const newCard = document.createElement("div");
    newCard.className = "folder-card playlist-card new-playlist-card";
    newCard.innerHTML = `
        <div class="new-playlist-icon">
            <i class="fa-solid fa-plus"></i>
        </div>
        <div class="new-playlist-label">New Playlist</div>
    `;
    newCard.onclick = () => createNewPlaylist(false);
    grid.appendChild(newCard);
    setTimeout(() => newCard.classList.add('loaded'), 0);

    Object.keys(playlists).sort().forEach(name => {
        const card = document.createElement("div");
        card.className = "folder-card playlist-card";
        card.dataset.name = name;
        card.innerHTML = `
            <div class="folder-art">
                <i class="fa-solid fa-compact-disc" style="opacity:0.2;font-size:40px;"></i>
            </div>
            <div class="folder-info"><span>${name}</span></div>
            <div class="play-overlay">
                <div class="control-group">
                    <div class="control-btn" onclick="playPlaylistFromCard(event)">
                        <i class="fa-solid fa-play"></i>
                    </div>
                    <div class="control-btn shuffle" onclick="shufflePlayFromCard(event)">
                        <i class="fa-solid fa-shuffle"></i>
                    </div>
                    <div class="btn-label">Shuffle Play</div>
                </div>
            </div>
        `;
        const artContainer = card.querySelector('.folder-art');
        
        // Try to get art from folder cover first (auto-detected from Google Drive folders)
        let foundArt = false;
        if (playlistCovers[name]) {
            const img = new Image();
            img.onload = () => {
                img.classList.add('loaded');
                artContainer.innerHTML = '';
                artContainer.appendChild(img);
            };
            img.src = playlistCovers[name];
            foundArt = true;
        }
        
        if (!foundArt && Array.isArray(playlists[name]) && playlists[name].length > 0) {
            const firstId = playlists[name][0].id;
            const firstMeta = trackMetadata[firstId];
            const album = firstMeta?.album;
            
            // Try to get art from album cache first (any track in same album)
            if (album && album !== "Unknown") {
                let albumArt = albumArtCache[album];
                if (!albumArt) {
                    // Try loading from IndexedDB asynchronously
                    loadAlbumArtFromDB(album).then(art => {
                        if (art) {
                            albumArtCache[album] = art;
                            artContainer.innerHTML = `<img src="${art}" class="loaded" style="width:100%;height:100%;object-fit:cover;position:absolute;inset:0;">`;
                        }
                    });
                } else {
                    artContainer.innerHTML = `<img src="${albumArt}" class="loaded" style="width:100%;height:100%;object-fit:cover;position:absolute;inset:0;">`;
                }
            }
            
            // Fallback to first track's individual art
            if (!album || album === "Unknown") {
                if (tempArtCache[firstId]) {
                    artContainer.innerHTML = `<img src="${tempArtCache[firstId]}" class="loaded" style="width:100%;height:100%;object-fit:cover;position:absolute;inset:0;">`;
                }
            }
        }
        card.onclick = () => {
            currentPlaylistName = name;
            document.getElementById("playlistGridContainer").style.display = "none";
            document.getElementById("playlistContentView").style.display = "block";
            document.getElementById("currentPlaylistTitle").innerText = name;
            document.getElementById("playlistBreadcrumb").innerHTML = `
                <div class="chip" onclick="backToPlaylistGrid()">Playlists</div>
                <i class="fa-solid fa-chevron-right" style="opacity:0.4;"></i>
                <div class="chip" style="background:var(--md-sys-color-primary-container);color:var(--md-sys-color-primary);">${name}</div>
            `;
            const coverEl = document.getElementById("playlistCover");
            coverEl.innerHTML = '<div class="no-art"><i class="fa-solid fa-compact-disc"></i></div>';
            
            // Try to get art from folder cover first (auto-detected from Google Drive folders)
            if (playlistCovers[name]) {
                const img = new Image();
                img.onload = () => {
                    img.classList.add('loaded');
                    coverEl.innerHTML = '';
                    coverEl.appendChild(img);
                };
                img.src = playlistCovers[name];
            } else if (Array.isArray(playlists[name]) && playlists[name].length > 0) {
                const firstId = playlists[name][0].id;
                const firstMeta = trackMetadata[firstId];
                const album = firstMeta?.album;

                // Try to get art from album cache first (any track in same album)
                if (album && album !== "Unknown") {
                    let albumArt = albumArtCache[album];
                    if (albumArt) {
                        coverEl.innerHTML = `
                            <img src="${albumArt}" class="loaded" style="width:100%;height:100%;object-fit:cover;">
                        `;
                    } else {
                        // Try loading from IndexedDB asynchronously
                        loadAlbumArtFromDB(album).then(art => {
                            if (art) {
                                albumArtCache[album] = art;
                                coverEl.innerHTML = `
                                    <img src="${art}" class="loaded" style="width:100%;height:100%;object-fit:cover;">
                                `;
                            }
                        });
                        // Also trigger metadata load
                        loadMetaAndArt(firstId, '');
                    }
                } else {
                    // No album, try individual track art
                    if (tempArtCache[firstId]) {
                        coverEl.innerHTML = `
                            <img src="${tempArtCache[firstId]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">
                        `;
                    } else {
                        loadMetaAndArt(firstId, '');
                    }
                }
            }
            renderTrackTable(playlists[name], document.getElementById("playlistSongBody"), true, name);
            initPlaylistSortable();
        };
        grid.appendChild(card);
        if (Array.isArray(playlists[name]) && playlists[name].length > 0) {
            loadMetaAndArt(playlists[name][0].id, '');
        }
    });
    // Animate existing playlist cards (skipping the new card at index 0)
    const existingCards = document.querySelectorAll('#playlistGrid .folder-card:not(.new-playlist-card)');
    existingCards.forEach((c, i) => setTimeout(() => c.classList.add('loaded'), 60 * i));
}

function backToPlaylistGrid() {
    document.getElementById("playlistGridContainer").style.display="block";
    document.getElementById("playlistContentView").style.display="none";
    if (playlistSortable) {
        playlistSortable.destroy();
        playlistSortable = null;
    }
}

function searchSongsToAdd(query) {
    const div = document.getElementById("searchResults");
    if (!query.trim()) {
        div.style.display = "none";
        return;
    }
    query = query.toLowerCase();
    const matchingIds = Object.keys(trackMetadata).filter(id => {
        const m = trackMetadata[id];
        const allText = `${m.title || ""} ${m.artist || ""} ${m.album || ""} ${m.genre || ""} ${m.year || ""} ${m.composer || ""} ${m.track || ""}`.toLowerCase();
        return allText.includes(query);
    });
    if (matchingIds.length === 0) {
        div.innerHTML = `<div style="padding:32px;text-align:center;opacity:0.6;">No results found in cache</div>`;
        div.style.display = "block";
        return;
    }
    const albumSet = new Set();
    matchingIds.forEach(id => {
        const alb = trackMetadata[id].album || "Unknown Album";
        albumSet.add(alb);
    });
    currentAlbumMap = {};
    Object.keys(trackMetadata).forEach(id => {
        const m = trackMetadata[id];
        const alb = m.album || "Unknown Album";
        if (albumSet.has(alb)) {
            if (!currentAlbumMap[alb]) {
                currentAlbumMap[alb] = {tracks: [], artists: new Set(), artId: null};
            }
            currentAlbumMap[alb].tracks.push({id, meta: m});
            currentAlbumMap[alb].artists.add(m.artist || "Unknown");
            if (!currentAlbumMap[alb].artId) {
                if (tempArtCache[id]) {
                    currentAlbumMap[alb].artId = id;
                } else if (alb !== "Unknown Album" && albumArtCache[alb]) {
                    currentAlbumMap[alb].artId = id;
                }
            }
        }
    });
    Object.values(currentAlbumMap).forEach(group => {
        group.tracks.sort((a, b) => {
            const ta = parseInt(a.meta.track?.split('/')[0] || "0") || Infinity;
            const tb = parseInt(b.meta.track?.split('/')[0] || "0") || Infinity;
            if (ta !== tb) return ta - tb;
            return a.meta.title.localeCompare(b.meta.title);
        });
    });
    const sortedAlbums = Object.keys(currentAlbumMap).sort((a, b) => a.localeCompare(b));
    div.innerHTML = sortedAlbums.map(alb => {
        const group = currentAlbumMap[alb];
        let art = null;
        let hasArtId = false;
        if (group.artId && tempArtCache[group.artId]) {
            art = tempArtCache[group.artId];
            hasArtId = true;
        } else if (alb !== "Unknown Album" && albumArtCache[alb]) {
            art = albumArtCache[alb];
            hasArtId = true;
        }
        
        // Try to load from IndexedDB if not in memory, and trigger metadata load
        if (!hasArtId && alb !== "Unknown Album") {
            loadAlbumArtFromDB(alb).then(dbArt => {
                if (dbArt) {
                    albumArtCache[alb] = dbArt;
                    // Update the art element
                    const artEl = div.querySelector(`[data-album-art="${alb.replace(/"/g, '\\"')}"]`);
                    if (artEl) {
                        artEl.innerHTML = `<img src="${dbArt}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                    }
                }
            });
            // Also trigger metadata load for first track
            if (group.tracks.length > 0) {
                loadMetaAndArt(group.tracks[0].id, '');
            }
        }
        
        const artistsStr = Array.from(group.artists).join(', ') || "Unknown Artist";
        const albEsc = alb.replace(/'/g, "\\'");
        return `
            <div class="search-result-item" onclick="openAlbumChecklist('${albEsc}')">
                <div data-album-art="${alb}" style="width:56px;height:56px;border-radius:16px;overflow:hidden;background:var(--md-sys-color-surface-variant);display:flex;align-items:center;justify-content:center;box-shadow:0 2px 8px rgba(0,0,0,0.2);">
                    ${art ? `<img src="${art}" class="loaded" style="width:100%;height:100%;object-fit:cover;">` : '<i class="fa-solid fa-compact-disc" style="opacity:0.3;font-size:24px;"></i>'}
                </div>
                <div class="search-result-content truncate">
                    <div style="font-size:15px;font-weight:600;">${alb === "Unknown Album" ? "Unknown Albums" : alb}</div>
                    <div style="font-size:13px;opacity:0.7;margin-top:2px;">${artistsStr}  ${group.tracks.length} songs</div>
                </div>
                <button class="search-result-add-btn" onclick="addEntireAlbum('${albEsc}'); event.stopPropagation();" title="Add entire album">
                    <i class="fa-solid fa-plus" style="font-size:18px;"></i>
                </button>
            </div>
        `;
    }).join('');
    div.style.display = "block";
}

function openAlbumChecklist(album) {
    if (!currentAlbumMap[album]) return;
    document.getElementById("albumModalTitle").innerText = album;
    const list = document.getElementById("albumSongList");
    list.innerHTML = "";
    const tracks = currentAlbumMap[album].tracks;
    
    // Try to load album art from IndexedDB if not in memory
    let albumArt = albumArtCache[album];
    if (!albumArt && album !== "Unknown") {
        loadAlbumArtFromDB(album).then(art => {
            if (art) {
                albumArtCache[album] = art;
                // Update all track art in the modal
                list.querySelectorAll('.album-modal-item-art').forEach(el => {
                    el.innerHTML = `<img src="${art}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                });
            }
        });
    }
    
    tracks.forEach(tr => {
        const m = tr.meta;
        const alb = m.album;
        let artHTML = '<div class="no-art"><i class="fa-solid fa-music"></i></div>';
        if (tempArtCache[tr.id]) {
            artHTML = `<img src="${tempArtCache[tr.id]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        } else if (alb && alb !== "Unknown" && albumArtCache[album]) {
            artHTML = `<img src="${albumArtCache[album]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        } else if (!tempArtCache[tr.id]) {
            // Trigger metadata load
            loadMetaAndArt(tr.id, '');
        }
        
        const item = document.createElement("div");
        item.className = "album-modal-item selected";
        item.innerHTML = `
            <input type="checkbox" checked data-id="${tr.id}" style="display:none;">
            <div class="album-modal-checkbox">
                <i class="fa-solid fa-check"></i>
            </div>
            <div class="album-modal-item-art">${artHTML}</div>
            <div class="album-modal-item-info">
                <div class="album-modal-item-title">${tr.meta.title || "Unknown Title"}</div>
                <div class="album-modal-item-artist">${tr.meta.artist || "Unknown Artist"}</div>
            </div>
        `;
        
        // Add toggle functionality
        item.addEventListener('click', () => {
            const checkbox = item.querySelector('input[type="checkbox"]');
            checkbox.checked = !checkbox.checked;
            item.classList.toggle('selected', checkbox.checked);
        });
        
        list.appendChild(item);
        if (!tempArtCache[tr.id] && !(alb && albumArtCache[alb])) {
            loadMetaAndArt(tr.id, '');
        }
    });
        // Show modal with animation
    const overlay = document.getElementById("albumModalOverlay");
    overlay.style.display = "flex";
    // Small delay to allow display:flex to apply before adding visible class for transition
    setTimeout(() => overlay.classList.add('visible'), 10);
}

function selectAllAlbumSongs() {
    document.querySelectorAll("#albumSongList input[type=checkbox]").forEach(cb => cb.checked = true);
}

function deselectAllAlbumSongs() {
    document.querySelectorAll("#albumSongList input[type=checkbox]").forEach(cb => cb.checked = false);
}

function addSelectedAlbumSongs() {
    const checked = document.querySelectorAll("#albumSongList input[type=checkbox]:checked");
    checked.forEach(cb => {
        const id = cb.dataset.id;
        if (!playlists[currentPlaylistName].some(t => t.id === id)) {
            playlists[currentPlaylistName].push({id});
        }
    });
    localStorage.setItem('goot_playlists', JSON.stringify(playlists));
    renderTrackTable(playlists[currentPlaylistName], document.getElementById("playlistSongBody"), true, currentPlaylistName);
    renderPlaylists();
    if (currentQueueSource === `playlist:${currentPlaylistName}`) {
        queue = playlists[currentPlaylistName].map(e => ({id: e.id}));
        // Defer renderQueue for smoother UI
        setTimeout(() => renderQueue(), 0);
    }
    initPlaylistSortable();
    closeAlbumModal();
}

function addEntireAlbum(album) {
    if (!currentAlbumMap[album]) return;
    const tracks = currentAlbumMap[album].tracks;
    tracks.forEach(tr => {
        if (!playlists[currentPlaylistName].some(t => t.id === tr.id)) {
            playlists[currentPlaylistName].push({id: tr.id});
        }
    });
    localStorage.setItem('goot_playlists', JSON.stringify(playlists));
    renderTrackTable(playlists[currentPlaylistName], document.getElementById("playlistSongBody"), true, currentPlaylistName);
    renderPlaylists();
    if (currentQueueSource === `playlist:${currentPlaylistName}`) {
        queue = playlists[currentPlaylistName].map(e => ({id: e.id}));
        // Defer renderQueue for smoother UI
        setTimeout(() => renderQueue(), 0);
    }
    initPlaylistSortable();
}

function closeAlbumModal() {
    const overlay = document.getElementById("albumModalOverlay");
    overlay.classList.remove('visible');
    // Wait for animation to complete before hiding
    setTimeout(() => {
        overlay.style.display = "none";
    }, 300);
}

// ========== Folder Add to Playlist Modal ==========
let currentFolderTracks = [];
let selectedFolderTracks = new Set();

function openFolderAddModal() {
    const currentFolderId = stack[stack.length - 1].id;
    const currentFolderName = stack[stack.length - 1].name;

    document.getElementById('folderAddModalSubtitle').textContent = currentFolderName;

    // Get all audio files from current folder (not recursive for this modal)
    getFolderContents(currentFolderId).then(files => {
        const tracks = files.filter(f => f.mimeType.includes('audio'));
        tracks.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));

        currentFolderTracks = tracks;
        selectedFolderTracks.clear();

        const list = document.getElementById('folderSongList');
        list.innerHTML = '';

        if (tracks.length === 0) {
            list.innerHTML = '<div style="padding:32px;text-align:center;opacity:0.6;">No audio files in this folder</div>';
        } else {
            tracks.forEach((t, index) => {
                const m = trackMetadata[t.id] || {title: t.name || "...", artist: "...", album: "..."};
                const div = document.createElement('div');
                div.className = 'album-modal-item';
                
                // Get album for this track
                const album = trackMetadata[t.id]?.album;
                let artHTML = '';
                
                if (album && albumArtCache[album]) {
                    artHTML = `<img src="${albumArtCache[album]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                } else if (tempArtCache[t.id]) {
                    artHTML = `<img src="${tempArtCache[t.id]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                } else {
                    artHTML = `<div class="no-art"><i class="fa-solid fa-music"></i></div>`;
                }
                
                div.innerHTML = `
                    <div class="album-modal-item-art">${artHTML}</div>
                    <div class="album-modal-item-info">
                        <div class="album-modal-item-title">${m.title}</div>
                        <div class="album-modal-item-artist">${m.artist}</div>
                    </div>
                    <div class="album-modal-checkbox" onclick="toggleFolderSong(this, '${t.id}')">
                        <i class="fa-solid fa-check"></i>
                    </div>
                `;
                // Store track id on the element for easy access
                div.dataset.trackId = t.id;
                list.appendChild(div);
            });

            // Load missing metadata
            tracks.forEach(t => {
                if (!trackMetadata[t.id]) {
                    loadMetaAndArt(t.id, t.name || '');
                }
            });
        }

        const overlay = document.getElementById("folderAddModalOverlay");
        overlay.style.display = 'flex';
        setTimeout(() => overlay.classList.add('visible'), 10);
    });
}

function toggleFolderSong(checkbox, trackId) {
    const item = checkbox.closest('.album-modal-item');
    if (selectedFolderTracks.has(trackId)) {
        selectedFolderTracks.delete(trackId);
        item.classList.remove('selected');
    } else {
        selectedFolderTracks.add(trackId);
        item.classList.add('selected');
    }
}

function selectAllFolderSongs() {
    document.querySelectorAll("#folderSongList .album-modal-item").forEach(item => {
        const trackId = item.dataset.trackId;
        selectedFolderTracks.add(trackId);
        item.classList.add('selected');
    });
}

function deselectAllFolderSongs() {
    document.querySelectorAll("#folderSongList .album-modal-item").forEach(item => {
        const trackId = item.dataset.trackId;
        selectedFolderTracks.delete(trackId);
        item.classList.remove('selected');
    });
}

function closeFolderAddModal() {
    const overlay = document.getElementById("folderAddModalOverlay");
    overlay.classList.remove("visible");
    setTimeout(() => {
        overlay.style.display = "none";
    }, 300);
    currentFolderTracks = [];
    selectedFolderTracks.clear();
}

// Update album art in folder add modal when metadata loads
function updateFolderModalArt(trackId) {
    const modalOverlay = document.getElementById("folderAddModalOverlay");
    if (modalOverlay.style.display !== "flex") return;

    const item = document.querySelector(`#folderSongList .album-modal-item[data-track-id="${trackId}"]`);
    if (!item) return;

    const artContainer = item.querySelector(".album-modal-item-art");
    if (!artContainer) return;

    const album = trackMetadata[trackId]?.album;
    let newArtHTML = "";

    if (album && albumArtCache[album]) {
        newArtHTML = `<img src="${albumArtCache[album]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
    } else if (tempArtCache[trackId]) {
        newArtHTML = `<img src="${tempArtCache[trackId]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
    }

    if (newArtHTML && !artContainer.querySelector("img.loaded")) {
        artContainer.innerHTML = newArtHTML;
    }
}

function openPlaylistSelectionForFolder() {
    if (selectedFolderTracks.size === 0) {
        showNotification('No tracks selected');
        return;
    }

    // Show playlist selection modal
    const list = document.getElementById('playlistSelectList');
    const playlistNames = Object.keys(playlists);

    if (playlistNames.length === 0) {
        list.innerHTML = '<div style="text-align:center;padding:40px 20px;opacity:0.6;">No playlists yet</div>';
    } else {
        list.innerHTML = playlistNames.map(n => {
            const trackCount = Array.isArray(playlists[n]) ? playlists[n].length : 0;
            return `
                <div class="playlist-modal-item" onclick="addSelectedFolderTracksToPlaylist('${n}')">
                    <div class="playlist-modal-item-icon">
                        <i class="fa-solid fa-music"></i>
                    </div>
                    <div class="playlist-modal-item-info">
                        <div class="playlist-modal-item-name">${n}</div>
                        <div class="playlist-modal-item-count">${trackCount} track${trackCount !== 1 ? 's' : ''}</div>
                    </div>
                    <div class="playlist-modal-item-arrow">
                        <i class="fa-solid fa-chevron-right"></i>
                    </div>
                </div>
            `;
        }).join('');
    }

    const overlay = document.getElementById("playlistSelectModalOverlay");
    overlay.style.display = 'flex';
    setTimeout(() => overlay.classList.add('visible'), 10);
}

function closePlaylistSelectModal() {
    const overlay = document.getElementById("playlistSelectModalOverlay");
    overlay.classList.remove('visible');
    setTimeout(() => {
        overlay.style.display = "none";
    }, 300);
}

function addSelectedFolderTracksToPlaylist(playlistName) {
    if (!Array.isArray(playlists[playlistName])) playlists[playlistName] = [];

    selectedFolderTracks.forEach(trackId => {
        if (!playlists[playlistName].some(t => t.id === trackId)) {
            playlists[playlistName].push({id: trackId});
        }
    });

    localStorage.setItem('goot_playlists', JSON.stringify(playlists));
    renderPlaylists();
    closePlaylistSelectModal();
    closeFolderAddModal();
    showNotification(`Added ${selectedFolderTracks.size} track${selectedFolderTracks.size !== 1 ? 's' : ''} to "${playlistName}"`);
}

function createNewPlaylistForFolder() {
    const name = prompt("Enter playlist name:");
    if (name) {
        playlists[name] = [];
        localStorage.setItem('goot_playlists', JSON.stringify(playlists));
        renderPlaylists();
        addSelectedFolderTracksToPlaylist(name);
    }
}

document.addEventListener('click', function(e) {
    const searchContainer = document.querySelector('.search-container');
    if (!searchContainer || searchContainer.contains(e.target)) return;
    document.getElementById("searchResults").style.display = "none";
});

function addToQueue(trackId) {
    // Add track to end of queue
    queue.push({id: trackId});
    // Re-render queue to show the new item
    renderQueue();
    
    // Visual feedback - briefly flash the queue button
    const trackRow = document.getElementById(`row-${trackId}`);
    if (trackRow) {
        trackRow.style.background = 'var(--md-sys-color-primary-container)';
        setTimeout(() => {
            trackRow.style.background = '';
        }, 300);
    }
}

function removeFromQueue(trackId) {
    const idx = queue.findIndex(t => t.id === trackId);
    if (idx === -1) return;
    
    // If removing the currently playing track, skip to next track
    if (idx === qIndex && player) {
        queue.splice(idx, 1);
        if (queue.length > 0) {
            // Calculate new index (next track or 0 if at end)
            const newIdx = idx < queue.length ? idx : 0;
            play(newIdx);
        } else {
            player.pause();
            document.body.classList.remove('playing');
        }
    } else {
        // Just remove from queue
        queue.splice(idx, 1);
        // Adjust qIndex if needed
        if (idx < qIndex) {
            qIndex--;
        }
        renderQueue();
    }
}

function removeFromPlaylist(e, playlistName, trackId) {
    e.stopPropagation();
    const currentId = queue[qIndex]?.id;
    playlists[playlistName] = playlists[playlistName].filter(t => t.id !== trackId);
    localStorage.setItem('goot_playlists', JSON.stringify(playlists));
    renderTrackTable(playlists[playlistName], document.getElementById("playlistSongBody"), true, playlistName);
    renderPlaylists();
    const coverEl = document.getElementById("playlistCover");
    coverEl.innerHTML = '<div class="no-art"><i class="fa-solid fa-compact-disc"></i></div>';
    if (playlists[playlistName].length > 0) {
        const firstId = playlists[playlistName][0].id;
        const firstMeta = trackMetadata[firstId];
        const album = firstMeta?.album;

        if (tempArtCache[firstId]) {
            coverEl.innerHTML = `
                <img src="${tempArtCache[firstId]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">
                </div>
            `;
        } else if (album && album !== "Unknown" && albumArtCache[album]) {
            coverEl.innerHTML = `
                <img src="${albumArtCache[album]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">
                </div>
            `;
        } else if (album && album !== "Unknown") {
            // Try loading from IndexedDB
            loadAlbumArtFromDB(album).then(art => {
                if (art) {
                    albumArtCache[album] = art;
                    coverEl.innerHTML = `
                        <img src="${art}" class="loaded" style="width:100%;height:100%;object-fit:cover;">
                        </div>
                    `;
                } else {
                    coverEl.innerHTML = `
                        <div class="no-art"><i class="fa-solid fa-compact-disc"></i></div>
                        </div>
                    `;
                    loadMetaAndArt(firstId, '');
                }
            });
        } else {
            coverEl.innerHTML = `
                <div class="no-art"><i class="fa-solid fa-compact-disc"></i></div>
                </div>
            `;
            loadMetaAndArt(firstId, '');
        }
    }
    if (currentQueueSource === `playlist:${playlistName}`) {
        queue = playlists[playlistName].map(e => ({id: e.id}));
        const newIdx = currentId ? queue.findIndex(t => t.id === currentId) : -1;
        if (newIdx !== -1) {
            qIndex = newIdx;
        } else {
            qIndex = Math.max(0, qIndex - 1);
            if (queue.length > 0) play(qIndex);
        }
        // Defer renderQueue for smoother UI
        setTimeout(() => renderQueue(), 0);
    }
    initPlaylistSortable();
}

function renameCurrentPlaylist() {
    let newName = prompt("Enter new playlist name:", currentPlaylistName);
    if (!newName || newName.trim() === "" || newName === currentPlaylistName) return;
    newName = newName.trim();
    if (playlists[newName]) {
        alert("A playlist with that name already exists.");
        return;
    }
    const oldName = currentPlaylistName;
    playlists[newName] = playlists[oldName];
    delete playlists[oldName];
    if (currentQueueSource === `playlist:${oldName}`) {
        currentQueueSource = `playlist:${newName}`;
    }
    currentPlaylistName = newName;
    localStorage.setItem('goot_playlists', JSON.stringify(playlists));
    document.getElementById("currentPlaylistTitle").innerText = newName;
    renderPlaylists();
}

function deleteCurrentPlaylist() {
    if (confirm(`Delete playlist "${currentPlaylistName}" permanently? This cannot be undone.`)) {
        if (currentQueueSource === `playlist:${currentPlaylistName}`) {
            currentQueueSource = null;
            queue = [];
            qIndex = -1;
            // Defer renderQueue for smoother UI
            setTimeout(() => renderQueue(), 0);
            player.pause();
            player.src = "";
        }
        delete playlists[currentPlaylistName];
        localStorage.setItem('goot_playlists', JSON.stringify(playlists));
        backToPlaylistGrid();
        renderPlaylists();
    }
}

function importPlaylists(input) {
    const file = input.files[0];
    if (!file) return;
    const r = new FileReader();
    r.onload = e => {
        try {
            const imported = JSON.parse(e.target.result);
            let changed = false;
            for (const name in imported) {
                const data = imported[name];
                if (!playlists[name]) {
                    playlists[name] = data;
                    changed = true;
                } else {
                    const existing = playlists[name];
                    if (!Array.isArray(existing)) existing = [];
                    const existingIds = new Set(existing.map(t => t.id));
                    const importedTracks = Array.isArray(data) ? data : [];
                    for (const track of importedTracks) {
                        if (track.id && !existingIds.has(track.id)) {
                            existing.push(track);
                            changed = true;
                        }
                    }
                    if (data.customCover) {
                        existing.customCover = data.customCover;
                        changed = true;
                    }
                }
            }
            if (changed) {
                localStorage.setItem('goot_playlists', JSON.stringify(playlists));
                renderPlaylists();
                
                // If the currently open playlist was imported/merged, update its view
                if (currentPlaylistName && playlists[currentPlaylistName]) {
                    renderTrackTable(playlists[currentPlaylistName], document.getElementById("playlistSongBody"), true, currentPlaylistName);
                }
                alert("Playlists imported and merged successfully.");
            } else {
                alert("No new playlists or tracks found to import.");
            }
        } catch (err) {
            alert("Invalid playlist file.");
        }
        input.value = "";
    };
    r.readAsText(file);
}

async function loadAllTrackInfo() {
    const btn = document.getElementById("loadAllBtn");
    const cancelBtn = document.getElementById("cancelBtn");
    const progressContainer = document.getElementById("progressContainer");
    const progressBar = document.getElementById("progressBar");
    const progressText = document.getElementById("progressText");
    const loadControls = document.getElementById("loadControls");
    if (isLoadingAll) return;
    isLoadingAll = true;
    shouldCancelLoad = false;
    loadLog = [];
    processedFiles = 0;
    totalFilesToLoad = 0;
    btn.disabled = true;
    btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Loading...';
    progressContainer.style.display = "block";
    loadControls.style.display = "flex";
    progressBar.style.width = "0%";
    progressText.textContent = "Scanning files...";
    const currentFolderId = stack[stack.length-1].id;
    await countFilesRecursive(currentFolderId);
    if (totalFilesToLoad === 0) {
        progressText.textContent = "No audio files found.";
        resetLoadUI();
        return;
    }
    progressText.textContent = `0 / ${totalFilesToLoad} (0%)`;
    updateLogDisplay();
    await processFilesRecursive(currentFolderId);
    if (shouldCancelLoad) {
        progressText.textContent = "Loading cancelled.";
        addToLog("Loading cancelled by user.");
    } else {
        progressText.textContent = `Done! ${processedFiles} / ${totalFilesToLoad} processed.`;
        addToLog("Loading completed.");
    }
    setTimeout(resetLoadUI, 3000);
}

async function countFilesRecursive(folderId) {
    if (shouldCancelLoad) return;
    try {
        const files = await getFolderContents(folderId);
        totalFilesToLoad += files.filter(f => f.mimeType.includes('audio')).length;
        const folders = files.filter(f => f.mimeType === 'application/vnd.google-apps.folder');
        for (const f of folders) {
            await countFilesRecursive(f.id);
        }
    } catch(e) {
        console.error('Error counting files:', e);
        addToLog(`Error counting in folder ${folderId}`);
    }
}

async function processFilesRecursive(folderId) {
    if (shouldCancelLoad) return;
    try {
        const files = await getFolderContents(folderId);
        const tracks = files.filter(f => f.mimeType.includes('audio'));
        for (const t of tracks) {
            if (shouldCancelLoad) break;
            addToLog(`Processing: ${t.name} (ID: ${t.id})`);
            await loadMetaAndArt(t.id, t.name);
            processedFiles++;
            const percent = Math.round((processedFiles / totalFilesToLoad) * 100);
            document.getElementById("progressBar").style.width = percent + "%";
            document.getElementById("progressText").textContent = `${processedFiles} / ${totalFilesToLoad} (${percent}%)`;
            updateLogDisplay();
        }
        const folders = files.filter(f => f.mimeType === 'application/vnd.google-apps.folder');
        for (const f of folders) {
            if (shouldCancelLoad) break;
            await processFilesRecursive(f.id);
        }
    } catch(e) {
        console.error('Error processing files:', e);
        addToLog(`Error processing folder ${folderId}`);
    }
}

function addToLog(message) {
    const timestamp = new Date().toLocaleTimeString([], {hour12: false});
    loadLog.push(`[${timestamp}] ${message}`);
    if (logModalOpen) updateLogDisplay();
}

function updateLogDisplay() {
    const content = document.getElementById("logContent");
    const status = document.getElementById("logStatus");
    content.textContent = loadLog.join("\n");
    status.textContent = isLoadingAll ? "(Loading in progress)" : "(Completed)";
    if (document.getElementById("autoScroll").checked) {
        content.scrollTop = content.scrollHeight;
    }
}

function cancelLoad() {
    shouldCancelLoad = true;
    document.getElementById("progressText").textContent = "Cancelling...";
    addToLog("Cancel requested...");
}

function resetLoadUI() {
    const btn = document.getElementById("loadAllBtn");
    const progressContainer = document.getElementById("progressContainer");
    const loadControls = document.getElementById("loadControls");
    if(btn) {
        btn.disabled = false;
        btn.innerHTML = '<i class="fa-solid fa-download"></i> Load All Track Info';
    }
    progressContainer.style.display = "none";
    loadControls.style.display = "none";
    isLoadingAll = false;
}

function showLog() {
    logModalOpen = true;
    updateLogDisplay();
    document.getElementById("logOverlay").style.display = "flex";
}

function closeLog() {
    logModalOpen = false;
    document.getElementById("logOverlay").style.display = "none";
}

function clearAllCache() {
    if (confirm("This will delete ALL cached metadata, album art, and reset related settings.\nAre you sure?")) {
        localStorage.removeItem('goot_meta_cache');
        trackMetadata = {};
        tempArtCache = {};
        albumArtCache = {};
        alert("Cache cleared! Refresh the page to see full effect.");
    }
}

function isColorTooLight(r, g, b) {
    // Check if a color is too light (close to white)
    // Using relative luminance formula
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    // If luminance is above 0.85, the color is too light/close to white
    return luminance > 0.85;
}

function ensureReadableColor(hex) {
    // Ensure the accent color is readable - not too dark
    const rgb = hexToRgb(hex);
    if (!rgb) return hex;
    
    const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
    
    // If color is too dark (luminance < 0.2), lighten it
    if (luminance < 0.2) {
        // Lighten the color by mixing with white
        const factor = 0.3; // How much to mix with white
        const r = Math.round(rgb.r + (255 - rgb.r) * factor);
        const g = Math.round(rgb.g + (255 - rgb.g) * factor);
        const b = Math.round(rgb.b + (255 - rgb.b) * factor);
        return rgbToHex([r, g, b]);
    }
    
    return hex;
}

function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

function updateTheme(hex) {
    // Check if the color is too light (white or near-white)
    const rgb = hexToRgb(hex);
    if (rgb && isColorTooLight(rgb.r, rgb.g, rgb.b)) {
        // Skip updating if color is too light - keep the current theme
        // Optionally update the picker to show the current valid color
        const picker = document.getElementById('accentPicker');
        if (picker) {
            const currentColor = localStorage.getItem('goot_accent') || '#ff0000';
            picker.value = currentColor;
        }
        return;
    }
    
    // Ensure color is readable (not too dark)
    hex = ensureReadableColor(hex);
    
    document.documentElement.style.setProperty('--md-sys-color-primary', hex);
    document.documentElement.style.setProperty('--md-sys-color-primary-container', hex+'26');
    // Calculate darker version for expanded view gradient
    document.documentElement.style.setProperty('--md-sys-color-primary-dark', adjustColor(hex, -100));
    localStorage.setItem('goot_accent', hex);
    
    // Update color picker if it exists
    const picker = document.getElementById('accentPicker');
    if (picker) picker.value = hex;
    
    // Update custom color preview
    updateCustomColorPreview(hex);
}

function updateCustomColorPreview(hex) {
    const customPreset = document.getElementById('customColorPreset');
    if (customPreset) {
        customPreset.style.background = hex;
        customPreset.style.animation = 'none';
    }
}

function toggleAlbumColorMode() {
    const enabled = document.getElementById('albumColorToggle').checked;
    localStorage.setItem('goot_album_color', enabled);
    
    // If disabled, restore the custom accent color
    if (!enabled) {
        const customColor = localStorage.getItem('goot_accent') || '#ff0000';
        updateTheme(customColor);
    } else if (queue[qIndex]?.id) {
        // If enabled and a track is playing, extract color from its art
        extractColorFromAlbumArt(queue[qIndex].id);
    }
}

function extractColorFromAlbumArt(id) {
    // Check if album color mode is enabled
    if (localStorage.getItem('goot_album_color') !== 'true') return;
    
    // Get album name for caching
    const album = trackMetadata[id]?.album;
    if (!album || album === "Unknown") {
        // Fallback if no album metadata
        const customColor = localStorage.getItem('goot_accent') || '#ff0000';
        if (queue[qIndex]?.id === id) {
            updateTheme(customColor);
        }
        return;
    }
    
    // Check localStorage cache first
    const albumAccentCache = JSON.parse(localStorage.getItem('goot_album_accent_cache') || '{}');
    if (albumAccentCache[album]) {
        // Use cached color for this album
        if (queue[qIndex]?.id === id) {
            updateTheme(albumAccentCache[album]);
        }
        return;
    }
    
    // Get the art source - prefer individual track art, then album art
    let artSrc = tempArtCache[id];
    if (!artSrc) {
        artSrc = albumArtCache[album];
    }
    
    if (!artSrc) return;
    
    // Create an image to extract color
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    
    img.onload = function() {
        // Find the most vibrant color using the new algorithm
        const vibrantColor = findMostVibrant(img);
        if (vibrantColor && queue[qIndex]?.id === id) {
            const hexColor = rgbToHex(vibrantColor.rgb);
            
            // Check if the color is essentially grayscale (black/white/gray album art)
            const rgb = vibrantColor.rgb;
            const isGrayscale = isColorGrayscale(rgb[0], rgb[1], rgb[2]);
            
            // Use #666666 for grayscale albums, otherwise use the extracted color
            const finalColor = isGrayscale ? '#666666' : hexColor;
            updateTheme(finalColor);
            
            // Cache this color for the album
            const cache = JSON.parse(localStorage.getItem('goot_album_accent_cache') || '{}');
            cache[album] = finalColor;
            localStorage.setItem('goot_album_accent_cache', JSON.stringify(cache));
        }
    };
    
    img.onerror = function() {
        // Fallback to custom color if extraction fails
        const customColor = localStorage.getItem('goot_accent') || '#ff0000';
        if (queue[qIndex]?.id === id) {
            updateTheme(customColor);
        }
    };
    
    img.src = artSrc;
}

function findMostCommonVibrantColor(img) {
    try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        
        // Sample pixels with larger step for performance
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const w = imageData.width;
        const h = imageData.height;
        
        // Quantize colors to group similar ones together
        const colorCounts = {};
        const quantization = 16; // Smaller quantization for more precise color grouping
        
        // Sample every 20th pixel for performance, but focus on center area to avoid borders
        const startX = Math.floor(w * 0.1);
        const endX = Math.floor(w * 0.9);
        const startY = Math.floor(h * 0.1);
        const endY = Math.floor(h * 0.9);
        
        for (let y = startY; y < endY; y += 4) {
            for (let x = startX; x < endX; x += 20) {
                const i = (y * w + x) * 4;
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];
                
                // Skip transparent or very dark pixels
                if (a < 128) continue;
                
                // Calculate brightness - skip very dark and very light pixels
                const brightness = (r + g + b) / 3;
                if (brightness < 50 || brightness > 240) continue;
                
                // Calculate saturation
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const saturation = max === 0 ? 0 : (max - min) / max;
                
                // Only consider very vibrant colors (saturation > 0.5)
                if (saturation < 0.5) continue;
                
                // Quantize the color to group similar ones
                const qr = Math.round(r / quantization) * quantization;
                const qg = Math.round(g / quantization) * quantization;
                const qb = Math.round(b / quantization) * quantization;
                
                const key = `${qr},${qg},${qb}`;
                
                if (!colorCounts[key]) {
                    colorCounts[key] = { count: 0, r: qr, g: qg, b: qb, brightness, saturation };
                }
                colorCounts[key].count++;
            }
        }
        
        // Find the color with highest saturation weighted by frequency
        // Formula: sqrt(count) * saturation^3 - heavily prioritizes vibrancy
        let maxScore = 0;
        let bestColor = null;
        
        Object.values(colorCounts).forEach(color => {
            const score = Math.sqrt(color.count) * Math.pow(color.saturation, 3);
            if (score > maxScore) {
                maxScore = score;
                bestColor = color;
            }
        });
        
        if (!bestColor || maxScore < 0.1) {
            // Fallback: try with more lenient filtering but still prioritize saturation
            for (let i = 0; i < data.length; i += 16) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];
                
                if (a < 128) continue;
                
                const brightness = (r + g + b) / 3;
                if (brightness < 40) continue;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const saturation = max === 0 ? 0 : (max - min) / max;
                
                if (saturation < 0.4) continue;
                
                const qr = Math.round(r / quantization) * quantization;
                const qg = Math.round(g / quantization) * quantization;
                const qb = Math.round(b / quantization) * quantization;
                const key = `${qr},${qg},${qb}`;
                
                if (!colorCounts[key]) {
                    colorCounts[key] = { count: 0, r: qr, g: qg, b: qb, brightness, saturation };
                }
                colorCounts[key].count++;
            }
            
            Object.values(colorCounts).forEach(color => {
                const score = Math.sqrt(color.count) * Math.pow(color.saturation, 3);
                if (score > maxScore) {
                    maxScore = score;
                    bestColor = color;
                }
            });
        }
        
        if (!bestColor) {
            // Final fallback to orange if no vibrant colors found
            return '#ff6600';
        }
        
        // Convert to hex
        const hex = '#' + [bestColor.r, bestColor.g, bestColor.b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
        
        return hex;
    } catch (e) {
        return '#ff6600'; // Default to orange on error
    }
}

function findMostVibrant(img) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    const maxSize = 200;
    let width = img.width;
    let height = img.height;
    
    if (width > height) {
        if (width > maxSize) {
            height = Math.round((height * maxSize) / width);
            width = maxSize;
        }
    } else {
        if (height > maxSize) {
            width = Math.round((width * maxSize) / height);
            height = maxSize;
        }
    }
    
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img, 0, 0, width, height);
    
    const imageData = ctx.getImageData(0, 0, width, height);
    const pixels = imageData.data;
    
    // Collect vibrant colors
    const colorGroups = {};
    const binSize = 15;
    
    for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        const a = pixels[i + 3];
        
        if (a < 128) continue;
        
        const hsl = rgbToHsl(r, g, b);
        
        // Skip very dark or very desaturated colors
        if (hsl.l < 0.15 || hsl.s < 0.15) continue;
        
        // Quantize
        const qr = Math.round(r / binSize) * binSize;
        const qg = Math.round(g / binSize) * binSize;
        const qb = Math.round(b / binSize) * binSize;
        
        const key = `${qr},${qg},${qb}`;
        
        if (!colorGroups[key]) {
            colorGroups[key] = {
                r: 0, g: 0, b: 0,
                h: 0, s: 0, l: 0,
                count: 0, score: 0
            };
        }
        
        colorGroups[key].r += r;
        colorGroups[key].g += g;
        colorGroups[key].b += b;
        colorGroups[key].h += hsl.h;
        colorGroups[key].s += hsl.s;
        colorGroups[key].l += hsl.l;
        colorGroups[key].count++;
    }
    
    // Calculate scores
    let bestColor = null;
    let bestScore = -1;
    
    for (const key in colorGroups) {
        const color = colorGroups[key];
        const avgR = Math.round(color.r / color.count);
        const avgG = Math.round(color.g / color.count);
        const avgB = Math.round(color.b / color.count);
        const avgH = color.h / color.count;
        const avgS = color.s / color.count;
        const avgL = color.l / color.count;
        
        // VIBE SCORE CALCULATION
        let score = 0;
        
        // Saturation weight: 3x (MOST IMPORTANT)
        score += avgS * 300;
        
        // Brightness bonus: sweet spot between 40% and 80%
        if (avgL >= 0.4 && avgL <= 0.8) {
            score += 80;
        } else if (avgL >= 0.3 && avgL <= 0.85) {
            score += 40;
        } else if (avgL < 0.25) {
            score -= 50; // Too dark
        } else if (avgL > 0.9) {
            score -= 30; // Too washed out
        }
        
        // Cool color bonus (blues and purples are preferred)
        const hue = avgH;
        if (hue >= 180 && hue < 280) {
            // Blues, cyans
            score += 50;
        } else if (hue >= 280 && hue < 320) {
            // Purples, magentas (valued higher than blues)
            score += 60;
        } else if (hue >= 320 || hue < 30) {
            // Pinks, reds (same priority as blues)
            score += 50;
        } else if (hue >= 30 && hue < 60) {
            // Oranges (same priority as blues)
            score += 50;
        } else {
            // Yellows, greens (less preferred)
            score += 10;
        }
        
        // Frequency bonus (but not too much)
        score += Math.log(color.count + 1) * 10;
        
        color.score = score;
        
        if (score > bestScore) {
            bestScore = score;
            bestColor = {
                rgb: [avgR, avgG, avgB],
                hsl: { h: avgH, s: avgS, l: avgL },
                score: score
            };
        }
    }
    
    // Fallback if no vibrant colors found
    if (!bestColor) {
        bestColor = findBrightestFallback(img);
    }
    
    return bestColor;
}

function findBrightestFallback(img) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = 100;
    canvas.height = 100;
    ctx.drawImage(img, 0, 0, 100, 100);
    
    const imageData = ctx.getImageData(0, 0, 100, 100);
    const pixels = imageData.data;
    
    let brightest = [255, 255, 255];
    let maxBright = 0;
    
    for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        const a = pixels[i + 3];
        
        if (a < 128) continue;
        
        const brightness = (r + g + b) / 3;
        if (brightness > maxBright) {
            maxBright = brightness;
            brightest = [r, g, b];
        }
    }
    
    return {
        rgb: brightest,
        hsl: rgbToHsl(brightest[0], brightest[1], brightest[2]),
        score: 0
    };
}

function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const delta = max - min;
    
    let h, s;
    const l = (max + min) / 2;
    
    if (delta === 0) {
        h = 0;
        s = 0;
    } else {
        s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
        
        switch (max) {
            case r:
                h = ((g - b) / delta + (g < b ? 6 : 0)) / 6;
                break;
            case g:
                h = ((b - r) / delta + 2) / 6;
                break;
            case b:
                h = ((r - g) / delta + 4) / 6;
                break;
        }
    }
    
    return { h: h * 360, s, l };
}

function isColorGrayscale(r, g, b) {
    // Check if color is essentially grayscale (R  G  B)
    // A color is grayscale if the difference between channels is very small
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const diff = max - min;
    
    // If the difference is less than 10% of the range, consider it grayscale
    // Also check if the saturation is very low
    const brightness = (r + g + b) / 3;
    const saturation = max === 0 ? 0 : diff / max;
    
    // A color is grayscale if saturation is very low (< 10%)
    return saturation < 0.1;
}

function rgbToHex(rgb) {
    return '#' + rgb.map(c => {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }).join('').toUpperCase();
}

// ==================== VOLUME NORMALIZATION ====================

/**
 * Initialize Web Audio API context for normalization
 */
function initNormalizationAudio() {
    // Use existing audio context from equalizer if available
    if (audioContext) return audioContext;
    if (audioCtx) {
        // Use the equalizer's audio context
        audioContext = audioCtx;
        // Create gain node if it doesn't exist
        if (!normGainNode) {
            normGainNode = audioContext.createGain();
            normGainNode.gain.value = 1.0;
            // Connect normGainNode to the chain before destination
            const dest = audioContext.destination;
            // Find where the chain ends and insert normGainNode
            // For simplicity, connect normGainNode in parallel
            normGainNode.connect(dest);
        }
        return audioContext;
    }
    // Create new context
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    normGainNode = audioContext.createGain();
    normGainNode.gain.value = 1.0;
    normGainNode.connect(audioContext.destination);
    return audioContext;
}

/**
 * Toggle volume normalization on/off
 */
function toggleNormalization() {
    const toggle = document.getElementById('normToggle');
    normEnabled = toggle.checked;
    localStorage.setItem('goot_norm_enabled', normEnabled);
    
    // Update status text
    updateNormStatus();
    
    // Apply gain to current track if playing
    if (queue[qIndex]?.id) {
        applyNormalization(queue[qIndex].id);
    }
}

/**
 * Update target loudness value
 */
function updateNormTarget(value) {
    normTargetLUFS = parseInt(value);
    document.getElementById('normTargetValue').textContent = normTargetLUFS + ' LUFS';
    localStorage.setItem('goot_norm_target', normTargetLUFS);
    
    // Apply new target to current track
    if (queue[qIndex]?.id) {
        applyNormalization(queue[qIndex].id);
    }
}

/**
 * Update normalization status display
 */
function updateNormStatus() {
    const statusText = document.getElementById('normStatusText');
    if (!statusText) return;
    
    if (!normEnabled) {
        statusText.textContent = 'Enable to play all tracks at consistent volume';
    } else if (currentNormGain === 1.0) {
        statusText.textContent = 'All tracks will play at similar volume levels';
    } else {
        const gainDb = (20 * Math.log10(currentNormGain)).toFixed(1);
        const sign = gainDb >= 0 ? '+' : '';
        statusText.textContent = `Volume adjusted by ${sign}${gainDb} dB`;
    }
}

/**
 * Get cached loudness for a track
 */
function getTrackLoudness(trackId) {
    // Check memory cache first
    if (trackLoudnessCache[trackId] !== undefined) {
        return trackLoudnessCache[trackId];
    }
    
    // Check localStorage
    const cacheKey = `goot_loudness_${trackId}`;
    const cached = localStorage.getItem(cacheKey);
    if (cached !== null) {
        const loudness = parseFloat(cached);
        trackLoudnessCache[trackId] = loudness;
        return loudness;
    }
    
    return null;
}

/**
 * Cache track loudness
 */
function cacheTrackLoudness(trackId, loudness) {
    trackLoudnessCache[trackId] = loudness;
    const cacheKey = `goot_loudness_${trackId}`;
    localStorage.setItem(cacheKey, loudness.toFixed(2));
}

/**
 * Analyze track loudness using Web Audio API
 * Returns loudness in LUFS (integrated)
 */
async function analyzeTrackLoudness(trackId, audioUrl) {
    return new Promise(async (resolve, reject) => {
        try {
            const ctx = initAudioContext();
            
            // Fetch the audio file
            const response = await fetch(audioUrl);
            const arrayBuffer = await response.arrayBuffer();
            
            // Decode the audio data
            const audioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));
            
            // Calculate loudness using EBU R128 algorithm approximation
            // This uses a gated loudness measurement approach
            const loudness = calculateLoudness(audioBuffer);
            
            resolve(loudness);
        } catch (error) {
            console.error('Error analyzing loudness:', error);
            // Fallback: return target loudness (no adjustment needed)
            resolve(normTargetLUFS);
        }
    });
}

/**
 * Calculate loudness of audio buffer using gated LUFS approximation
 */
function calculateLoudness(audioBuffer) {
    const channelData = audioBuffer.getChannelData(0); // Use first channel
    const sampleRate = audioBuffer.sampleRate;
    
    // Calculate RMS for each 3-second window (block size ~400ms for more precision)
    const blockSize = Math.floor(sampleRate * 0.4); // 400ms blocks
    const hopSize = Math.floor(sampleRate * 3); // 3-second gating blocks
    const gatingThreshold = -70; // LUFS
    
    let energyValues = [];
    
    // Calculate absolute RMS for each sample
    for (let i = 0; i < channelData.length; i += hopSize) {
        let sum = 0;
        let count = 0;
        
        for (let j = i; j < Math.min(i + blockSize, channelData.length); j++) {
            sum += channelData[j] * channelData[j];
            count++;
        }
        
        if (count > 0) {
            const rms = Math.sqrt(sum / count);
            // Convert to LUFS approximation (relative to full scale)
            // For simplicity, we use RMS relative to a reference level
            let db = 20 * Math.log10(rms + 1e-10); // Avoid log(0)
            let lufs = db - 0.691; // Account for relative scale
            energyValues.push(lufs);
        }
    }
    
    if (energyValues.length === 0) {
        return normTargetLUFS; // Fallback
    }
    
    // Filter out samples below gating threshold
    const gatedValues = energyValues.filter(e => e >= gatingThreshold);
    
    if (gatedValues.length === 0) {
        return normTargetLUFS; // Fallback
    }
    
    // Calculate mean energy
    const meanEnergy = gatedValues.reduce((a, b) => a + Math.pow(10, b / 10), 0) / gatedValues.length;
    const integratedLoudness = 10 * Math.log10(meanEnergy);
    
    // Adjust for channel count (simple mono/stereo correction)
    const channelCount = audioBuffer.numberOfChannels;
    const channelCorrection = channelCount > 2 ? 0 : 0; // Simplified
    
    return integratedLoudness + channelCorrection;
}

/**
 * Calculate and apply normalization gain for a track
 */
async function applyNormalization(trackId) {
    if (!normEnabled || !normGainNode) {
        currentNormGain = 1.0;
        if (normGainNode) {
            normGainNode.gain.setValueAtTime(1.0, audioContext.currentTime);
        }
        updateNormStatus();
        updateNormIndicator(null);
        return;
    }
    
    // Get cached loudness or analyze
    let trackLoudness = getTrackLoudness(trackId);
    
    if (trackLoudness === null) {
        // Need to analyze this track
        // For now, use a reasonable default based on typical values
        // Real analysis would require the audio URL
        const track = queue.find(t => t.id === trackId);
        if (track && track.googleUrl) {
            // We could analyze here, but for performance, let's estimate
            // Typical pop/rock tracks are around -10 to -14 LUFS
            // We use target as default until analyzed
            trackLoudness = normTargetLUFS;
        } else {
            trackLoudness = normTargetLUFS;
        }
    }
    
    // Calculate gain needed to reach target
    // LUFS difference directly translates to dB gain needed
    const loudnessDiff = normTargetLUFS - trackLoudness;
    const gain = Math.pow(10, loudnessDiff / 20); // Convert dB to linear
    
    // Clamp gain to reasonable range (0.5x to 2x = -6dB to +6dB)
    const clampedGain = Math.max(0.5, Math.min(2.0, gain));
    
    currentNormGain = clampedGain;
    
    // Apply gain smoothly
    if (normGainNode && audioContext) {
        normGainNode.gain.setTargetAtTime(clampedGain, audioContext.currentTime, 0.1);
    }
    
    updateNormStatus();
    updateNormIndicator(loudnessDiff);
}

/**
 * Update the normalization indicator on the player
 */
function updateNormIndicator(loudnessDiff) {
    let indicator = document.getElementById('normIndicator');
    
    if (!indicator) {
        // Create indicator if it doesn't exist
        const playerBar = document.querySelector('.player-bar');
        if (playerBar) {
            indicator = document.createElement('div');
            indicator.id = 'normIndicator';
            indicator.className = 'norm-indicator';
            indicator.innerHTML = '<i class="fa-solid fa-wave-square"></i><span id="normIndicatorText"></span>';
            playerBar.appendChild(indicator);
        }
    }
    
    if (!indicator) return;
    
    if (!normEnabled) {
        indicator.classList.remove('visible');
        return;
    }
    
    const indicatorText = document.getElementById('normIndicatorText');
    if (loudnessDiff !== null) {
        const absDiff = Math.abs(loudnessDiff).toFixed(1);
        const sign = loudnessDiff >= 0 ? '+' : '-';
        indicatorText.textContent = `${sign}${absDiff} dB`;
    } else {
        indicatorText.textContent = 'Norm';
    }
    
    indicator.classList.add('visible');
}

/**
 * Load normalization settings from localStorage
 */
function loadNormSettings() {
    // Load enabled state
    const savedEnabled = localStorage.getItem('goot_norm_enabled');
    if (savedEnabled !== null) {
        normEnabled = savedEnabled === 'true';
        document.getElementById('normToggle').checked = normEnabled;
    }
    
    // Load target loudness
    const savedTarget = localStorage.getItem('goot_norm_target');
    if (savedTarget !== null) {
        normTargetLUFS = parseInt(savedTarget);
        document.getElementById('normTargetSlider').value = normTargetLUFS;
        const normTargetValue = document.getElementById('normTargetValue');
        if (normTargetValue) normTargetValue.textContent = normTargetLUFS;
    }
    
    updateNormStatus();
    updateCacheStats();
}

/**
 * Update cache statistics display
 */
function updateCacheStats() {
    const metaCount = document.getElementById('cacheMetaCount');
    const artCount = document.getElementById('cacheArtCount');
    
    if (metaCount) {
        const metaCache = JSON.parse(localStorage.getItem('goot_meta_cache') || '{}');
        metaCount.textContent = Object.keys(metaCache).length;
    }
    
    if (artCount) {
        const artCache = JSON.parse(localStorage.getItem('goot_album_art_cache') || '{}');
        artCount.textContent = Object.keys(artCache).length;
    }
}

/**
 * Update the player audio source to include normalization gain node
 */
function setupNormalizedAudio() {
    if (!normEnabled || !audioContext) return;
    
    // The gain node should be connected between source and destination
    // This is handled by the createMediaElementSource setup
}

	function adjustColor(hex, amount) {
	    const num = parseInt(hex.slice(1), 16);
	    const r = Math.min(255, Math.max(0, (num >> 16) + amount));
	    const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
	    const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
	    return '#' + (b | (g << 8) | (r << 16)).toString(16).padStart(6, '0').toUpperCase();
	}

function goHome(el) { stack=[{id:ROOT_ID,name:"Home"}]; loadFolders(ROOT_ID); nav(el); }

function nav(el) {
    const screen = el.dataset.screen;
    document.querySelectorAll('.nav-item').forEach(x => {
        x.classList.toggle('active', x.dataset.screen === screen);
    });
    document.querySelectorAll('.mobile-nav-item').forEach(x => {
        if(x.dataset.screen) x.classList.toggle('active', x.dataset.screen === screen);
    });
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const target = document.getElementById(screen + '-screen');
    if(target) target.classList.add('active');
}

function toggleSidebar() { document.getElementById("sidebar").classList.toggle("collapsed"); }

function openMobilePlayer() {
    if (window.innerWidth <= 768) {
        document.getElementById("mobilePlayer").classList.add("active");
    }
}

function closeMobilePlayer() {
    document.getElementById("mobilePlayer").classList.remove("active");
}

function shuffleQueue() {
    for(let i=queue.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [queue[i], queue[j]] = [queue[j], queue[i]];
    }
}

function toggleShuffle() {
    shuffleMode = !shuffleMode;
    const mini = document.getElementById("btnShuffle");
    const fs = document.getElementById("fsBtnShuffle");
    const cleanBtn = document.getElementById("deShuffleBtn");
    
    mini.style.opacity = shuffleMode ? "1" : "0.5";
    mini.style.color = shuffleMode ? "var(--md-sys-color-primary)" : "inherit";
    
    fs.style.opacity = shuffleMode ? "1" : "0.5";
    fs.style.color = shuffleMode ? "var(--md-sys-color-primary)" : "inherit";
    
    if(cleanBtn) cleanBtn.classList.toggle('active', shuffleMode);
    
    if (shuffleMode) {
        if (queue.length < 2) return;
        const currentId = queue[qIndex]?.id;
        if (!currentId) return;
        originalQueue = [...queue];
        shuffleQueue();
        const pos = queue.findIndex(t => t.id === currentId);
        if (pos !== 0) {
            [queue[0], queue[pos]] = [queue[pos], queue[0]];
        }
        qIndex = 0;
        currentQueueSource = null;
    } else {
        const currentId = queue[qIndex]?.id;
        queue = [...originalQueue];
        qIndex = originalQueue.findIndex(t => t.id === currentId);
        if (qIndex === -1) qIndex = 0;
        currentQueueSource = null;
    }
    // Defer renderQueue for smoother UI
    setTimeout(() => renderQueue(), 0);
}

function skip(direction) {
    let next = qIndex + direction;
    if (shuffleMode) {
        if (repeatMode === 1 && next >= queue.length) {
            shuffleQueue();
            next = 0;
        } else if (next >= queue.length || next < 0) return;
    } else {
        if (repeatMode === 1) {
            if (next >= queue.length) next = 0;
            if (next < 0) next = queue.length-1;
        } else if (next >= queue.length || next < 0) return;
    }
    play(next);
}

function togglePlay() { player.paused ? player.play() : player.pause(); }

function scrub(v) { if (player.duration) player.currentTime = (v/100)*player.duration; }

function updateBreadcrumbs() {
    document.getElementById('breadcrumb').innerHTML = stack.map((s,i)=>`
        <div class="breadcrumb-chip" onclick="stack.splice(${i+1});loadFolders(stack[${i}].id)">${s.name}</div>
    `).join('<i class="fa-solid fa-chevron-right" style="opacity:0.2;font-size:10px;"></i>');
}

function openPlaylistModal(e,id) {
    e.stopPropagation();
    const playlistNames = Object.keys(playlists);
    if (playlistNames.length === 0) {
        document.getElementById("modalList").innerHTML = '<div style="text-align:center;padding:40px 20px;opacity:0.6;">No playlists yet</div>';
    } else {
        document.getElementById("modalList").innerHTML = playlistNames.map(n => {
            const trackCount = Array.isArray(playlists[n]) ? playlists[n].length : 0;
            return `
                <div class="playlist-modal-item" onclick="addToPlaylist('${n}','${id}')">
                    <div class="playlist-modal-item-icon">
                        <i class="fa-solid fa-music"></i>
                    </div>
                    <div class="playlist-modal-item-info">
                        <div class="playlist-modal-item-name">${n}</div>
                        <div class="playlist-modal-item-count">${trackCount} track${trackCount !== 1 ? 's' : ''}</div>
                    </div>
                    <div class="playlist-modal-item-arrow">
                        <i class="fa-solid fa-chevron-right"></i>
                    </div>
                </div>
            `;
        }).join('');
    }
    document.getElementById("modalOverlay").style.display = "flex";
}

function addToPlaylist(p,id) {
    if (!Array.isArray(playlists[p])) playlists[p] = [];
    playlists[p].push({id});
    localStorage.setItem('goot_playlists',JSON.stringify(playlists));
    closeModal();
    renderPlaylists();
    
    // If the currently open playlist is the one we just modified, update its view
    if (currentPlaylistName === p) {
        renderTrackTable(playlists[p], document.getElementById("playlistSongBody"), true, p);
    }
}

function closeModal() { document.getElementById("modalOverlay").style.display="none"; }

function createNewPlaylist(fm) {
    const n = prompt("Name:");
    if(n){
        playlists[n]=[];
        localStorage.setItem('goot_playlists',JSON.stringify(playlists));
        renderPlaylists();
    }
    if(fm) closeModal();
}

function exportPlaylists() {
    const blob = new Blob([JSON.stringify(playlists)],{type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "backup.goot2";
    a.click();
}

function toggleRepeat() {
    repeatMode = repeatMode === 0 ? 1 : 0;
    const mini = document.getElementById("btnRepeat");
    const fs = document.getElementById("fsBtnRepeat");
    const cleanBtn = document.getElementById("deRepeatBtn");
    
    mini.style.opacity = repeatMode === 1 ? "1" : "0.5";
    mini.style.color = repeatMode === 1 ? "var(--md-sys-color-primary)" : "inherit";
    
    fs.style.opacity = repeatMode === 1 ? "1" : "0.5";
    fs.style.color = repeatMode === 1 ? "var(--md-sys-color-primary)" : "inherit";
    
    if(cleanBtn) cleanBtn.classList.toggle('active', repeatMode === 1);
}

function setVolume(val) {
    player.volume = val;
    if (player.muted && val > 0) player.muted = false;
    
    // Update main volume slider
    const volSlider = document.getElementById('volSlider');
    if (volSlider) volSlider.value = val;
    
    // Update desktop extended volume slider
    const deVolSlider = document.getElementById('deVolSlider');
    if (deVolSlider) deVolSlider.value = val;
    
    updateVolIcon(val);
}

function toggleMute() {
    player.muted = !player.muted;
    updateVolIcon(player.muted ? 0 : player.volume);
    
    // Update both sliders
    const deVolSlider = document.getElementById('deVolSlider');
    const volSlider = document.getElementById('volSlider');
    
    if (!player.muted && player.volume === 0) {
        player.volume = 0.5;
        if (volSlider) volSlider.value = 0.5;
        if (deVolSlider) deVolSlider.value = 0.5;
        updateVolIcon(0.5);
    }
}

function updateVolIcon(val) {
    const icon = document.getElementById('volIcon');
    const deVolIcon = document.getElementById('deVolIcon');
    const slider = document.getElementById('volSlider');
    
    if (!player.muted) slider.value = val;
    
    if (player.muted || val == 0) {
        icon.className = 'fa-solid fa-volume-xmark';
        icon.style.opacity = "0.5";
        if (deVolIcon) {
            deVolIcon.className = 'fa-solid fa-volume-xmark';
            deVolIcon.style.opacity = "0.5";
        }
    } else {
        icon.style.opacity = "0.8";
        if (val < 0.5) {
            icon.className = 'fa-solid fa-volume-low';
            if (deVolIcon) {
                deVolIcon.className = 'fa-solid fa-volume-low';
                deVolIcon.style.opacity = "0.7";
            }
        } else {
            icon.className = 'fa-solid fa-volume-high';
            if (deVolIcon) {
                deVolIcon.className = 'fa-solid fa-volume-high';
                deVolIcon.style.opacity = "0.7";
            }
        }
    }
}

function updateBuffer() {
    if (player.duration > 0) {
        for (let i = 0; i < player.buffered.length; i++) {
            if (player.buffered.start(i) <= player.currentTime && player.buffered.end(i) >= player.currentTime) {
                const p = (player.buffered.end(i) / player.duration) * 100;
                document.getElementById("buffFill").style.width = p + "%";
                document.getElementById("fsBuffFill").style.width = p + "%";
                break;
            }
        }
    }
}

player.ontimeupdate = () => {
    const p = player.duration ? (player.currentTime / player.duration) * 100 : 0;
    const cur = Math.floor(player.currentTime/60) + ":" + Math.floor(player.currentTime%60).toString().padStart(2,'0');
    const dur = Math.floor(player.duration/60||0) + ":" + Math.floor(player.duration%60||0).toString().padStart(2,'0');

    document.getElementById("progFill").style.width = p + "%";
    document.getElementById("curTime").textContent = cur;
    document.getElementById("durTime").textContent = dur;
    
    // Clean View Updates
    const deFill = document.getElementById("deProgFill");
    if(deFill) {
        deFill.style.width = p + "%";
        document.getElementById("deCurTime").textContent = cur;
        document.getElementById("deDurTime").textContent = dur;
        document.getElementById("deProgScrub").value = p;
    }
    
    document.getElementById("fsProgFill").style.width = p + "%";
    document.getElementById("fsCurTime").textContent = cur;
    document.getElementById("fsDurTime").textContent = dur;
    document.getElementById("fsProgScrub").value = p;
    document.getElementById("progScrub").value = p;
    
    updateBuffer();
};

document.addEventListener('input', (e) => {
    if (e.target.id === 'deProgScrub') {
        scrub(e.target.value);
    }
});

player.addEventListener('progress', updateBuffer);

player.onplay = () => {
    // Resume audio context if suspended (browser autoplay policy)
    if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
    }
    if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    
    document.getElementById("playIcon").className = "fa-solid fa-pause";
    document.getElementById("fsPlayIcon").className = "fa-solid fa-pause";
    const dePlay = document.getElementById("dePlayIcon");
    if(dePlay) dePlay.className = "fa-solid fa-pause";
    document.body.classList.add('playing');
};

player.onpause = () => {
    document.getElementById("playIcon").className = "fa-solid fa-play";
    document.getElementById("fsPlayIcon").className = "fa-solid fa-play";
    const dePlay = document.getElementById("dePlayIcon");
    if(dePlay) dePlay.className = "fa-solid fa-play";
    document.body.classList.remove('playing');
};

player.onended = () => {
    skip(1);
};

// Extended View Toggle Logic
function toggleDesktopExtended() {
    const panel = document.getElementById("desktopExtended");
    panel.classList.toggle("collapsed");
    // Ensure queue is rendered if opening
    if (!panel.classList.contains("collapsed")) {
        // Defer renderQueue for smoother UI
        setTimeout(() => renderQueue(), 0);
    }
}

document.getElementById('bassSlider').addEventListener('input', (e) => {
    updateBass(e.target.value);
});

document.getElementById('trebleSlider').addEventListener('input', (e) => {
    updateTreble(e.target.value);
});

// Desktop extended volume slider
document.getElementById('deVolSlider').addEventListener('input', (e) => {
    setVolume(e.target.value);
});

// ==================== Cover Picker ====================

// Configuration





// ==================== Notification Helper ====================

/**
 * Shows a notification to the user
 */
function showNotification(message) {
    // Create notification element
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        bottom: 140px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--md-sys-color-primary);
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        z-index: 5000;
        animation: fadeInOut 2.5s ease-in-out forwards;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    notification.textContent = message;

    document.body.appendChild(notification);

    // Remove after animation
    setTimeout(() => {
        notification.remove();
    }, 2500);
}

if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
} else {
    init();
}
</script>
</body>
</html>
