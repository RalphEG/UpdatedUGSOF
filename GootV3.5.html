<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Home - Classroom</title>
<link rel="icon" type="image/svg+xml" href="https://www.gstatic.com/classroom/logo_square_rounded.svg">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
<link rel="stylesheet" href="https://site-assets.fontawesome.com/releases/v6.5.1/css/all.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jsmediatags/3.9.5/jsmediatags.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Google+Sans:wght@400;500;700&family=Roboto+Mono&display=swap');
:root {
    --md-sys-color-primary: #ff4d4d;
    --md-sys-color-primary-container: rgba(255, 77, 77, 0.15);
    --md-sys-color-surface: #0b0d0e;
    --md-sys-color-surface-variant: #1a1c1e;
    --md-sys-color-on-surface: #e2e2e6;
    --md-sys-color-outline: #42474e;
    --md-sys-color-on-primary: #ffffff;
    --md-sys-color-background: #060809;
    --md-sys-color-on-background: #e2e2e6;
    --motion-standard: cubic-bezier(0.2, 0, 0, 1);
    --nav-height: 0px;
}
[data-theme="light"] {
    --md-sys-color-primary: #b71c1c;
    --md-sys-color-primary-container: rgba(183, 28, 28, 0.12);
    --md-sys-color-surface: #f8f9fa;
    --md-sys-color-surface-variant: #e8eaed;
    --md-sys-color-on-surface: #1f1f1f;
    --md-sys-color-outline: #757575;
    --md-sys-color-on-primary: #ffffff;
    --md-sys-color-background: #ffffff;
    --md-sys-color-on-background: #212121;
}
* { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-thumb { background: var(--md-sys-color-primary); border-radius: 10px; }
body {
    font-family: 'Google Sans', sans-serif;
    background: var(--md-sys-color-background);
    color: var(--md-sys-color-on-background);
    margin: 0; height: 100vh; display: flex;
    flex-direction: column; overflow: hidden;
    transition: background-color 0.4s ease, color 0.4s ease;
}
.app-shell { display: flex; flex: 1; overflow: hidden; position: relative; }
.nav-rail {
    width: 88px; background: var(--md-sys-color-surface);
    border-right: 1px solid var(--md-sys-color-outline);
    display: flex; flex-direction: column; align-items: center;
    padding: 24px 0; gap: 12px; z-index: 100; flex-shrink: 0;
}
.main-container { flex: 1; padding: 40px 60px; overflow-y: auto; position: relative; padding-bottom: 120px; }

/* Performance optimization during bulk metadata loading */
.main-container.bulk-loading {
    will-change: contents;
}

/* Reduce animations during bulk loading */
.main-container.bulk-loading .updating {
    transition: none !important;
}

.main-container.bulk-loading .updated {
    animation: none !important;
}
.side-sheet {
    width: 380px; background: var(--md-sys-color-surface);
    border-left: 1px solid var(--md-sys-color-outline);
    display: flex; flex-direction: column;
    transition: transform 0.4s var(--motion-standard);
    z-index: 300;
}
.side-sheet.collapsed { transform: translateX(100%); width: 0; border: none; }
.player-bar {
    height: 110px; background: rgba(11,13,14,0.98);
    backdrop-filter: blur(20px); border-top: 1px solid var(--md-sys-color-outline);
    display: flex; align-items: center; padding: 0 40px; gap: 24px; z-index: 200;
    transition: all 0.3s ease;
}

/* Player bar button hover effects */
#btnShuffle:hover,
#btnRepeat:hover {
    opacity: 1 !important;
    transform: scale(1.15);
}

.player-bar .fa-backward-step:hover,
.player-bar .fa-forward-step:hover {
    transform: scale(1.15);
}

.player-bar .play-btn:hover {
    background: var(--md-sys-color-primary) !important;
    color: white !important;
    transform: scale(1.12);
}

.player-bar .play-btn:active {
    transform: scale(0.95);
}

body.playing .player-bar .play-btn {
    animation: playerHeartbeat 2.4s infinite ease-in-out;
}

@keyframes playerHeartbeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.12); }
}

[data-theme="light"] .player-bar { background: rgba(255,255,255,0.95); }
.screen { display: none; opacity: 0; transform: translateY(24px) scale(0.98); transition: opacity 0.6s cubic-bezier(0.16,1,0.3,1), transform 0.6s cubic-bezier(0.16,1,0.3,1); }
.screen.active { display: block; opacity: 1; transform: translateY(0) scale(1); }
img { opacity: 0; transition: opacity 0.6s var(--motion-standard); }
img.loaded { opacity: 1; }
.folder-grid {
    display: grid; grid-template-columns: repeat(auto-fill, minmax(180px,1fr)); gap: 24px; position: relative; z-index: 1;
    width: 100%;
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 24px;
}
.folder-card {
    background: #000; aspect-ratio: 1/1; border-radius: 20px; cursor: pointer; overflow: hidden; position: relative;
    border: 1px solid var(--md-sys-color-outline);
    opacity: 0; transform: translateY(16px) scale(0.96);
    transition: opacity 0.4s cubic-bezier(0.16,1,0.3,1), transform 0.4s cubic-bezier(0.16,1,0.3,1), box-shadow 0.3s ease;
    z-index: 1;
}
.folder-card.loaded { opacity: 1; transform: translateY(0) scale(1); }
.folder-card:hover { transform: translateY(-4px) scale(1.02); box-shadow: 0 12px 28px rgba(0,0,0,0.5), 0 0 0 1px var(--md-sys-color-primary); border-color: var(--md-sys-color-primary); }
.folder-art { 
    position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 1; background: linear-gradient(135deg, #1a1a1a 0%, #000 100%); 
}
.folder-art img { 
    width: 100%; height: 100%; object-fit: cover; position: absolute; inset: 0;
    opacity: 0;
    transition: opacity 0.4s ease, transform 0.6s cubic-bezier(0.16,1,0.3,1);
    transform: scale(1.05);
}
.folder-art img.loaded { 
    opacity: 1;
    transform: scale(1);
}
.folder-info { position: absolute; inset: 0; z-index: 2; padding: 12px; display: flex; align-items: flex-end; background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.4) 50%, transparent 100%); }
.folder-info span { font-weight: 600; font-size: 14px; color: white; }
.playlist-card .play-overlay {
    position: absolute; inset: 0; display: flex; flex-direction: column; justify-content: flex-end; align-items: flex-end;
    padding: 16px; opacity: 0; transition: opacity 0.4s var(--motion-standard); pointer-events: none;
    background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, transparent 60%); z-index: 3;
}
.playlist-card:hover .play-overlay { opacity: 1; pointer-events: auto; }
.play-overlay .control-group { display: flex; flex-direction: column; gap: 12px; align-items: center; }
.play-overlay .control-btn {
    width: 56px; height: 56px; border-radius: 50%; background: var(--md-sys-color-primary); color: white;
    display: flex; align-items: center; justify-content: center; font-size: 22px;
    box-shadow: 0 4px 16px rgba(0,0,0,0.5); transition: transform 0.3s ease;
}
.play-overlay .control-btn.shuffle { background: color-mix(in srgb, var(--md-sys-color-primary) 70%, #333); }
.play-overlay .control-btn:hover { transform: scale(1.15); }
.play-overlay .btn-label { color: white; font-size: 13px; font-weight: 500; text-shadow: 0 1px 4px rgba(0,0,0,0.8); }

/* Listen Again section - smaller control buttons */
.listen-again-track-card .play-overlay .control-btn {
    width: 36px; height: 36px; font-size: 14px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.5);
}
.listen-again-track-card .play-overlay .control-group {
    gap: 8px;
}
.listen-again-track-card .play-overlay .btn-label {
    font-size: 10px;
}
.playlist-header { display: flex; align-items: center; gap: 32px; margin-bottom: 32px; flex-wrap: wrap; }
.playlist-cover {
    width: 240px; height: 240px; border-radius: 16px; overflow: hidden; background: var(--md-sys-color-surface-variant);
    box-shadow: 0 8px 32px rgba(0,0,0,0.4); position: relative; cursor: pointer;
}

.playlist-cover img { width: 100%; height: 100%; object-fit: cover; }
.playlist-cover .no-art { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 80px; opacity: 0.25; }

.playlist-info { flex: 1; min-width: 300px; }
.playlist-controls { display: flex; gap: 16px; margin-top: 16px; }
.playlist-management { display: flex; gap: 12px; margin-top: 24px; flex-wrap: wrap; }
.playlist-breadcrumb { display: flex; align-items: center; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; }
.playlist-breadcrumb .chip {
    padding: 8px 16px; background: var(--md-sys-color-surface-variant); border-radius: 100px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;
}
.playlist-breadcrumb .chip:hover { background: var(--md-sys-color-primary-container); color: var(--md-sys-color-primary); }
.breadcrumb-chip {
    padding: 8px 16px; background: var(--md-sys-color-surface-variant); border-radius: 100px; font-size: 13px; cursor: pointer; transition: all 0.3s ease;
}
.breadcrumb-chip:hover { background: var(--md-sys-color-primary-container); color: var(--md-sys-color-primary); }
.song-row { 
    cursor: pointer;
    /* Start hidden and shifted down */
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.4s var(--motion-standard), transform 0.4s var(--motion-standard);
}
.song-row.loaded {
    opacity: 1;
    transform: translateY(0);
}

/* Metadata load animation - subtle fade for when text updates */
.meta-title, .meta-artist, .meta-album {
    transition: opacity 0.3s ease;
}
.meta-title.updating, .meta-artist.updating, .meta-album.updating {
    opacity: 0.5;
}
.meta-title.updated, .meta-artist.updated, .meta-album.updated {
    opacity: 1;
}

.song-row:hover td { background: var(--md-sys-color-primary-container); }
.song-row td:first-child { border-radius: 12px 0 0 12px; }
.song-row td:last-child { border-radius: 0 12px 12px 0; }
.song-row { cursor: grab; }
.song-row:active { cursor: grabbing; }

/* Playlist drag handle */
.playlist-drag-handle {
    opacity: 0.3;
    cursor: grab;
    padding: 4px 8px;
    transition: opacity 0.2s;
    display: flex;
    align-items: center;
    justify-content: center;
}
.playlist-drag-handle:hover { opacity: 1; }
.playlist-drag-handle:active { cursor: grabbing; }
.sortable-ghost { opacity: 0.4; background: var(--md-sys-color-primary-container); }

.queue-item.visible { opacity: 1; transform: translateX(0); }
.queue-item:hover { background: var(--md-sys-color-primary-container); transform: translateX(6px); }
.queue-item.active { background: var(--md-sys-color-primary-container); border-left: 4px solid var(--md-sys-color-primary); }

/* Disable transitions during drag for smooth animation */
.queue-item.sortable-chosen { transition: none; }
.queue-item.sortable-ghost { transition: none; opacity: 0.4; background: var(--md-sys-color-primary-container); }

/* Queue drag handle */
.queue-drag-handle {
    opacity: 0.3;
    cursor: grab;
    padding: 4px;
    transition: opacity 0.2s;
}
.queue-drag-handle:hover { opacity: 1; }
.queue-drag-handle:active { cursor: grabbing; }

/* Queue drag animations - matching playlist style */
.queue-sort-drag {
    opacity: 1;
    transform: scale(1.02);
    box-shadow: 0 8px 32px rgba(0,0,0,0.4);
    z-index: 100;
}
.nav-item { width: 100%; display: flex; flex-direction: column; align-items: center; cursor: pointer; gap: 4px; opacity: 0.6; transition: all 0.4s var(--motion-standard); }
.nav-item.active { opacity: 1; color: var(--md-sys-color-primary); transform: scale(1.08); }
.nav-icon-wrapper { width: 56px; height: 32px; border-radius: 16px; display: flex; align-items: center; justify-content: center; transition: all 0.4s var(--motion-standard); }
.nav-item.active .nav-icon-wrapper { background: var(--md-sys-color-primary-container); transform: scale(1.1); }
.play-btn {
    width: 56px; height: 56px; border-radius: 50%; background: var(--md-sys-color-primary); color: white;
    display: flex; align-items: center; justify-content: center; font-size: 20px; cursor: pointer;
    transition: all 0.4s cubic-bezier(0.175,0.885,0.32,1.275);
}
.play-btn:hover { transform: scale(1.12); filter: brightness(1.15); }
body.playing .play-btn,
body.playing .clean-btn.play-btn-large {
    animation: heartbeat 2.4s infinite ease-in-out;
}

@keyframes heartbeat {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.12); }
}

@keyframes fadeInOut {
    0% { opacity: 0; transform: translateX(-50%) translateY(10px); }
    15% { opacity: 1; transform: translateX(-50%) translateY(0); }
    85% { opacity: 1; transform: translateX(-50%) translateY(0); }
    100% { opacity: 0; transform: translateX(-50%) translateY(-10px); }
}
.action-btn {
    background: var(--md-sys-color-surface-variant); color: white; border: 1px solid var(--md-sys-color-outline);
    padding: 10px 20px; border-radius: 12px; cursor: pointer; display: inline-flex; align-items: center; gap: 8px; font-size: 14px;
    transition: all 0.3s var(--motion-standard);
}
.action-btn:hover { border-color: var(--md-sys-color-primary); background: var(--md-sys-color-primary-container); transform: translateY(-2px); }

/* Material 3 Expressive Buttons */
.m3-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 10px 16px;
    border-radius: 16px;
    border: none;
    cursor: pointer;
    font-family: inherit;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.3s var(--motion-standard);
}

.m3-btn i {
    font-size: 18px;
}

.m3-btn span {
    font-weight: 500;
}

/* Filled button - accent color background */
.m3-btn-filled {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.m3-btn-filled:hover {
    background: var(--md-sys-color-primary);
    filter: brightness(1.1);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}

.m3-btn-filled:active {
    transform: translateY(0);
    filter: brightness(0.95);
}

/* Tonal button - secondary with accent tint */
.m3-btn-tonal {
    background: var(--md-sys-color-secondary-container);
    color: var(--md-sys-color-on-secondary-container);
    border: 1px solid var(--md-sys-color-outline);
}

.m3-btn-tonal:hover {
    background: var(--md-sys-color-primary-container);
    border-color: var(--md-sys-color-primary);
    transform: translateY(-2px);
}

.m3-btn-tonal:active {
    transform: translateY(0);
}

/* Text button style */
.m3-btn-text {
    background: transparent;
    color: var(--md-sys-color-primary);
    border: 1px solid transparent;
}
.m3-btn-text:hover {
    background: var(--md-sys-color-primary-container);
}
.m3-btn-text:active {
    background: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
}

/* Modal selection button style (None/All buttons) */
.m3-btn-modal-action {
    background: var(--md-sys-color-surface-variant);
    color: var(--md-sys-color-on-surface);
    border: 1px solid var(--md-sys-color-outline);
    border-radius: 20px;
    min-width: 72px;
    font-weight: 500;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
}
.m3-btn-modal-action:hover {
    background: var(--md-sys-color-outline);
    border-color: var(--md-sys-color-outline);
    color: var(--md-sys-color-on-surface);
}
.m3-btn-modal-action:active {
    background: var(--md-sys-color-primary);
    border-color: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary);
}

/* Delete button specific styling */
.m3-btn.playlist-delete-btn {
    --md-sys-color-on-secondary-container: #ff4444;
    --md-sys-color-secondary-container: rgba(255, 68, 68, 0.15);
}

.m3-btn.playlist-delete-btn:hover {
    background: rgba(255, 68, 68, 0.25);
    border-color: #ff4444;
    transform: translateY(-2px);
}

/* New Playlist Big Square Card */
.new-playlist-card {
    cursor: pointer;
}

.new-playlist-icon {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--md-sys-color-surface-variant);
    border: 2px dashed var(--md-sys-color-outline);
    border-radius: 20px;
    transition: all 0.3s ease;
}

.new-playlist-card:hover .new-playlist-icon {
    border-color: var(--md-sys-color-primary);
    background: var(--md-sys-color-primary-container);
}

.new-playlist-icon i {
    font-size: 48px;
    color: var(--md-sys-color-on-surface);
    opacity: 0.4;
    transition: all 0.3s ease;
}

.new-playlist-card:hover .new-playlist-icon i {
    opacity: 1;
    color: var(--md-sys-color-primary);
    transform: scale(1.1);
}

.new-playlist-label {
    position: absolute;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 13px;
    font-weight: 600;
    color: var(--md-sys-color-on-surface);
    opacity: 0.8;
    white-space: nowrap;
    text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
}

/* Light mode new playlist card */
[data-theme="light"] .new-playlist-icon {
    background: #f5f5f5;
}

[data-theme="light"] .new-playlist-label {
    text-shadow: 0 1px 4px rgba(255, 255, 255, 0.8);
}

/* Pin button on playlist/folder cards */
.pin-btn {
    position: absolute;
    top: 12px;
    left: 12px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: rgba(0, 0, 0, 0.5);
    border: none;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    opacity: 1;
    transition: all 0.2s ease;
    z-index: 100;
    backdrop-filter: blur(4px);
}

.folder-card .pin-btn,
.playlist-card .pin-btn {
    z-index: 100;
}

.folder-card:hover .pin-btn,
.playlist-card:hover .pin-btn {
    opacity: 1;
}

.pin-btn:hover {
    background: var(--md-sys-color-primary);
    transform: scale(1.1);
}

.pin-btn i {
    transition: transform 0.2s ease;
}

.pin-btn:hover i {
    transform: rotate(45deg);
}

.labeled-pin-btn {
    flex-direction: row;
    gap: 4px;
    padding: 0 12px;
    width: auto;
    height: 28px;
    font-size: 11px;
    border-radius: 14px;
    z-index: 1000;
    pointer-events: auto !important;
    position: relative; /* Ensure it's in the stacking context */
}

/* Ensure pin button is always clickable */
.folder-card .labeled-pin-btn {
    position: absolute;
    top: 12px;
    left: 12px;
    pointer-events: auto !important;
}

.labeled-pin-btn span {
    font-weight: 500;
}

/* Track actions container */
.track-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
}

.track-actions .m3-btn {
    padding: 8px 14px;
    border-radius: 12px;
}

.track-actions .m3-btn i {
    font-size: 14px;
}

.track-actions .m3-btn span {
    font-size: 12px;
}

/* Icon-only button for queue items */
.m3-btn-icon {
    padding: 8px;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
}

/* Queue hover menu - slides in from the left when hovering ellipsis */
.queue-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    cursor: pointer;
    border-bottom: 1px solid rgba(255,255,255,0.05);
    position: relative;
    overflow: hidden;
}

.queue-item-content {
    display: flex;
    align-items: center;
    gap: 12px;
    flex: 1;
    transition: opacity 0.25s var(--motion-standard);
    z-index: 1;
}

.queue-hover-menu {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    gap: 8px;
    padding: 12px 16px;
    background: var(--md-sys-color-surface-variant);
    transform: translateX(-100%);
    opacity: 0;
    z-index: 10;
    transition: transform 0.3s var(--motion-standard), opacity 0.2s ease;
}

/* Trigger hover menu from ellipsis button hover */
.queue-item:has(.queue-ellipsis:hover) .queue-hover-menu {
    transform: translateX(0);
    opacity: 1;
}

/* Also show menu when directly hovering the menu itself */
.queue-item:has(.queue-hover-menu:hover) .queue-hover-menu {
    transform: translateX(0);
    opacity: 1;
}

/* Fade out main content when menu is visible */
.queue-item:has(.queue-ellipsis:hover) .queue-item-content,
.queue-item:has(.queue-hover-menu:hover) .queue-item-content {
    opacity: 0;
}

.queue-hover-menu .m3-btn {
    padding: 8px 12px;
}

.queue-hover-menu .m3-btn i {
    font-size: 14px;
}

.queue-hover-menu .m3-btn span {
    font-size: 12px;
    font-weight: 500;
}

/* Light mode queue hover menu */
[data-theme="light"] .queue-hover-menu {
    background: #e8eaed;
}
[data-theme="light"] .queue-hover-menu .m3-btn {
    color: var(--md-sys-color-on-surface);
}

/* --- VOLUME NORMALIZATION STYLES --- */

.norm-container {
    background: var(--md-sys-color-surface-variant);
    border-radius: 24px;
    padding: 24px;
    border: 1px solid var(--md-sys-color-outline);
    margin-top: 24px;
}

.norm-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 20px;
}

.norm-title {
    font-size: 16px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 10px;
}

.norm-title i {
    color: var(--md-sys-color-primary);
}

.norm-toggle-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 0;
    border-bottom: 1px solid var(--md-sys-color-outline);
}

.norm-toggle-label {
    font-size: 14px;
    font-weight: 500;
}

.norm-target-row {
    padding: 16px 0;
    border-bottom: 1px solid var(--md-sys-color-outline);
}

.norm-target-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    font-size: 14px;
    font-weight: 500;
}

.norm-target-value {
    color: var(--md-sys-color-primary);
    font-weight: 600;
    font-variant-numeric: tabular-nums;
}

.norm-slider-container {
    display: flex;
    align-items: center;
    gap: 16px;
}

.norm-slider {
    flex: 1;
    -webkit-appearance: none;
    appearance: none;
    height: 6px;
    background: rgba(255,255,255,0.12);
    border-radius: 3px;
    cursor: pointer;
}

.norm-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px;
    height: 20px;
    background: var(--md-sys-color-primary);
    border-radius: 50%;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    cursor: pointer;
    transition: transform 0.15s ease;
}

.norm-slider::-webkit-slider-thumb:hover {
    transform: scale(1.15);
}

.norm-slider::-webkit-slider-runnable-track {
    height: 6px;
    background: rgba(255,255,255,0.12);
    border-radius: 3px;
}

.norm-loudness-labels {
    display: flex;
    justify-content: space-between;
    margin-top: 8px;
    font-size: 11px;
    opacity: 0.6;
}

.norm-status {
    margin-top: 16px;
    padding: 12px 16px;
    background: rgba(0,0,0,0.2);
    border-radius: 12px;
    font-size: 13px;
    display: flex;
    align-items: center;
    gap: 10px;
}

.norm-status i {
    color: var(--md-sys-color-primary);
}

.norm-indicator {
    position: absolute;
    bottom: 8px;
    right: 8px;
    font-size: 10px;
    padding: 4px 8px;
    background: var(--md-sys-color-primary-container);
    color: var(--md-sys-color-primary);
    border-radius: 100px;
    font-weight: 600;
    display: flex;
    align-items: center;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.norm-indicator.visible {
    opacity: 1;
}

.norm-gain-value {
    font-size: 11px;
    opacity: 0.8;
    margin-left: 4px;
}

/* Light mode normalization styles */
[data-theme="light"] .norm-container {
    background: var(--md-sys-color-surface);
}
[data-theme="light"] .norm-slider {
    background: rgba(0,0,0,0.12);
}
[data-theme="light"] .norm-slider::-webkit-slider-runnable-track {
    background: rgba(0,0,0,0.12);
}
[data-theme="light"] .norm-status {
    background: rgba(0,0,0,0.06);
}

/* --- LUFS SLIDER STYLES --- */

.lufs-control-section {
    background: var(--md-sys-color-surface);
    border-radius: 24px;
    padding: 24px;
    margin-top: 16px;
    border: 1px solid var(--md-sys-color-outline);
}

.lufs-header {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 24px;
}

.lufs-icon {
    width: 56px;
    height: 56px;
    background: linear-gradient(135deg, var(--md-sys-color-primary-container), color-mix(in srgb, var(--md-sys-color-primary) 20%, var(--md-sys-color-surface)));
    border-radius: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.lufs-icon i {
    font-size: 24px;
    color: var(--md-sys-color-primary);
}

.lufs-title-area {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.lufs-label {
    font-size: 13px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
    opacity: 0.6;
}

.lufs-value {
    font-size: 32px;
    font-weight: 700;
    color: var(--md-sys-color-primary);
    font-variant-numeric: tabular-nums;
    text-shadow: 0 0 20px color-mix(in srgb, var(--md-sys-color-primary) 30%, transparent);
}

.lufs-slider-container {
    position: relative;
    height: 80px;
    padding: 0 10px;
}

.lufs-slider {
    position: absolute;
    width: calc(100% - 20px);
    height: 8px;
    top: 36px;
    left: 10px;
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    z-index: 3;
}

.lufs-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 24px;
    height: 24px;
    background: white;
    border-radius: 50%;
    border: 3px solid var(--md-sys-color-primary);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3), 0 0 16px color-mix(in srgb, var(--md-sys-color-primary) 40%, transparent);
    cursor: pointer;
    transition: transform 0.2s var(--motion-standard), box-shadow 0.2s var(--motion-standard);
    margin-top: -2px;
}

.lufs-slider::-webkit-slider-thumb:hover {
    transform: scale(1.15);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 24px color-mix(in srgb, var(--md-sys-color-primary) 50%, transparent);
}

.lufs-slider::-webkit-slider-thumb:active {
    transform: scale(1.1);
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.5), 0 0 32px color-mix(in srgb, var(--md-sys-color-primary) 60%, transparent);
}

.lufs-slider::-moz-range-thumb {
    width: 24px;
    height: 24px;
    background: white;
    border-radius: 50%;
    border: 3px solid var(--md-sys-color-primary);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3), 0 0 16px color-mix(in srgb, var(--md-sys-color-primary) 40%, transparent);
    cursor: pointer;
}

.lufs-track {
    position: absolute;
    top: 36px;
    left: 10px;
    right: 10px;
    height: 8px;
    background: rgba(255, 255, 255, 0.12);
    border-radius: 8px;
    overflow: hidden;
    border: none;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
}

.lufs-progress {
    height: 100%;
    background: linear-gradient(90deg, var(--md-sys-color-primary), color-mix(in srgb, var(--md-sys-color-primary) 80%, #fff));
    border-radius: 8px;
    width: 0%;
    transition: width 0.15s ease-out;
    box-shadow: 0 0 12px color-mix(in srgb, var(--md-sys-color-primary) 50%, transparent);
    position: relative;
}

.lufs-progress::after {
    content: '';
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    width: 12px;
    height: 12px;
    background: var(--md-sys-color-primary);
    border-radius: 50%;
    box-shadow: 0 0 8px var(--md-sys-color-primary), 0 0 16px color-mix(in srgb, var(--md-sys-color-primary) 60%, transparent);
}

.lufs-markers {
    position: absolute;
    left: 10px;
    right: 10px;
    bottom: 0;
    height: 36px;
    display: flex;
}

.lufs-marker[data-value="-23"] { left: 0%; }
.lufs-marker[data-value="-18"] { left: 33.33%; }
.lufs-marker[data-value="-14"] { left: 60%; }
.lufs-marker[data-value="-10"] { left: 86.67%; }
.lufs-marker[data-value="-8"] { left: 100%; }

.lufs-marker {
    position: absolute;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    cursor: pointer;
    transition: transform 0.2s var(--motion-standard);
    min-width: 48px;
}

.lufs-marker:hover {
    transform: translateX(-50%) translateY(-3px);
}

.lufs-marker .marker-line {
    width: 2px;
    height: 10px;
    background: rgba(255, 255, 255, 0.25);
    border-radius: 2px;
    transition: all 0.2s var(--motion-standard);
}

.lufs-marker.active .marker-line {
    background: var(--md-sys-color-primary);
    height: 14px;
    box-shadow: 0 0 8px color-mix(in srgb, var(--md-sys-color-primary) 50%, transparent);
}

.lufs-marker.active .marker-dot {
    background: var(--md-sys-color-primary);
    border-color: var(--md-sys-color-primary);
    transform: scale(1.2);
    box-shadow: 0 0 12px color-mix(in srgb, var(--md-sys-color-primary) 60%, transparent);
}

.lufs-marker.active .marker-label {
    color: var(--md-sys-color-primary);
    font-weight: 700;
}

.marker-dot {
    width: 14px;
    height: 14px;
    background: rgba(255, 255, 255, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.4);
    border-radius: 50%;
    transition: all 0.2s var(--motion-standard);
}

.marker-label {
    font-size: 13px;
    font-weight: 600;
    opacity: 0.7;
    color: var(--md-sys-color-on-surface);
    font-variant-numeric: tabular-nums;
}

.marker-desc {
    font-size: 10px;
    font-weight: 500;
    text-transform: uppercase;
    letter-spacing: 0.8px;
    opacity: 0.5;
    margin-top: -2px;
}



[data-theme="light"] .lufs-control-section {
    background: var(--md-sys-color-surface-variant);
}

[data-theme="light"] .lufs-track {
    background: rgba(0, 0, 0, 0.08);
    border-color: rgba(0, 0, 0, 0.1);
}

[data-theme="light"] .marker-dot {
    background: rgba(0, 0, 0, 0.2);
    border-color: rgba(0, 0, 0, 0.3);
}

/* --- LISTEN AGAIN SECTION --- */
/* Uses same styling as folder-card to match home screen aesthetic */

.listen-again-container {
    margin-bottom: 32px;
    width: 100%;
    max-width: 1400px;
    margin-left: auto;
    margin-right: auto;
    padding: 0 24px;
}

/* Horizontal scroll container - no wrapping */
.listen-again-scroll-container {
    display: flex;
    flex-direction: row;
    align-items: flex-start;
    justify-content: flex-start;
    gap: 24px;
    overflow-x: auto;
    overflow-y: visible;
    padding: 8px 0 24px 0;
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
    scrollbar-width: thin;
    scrollbar-color: var(--md-sys-color-primary) transparent;
}

.listen-again-scroll-container::-webkit-scrollbar {
    height: 6px;
}

.listen-again-scroll-container::-webkit-scrollbar-thumb {
    background: var(--md-sys-color-primary);
    border-radius: 3px;
}

.listen-again-scroll-container::-webkit-scrollbar-track {
    background: transparent;
}

.listen-again-header {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin-bottom: 24px;
    flex-wrap: wrap;
    gap: 16px;
    text-align: center;
}

.listen-again-title {
    font-size: 32px;
    font-weight: 700;
    margin: 0;
    color: var(--md-sys-color-on-background);
    letter-spacing: -0.5px;
    position: relative;
}

.listen-again-title::after {
    content: '';
    position: absolute;
    bottom: -4px;
    left: 0;
    width: 40px;
    height: 4px;
    background: var(--md-sys-color-primary);
    border-radius: 2px;
}

.listen-again-actions {
    display: flex;
    gap: 12px;
}

.listen-again-expand-btn {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    background: var(--md-sys-color-surface-container);
    border: 1px solid var(--md-sys-color-outline);
    border-radius: 100px;
    color: var(--md-sys-color-on-surface);
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
}

.listen-again-expand-btn:hover {
    background: var(--md-sys-color-primary-container);
    border-color: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary-container);
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(var(--md-sys-color-primary-rgb), 0.3);
}

/* --- SKELETON LOADING STATES --- */

/* Shimmer animation for skeleton loading */
@keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
}

/* Smooth pulse for empty states */
@keyframes pulse-subtle {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
}

/* Skeleton container for loading states */
.skeleton-container {
    opacity: 0;
    transition: opacity 0.4s ease;
}

.skeleton-container.loading {
    opacity: 1;
}

/* Listen Again skeleton */
.listen-again-skeleton {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 24px;
    width: 100%;
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 24px;
}

.listen-again-skeleton-item {
    aspect-ratio: 1/1;
    border-radius: 20px;
    background: var(--md-sys-color-surface-container);
    position: relative;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.listen-again-skeleton-item .skeleton-art {
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--md-sys-color-surface-container) 0%, var(--md-sys-color-surface-variant) 100%);
    background-size: 200% 200%;
    animation: shimmer 2s ease-in-out infinite;
    border-radius: 20px;
}

.listen-again-skeleton-item .skeleton-text {
    position: absolute;
    bottom: 16px;
    left: 16px;
    right: 16px;
}

.listen-again-skeleton-item .skeleton-title {
    height: 14px;
    background: linear-gradient(90deg, var(--md-sys-color-surface-variant) 25%, rgba(255,255,255,0.12) 50%, var(--md-sys-color-surface-variant) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s ease-in-out infinite;
    border-radius: 4px;
    margin-bottom: 8px;
}

.listen-again-skeleton-item .skeleton-subtitle {
    height: 12px;
    width: 60%;
    background: linear-gradient(90deg, var(--md-sys-color-surface-variant) 25%, rgba(255,255,255,0.06) 50%, var(--md-sys-color-surface-variant) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s ease-in-out infinite;
    border-radius: 4px;
}

/* Folder grid skeleton */
.folder-grid-skeleton {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 24px;
    width: 100%;
    max-width: 1400px;
    margin: 0 auto;
    padding: 0 24px;
}

.folder-grid-skeleton .skeleton-folder {
    aspect-ratio: 1/1;
    border-radius: 20px;
    background: var(--md-sys-color-surface-container);
    position: relative;
    overflow: hidden;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.folder-grid-skeleton .skeleton-folder .skeleton-art {
    position: absolute;
    inset: 0;
    background: linear-gradient(135deg, var(--md-sys-color-surface-container) 0%, var(--md-sys-color-surface-variant) 100%);
    background-size: 200% 200%;
    animation: shimmer 2s ease-in-out infinite;
    border-radius: 20px;
}

.folder-grid-skeleton .skeleton-folder .skeleton-text {
    position: absolute;
    bottom: 16px;
    left: 16px;
    right: 16px;
}

.folder-grid-skeleton .skeleton-folder .skeleton-name {
    height: 16px;
    background: linear-gradient(90deg, var(--md-sys-color-surface-variant) 25%, rgba(255,255,255,0.12) 50%, var(--md-sys-color-surface-variant) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s ease-in-out infinite;
    border-radius: 4px;
    margin-bottom: 6px;
}

.folder-grid-skeleton .skeleton-folder .skeleton-count {
    height: 12px;
    width: 50%;
    background: linear-gradient(90deg, var(--md-sys-color-surface-variant) 25%, rgba(255,255,255,0.06) 50%, var(--md-sys-color-surface-variant) 75%);
    background-size: 200% 100%;
    animation: shimmer 1.5s ease-in-out infinite;
    border-radius: 4px;
}

/* Enhanced initial loading overlay */
.initial-loading-overlay {
    grid-column: 1/-1;
    text-align: center;
    padding: 80px 20px;
}

.initial-loading-overlay .loading-spinner {
    width: 48px;
    height: 48px;
    margin: 0 auto 24px;
    border: 3px solid var(--md-sys-color-surface-variant);
    border-top-color: var(--md-sys-color-primary);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
}

@keyframes spin {
    to { transform: rotate(360deg); }
}

.initial-loading-overlay .loading-text {
    font-size: 18px;
    font-weight: 500;
    color: var(--md-sys-color-on-surface);
    opacity: 0.8;
    margin-bottom: 8px;
}

.initial-loading-overlay .loading-subtext {
    font-size: 14px;
    color: var(--md-sys-color-on-surface);
    opacity: 0.5;
}

/* Content fade-in animation */
.content-fade-in {
    opacity: 0;
    transform: translateY(20px);
    transition: opacity 0.5s ease, transform 0.5s ease;
}

.content-fade-in.loaded {
    opacity: 1;
    transform: translateY(0);
}
/* Grid wrapper for horizontal scrolling */
.listen-again-grid {
    display: contents;
}

.listen-again-scroll-wrapper {
    flex: 1;
    min-width: 0;
    overflow: visible;
}

/* Track card styling matching folder-card */
.listen-again-track-card {
    flex-shrink: 0;
    width: 180px;
    height: 180px;
    background: #000;
    aspect-ratio: 1/1;
    border-radius: 20px;
    cursor: pointer;
    overflow: visible;
    position: relative;
    border: 1px solid var(--md-sys-color-outline);
    opacity: 0;
    transform: translateY(16px) scale(0.96);
    transition: opacity 0.4s cubic-bezier(0.16,1,0.3,1), transform 0.4s cubic-bezier(0.16,1,0.3,1), box-shadow 0.3s ease;
    transform-origin: center center;
    isolation: isolate;
}

.listen-again-track-card.loaded {
    opacity: 1;
    transform: translateY(0) scale(1);
}

.listen-again-track-card:hover {
    transform: translateY(-4px) scale(1.02);
    box-shadow: 0 12px 28px rgba(0,0,0,0.5), 0 0 0 1px var(--md-sys-color-primary);
    border-color: var(--md-sys-color-primary);
    z-index: 10;
    position: relative;
}

.listen-again-track-card:active {
    transform: scale(0.98);
}

.listen-again-track-art {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 1;
    background: linear-gradient(135deg, #1a1a1a 0%, #000 100%);
    border-radius: 20px;
    overflow: hidden;
}

.listen-again-track-art img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    position: absolute;
    inset: 0;
    border-radius: 20px;
    opacity: 0;
    transition: opacity 0.4s ease, transform 0.6s cubic-bezier(0.16,1,0.3,1);
    transform: scale(1.05);
}

.listen-again-track-art img.fade-in,
.listen-again-track-art img.loaded {
    opacity: 1;
    transform: scale(1);
}

/* Track table album art */
[class^="track-art-"] > img, [class*=" track-art-"] > img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
}
[class^="track-art-"] > img.fade-in, 
[class^="track-art-"] > img.loaded,
[class*=" track-art-"] > img.fade-in,
[class*=" track-art-"] > img.loaded {
    opacity: 1;
}

/* Player album art */
#npArt img, #fsArt img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}
#npArt img.fade-in, #npArt img.loaded,
#fsArt img.fade-in, #fsArt img.loaded {
    opacity: 1;
}

/* Playlist and folder art */
.folder-art img, .playlist-cover img, #playlistCover img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.4s ease, transform 0.6s cubic-bezier(0.16,1,0.3,1);
    transform: scale(1.05);
}
.folder-art img.fade-in, .folder-art img.loaded,
.playlist-cover img.fade-in, .playlist-cover img.loaded,
#playlistCover img.fade-in, #playlistCover img.loaded {
    opacity: 1;
    transform: scale(1);
}

/* Play overlay for Listen Again cards - SAME as playlist-card */
.listen-again-track-card .play-overlay {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    align-items: flex-end;
    padding: 12px;
    opacity: 0;
    transition: opacity 0.4s var(--motion-standard);
    pointer-events: none;
    background: linear-gradient(to top, rgba(0,0,0,0.7) 0%, transparent 60%);
    z-index: 3;
    border-radius: 20px;
    overflow: visible;
}

.listen-again-track-card:hover .play-overlay { opacity: 1; pointer-events: auto; }


/* Pin button in Listen Again play overlay */
.listen-again-pin-btn {
    position: absolute;
    top: 12px;
    left: 12px;
    width: 28px;
    height: 28px;
    border-radius: 50%;
    background: var(--md-sys-color-primary);
    border: none;
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    backdrop-filter: blur(4px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    z-index: 10; /* Higher than overlay's z-index: 3 */
}

.listen-again-pin-btn i {
    font-size: 14px;
}



.listen-again-pin-btn:hover i {
    transform: scale(1.1);
}



.listen-again-pin-btn:hover svg {
    transform: rotate(45deg) scale(1.1);
}

/* Play count badge */
.listen-again-count {
    background: rgba(0, 0, 0, 0.75);
    color: white;
    padding: 6px 10px;
    border-radius: 8px;
    font-size: 12px;
    font-weight: 600;
    font-variant-numeric: tabular-nums;
    backdrop-filter: blur(8px);
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
}

/* Track info overlay */
.listen-again-track-info {
    position: absolute;
    inset: 0;
    z-index: 2;
    padding: 12px;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
    background: linear-gradient(to top, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.4) 50%, transparent 100%);
    border-radius: 20px;
    overflow: visible;
}

.listen-again-track-title {
    font-weight: 600;
    font-size: 14px;
    color: white;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 4px;
    text-shadow: 0 2px 8px rgba(0,0,0,0.8);
}

.listen-again-track-artist {
    font-size: 12px;
    color: rgba(255,255,255,0.75);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    text-shadow: 0 1px 4px rgba(0,0,0,0.8);
}

/* Empty state */
.listen-again-empty {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 60px 20px;
    text-align: center;
    background: var(--md-sys-color-surface-container);
    border-radius: 20px;
    border: 1px solid var(--md-sys-color-outline-variant);
}

.listen-again-empty-icon {
    font-size: 48px;
    color: var(--md-sys-color-primary);
    margin-bottom: 16px;
    opacity: 0.4;
}

.listen-again-empty-text {
    font-size: 15px;
    color: var(--md-sys-color-on-surface);
    opacity: 0.6;
    margin: 0;
    max-width: 300px;
    line-height: 1.5;
}

/* Pinned item styles - make them look more prominent like pinned content */
.listen-again-track-card.pinned-item {
    border-color: var(--md-sys-color-primary);
}

.listen-again-track-card.pinned-item:hover {
    border-color: var(--md-sys-color-primary);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
}

/* Make pinned badge more prominent */
.pinned-badge {
    position: absolute;
    top: 8px;
    right: 8px;
    background: var(--md-sys-color-primary);
    color: white;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    z-index: 10;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    transition: transform 0.2s ease;
}

.pinned-badge i {
    font-size: 12px;
}

.unpin-btn {
    position: absolute;
    top: 8px;
    left: 8px;
    background: rgba(0, 0, 0, 0.6);
    color: white;
    width: 24px;
    height: 24px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    z-index: 10;
    cursor: pointer;
    opacity: 0;
    transition: opacity 0.2s ease, background 0.2s ease;
}

.listen-again-track-card:hover .unpin-btn {
    opacity: 1;
}

.unpin-btn:hover {
    background: var(--md-sys-color-primary);
}

/* Album consolidation styles */
.listen-again-track-card[data-album] .listen-again-track-info .listen-again-track-artist {
    color: var(--md-sys-color-primary);
    font-weight: 500;
}

/* Hide old pagination - using horizontal scroll now */
.listen-again-pagination {
    display: none;
}

/* Carousel navigation for Listen Again - now horizontal scroll */
.listen-again-carousel {
    display: flex;
    align-items: center;
    position: relative;
    width: 100%;
    overflow: visible;
    padding: 0 8px;
}

.listen-again-carousel-btn {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 1px solid var(--md-sys-color-outline);
    background: var(--md-sys-color-surface-container);
    color: var(--md-sys-color-on-surface);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 16px;
    transition: all 0.2s cubic-bezier(0.16,1,0.3,1);
    flex-shrink: 0;
    z-index: 20;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
}

.listen-again-carousel-btn:hover:not(:disabled) {
    background: var(--md-sys-color-primary-container);
    border-color: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary-container);
    transform: scale(1.08);
    box-shadow: 0 4px 16px rgba(var(--md-sys-color-primary-rgb), 0.25);
}

.listen-again-carousel-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.listen-again-carousel-btn:disabled:hover {
    transform: none;
}

.listen-again-scroll-wrapper {
    flex: 1;
    min-width: 0;
    overflow: visible;
    padding: 0 16px;
}

.listen-again-grid-wrapper {
    order: 2;
    flex: 1;
    position: relative;
    overflow: visible;
    width: 100%;
    max-width: none;
    min-width: 0;
}

.listen-again-page-indicator {
    display: flex;
    gap: 8px;
    justify-content: center;
}

.listen-again-page-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--md-sys-color-outline);
    transition: all 0.3s cubic-bezier(0.16,1,0.3,1);
    cursor: pointer;
}

.listen-again-page-dot.active {
    background: var(--md-sys-color-primary);
    transform: scale(1.3);
    box-shadow: 0 0 8px rgba(var(--md-sys-color-primary-rgb), 0.5);
}

.listen-again-page-dot:hover:not(.active) {
    background: var(--md-sys-color-primary-container);
    transform: scale(1.15);
}

.listen-again-page-btn {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    background: var(--md-sys-color-surface-container);
    border: 1px solid var(--md-sys-color-outline);
    color: var(--md-sys-color-on-surface);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    transition: all 0.2s cubic-bezier(0.16,1,0.3,1);
}

.listen-again-page-btn:hover:not(:disabled) {
    background: var(--md-sys-color-primary-container);
    border-color: var(--md-sys-color-primary);
    color: var(--md-sys-color-on-primary-container);
    transform: scale(1.08);
}

.listen-again-page-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
}

.listen-again-page-btn:disabled:hover {
    transform: none;
}

.listen-again-page-dots {
    color: var(--md-sys-color-on-surface);
    opacity: 0.5;
    font-size: 20px;
}

.listen-again-page-indicator {
    display: flex;
    gap: 8px;
}

.listen-again-page-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--md-sys-color-outline);
    transition: all 0.3s ease;
}

.listen-again-page-dot.active {
    background: var(--md-sys-color-primary);
    transform: scale(1.3);
}

.listen-again-page-dot:hover:not(.active) {
    background: var(--md-sys-color-primary-container);
}

/* Page transition for grid items */
.listen-again-grid-wrapper {
    position: relative;
    overflow: visible;
    width: 100%;
}

.listen-again-grid.listen-again-grid-slide {
    display: flex;
    flex-wrap: nowrap;
    gap: 24px;
    transition: transform 0.2s cubic-bezier(0.16, 1, 0.3, 1), opacity 0.2s ease;
}

.listen-again-grid.listen-again-grid-slide .listen-again-track-card {
    flex-shrink: 0;
    width: 180px;
}

.listen-again-grid.listen-again-grid-slide.enter-forward {
    opacity: 0;
    transform: translateX(30px);
}

.listen-again-grid.listen-again-grid-slide.enter-back {
    opacity: 0;
    transform: translateX(-30px);
}

.listen-again-grid.listen-again-grid-slide.enter-active {
    opacity: 1;
    transform: translateX(0);
}

.listen-again-grid.listen-again-grid-slide.exit-forward {
    opacity: 0;
    transform: translateX(-30px);
}

.listen-again-grid.listen-again-grid-slide.exit-back {
    opacity: 0;
    transform: translateX(30px);
}

.listen-again-grid.listen-again-grid-slide.exit-forward {
    opacity: 0;
    transform: translateX(-30px);
}

/* All Played Tracks Screen */
#all-played-screen {
    display: none;
}

#all-played-screen.active {
    display: block;
}

.all-played-header {
    margin-bottom: 32px;
}

.all-played-title {
    font-size: 36px;
    font-weight: 600;
    margin: 0 0 8px 0;
    color: var(--md-sys-color-on-surface);
}

.all-played-subtitle {
    font-size: 16px;
    color: var(--md-sys-color-on-surface-variant);
    margin: 0;
    opacity: 0.7;
}

.all-played-tracks-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
    gap: 24px;
}

/* All Played Tracks - Horizontal Row Layout */
.all-played-tracks-container {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.all-played-track-row {
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 12px 16px;
    border-radius: 12px;
    cursor: pointer;
    transition: background 0.2s ease;
    background: var(--md-sys-color-surface-variant);
    
    /* Animation: start hidden and slightly shifted */
    opacity: 0;
    transform: translateY(20px);
    transition: all 0.5s var(--motion-standard), background 0.2s ease;
}

.all-played-track-row.loaded {
    opacity: 1;
    transform: translateY(0);
}

.all-played-track-row:hover {
    background: var(--md-sys-color-primary-container);
}

.all-played-track-row .rank {
    width: 32px;
    font-size: 14px;
    font-weight: 600;
    color: var(--md-sys-color-primary);
    text-align: center;
}

.all-played-track-row .art {
    width: 48px;
    height: 48px;
    border-radius: 8px;
    overflow: hidden;
    flex-shrink: 0;
    background: var(--md-sys-color-surface);
}

.all-played-track-row .art img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.all-played-track-row .art img.loaded {
    opacity: 1;
}

.all-played-track-row .info {
    flex: 1;
    min-width: 0;
}

.all-played-track-row .title {
    font-size: 15px;
    font-weight: 500;
    color: var(--md-sys-color-on-surface);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.all-played-track-row .artist {
    font-size: 13px;
    color: var(--md-sys-color-on-surface-variant);
    opacity: 0.7;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.all-played-track-row .plays {
    font-size: 13px;
    font-weight: 500;
    color: var(--md-sys-color-primary);
    white-space: nowrap;
}

.all-played-track-row .actions {
    display: flex;
    gap: 8px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.all-played-track-row:hover .actions {
    opacity: 1;
}

.all-played-track-row .actions .m3-btn {
    padding: 8px 12px;
    font-size: 12px;
}

/* Remove old card-based styles */
.all-played-grid {
    display: none;
}

/* Mobile responsive */
@media (max-width: 768px) {
    .listen-again-container {
        width: 100%;
        max-width: none;
        margin-left: auto;
        margin-right: auto;
        padding: 0 16px;
    }
    
    .listen-again-scroll-container {
        padding: 8px 0 24px 0;
        justify-content: flex-start;
    }
    
    .listen-again-grid {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 16px;
    }
    
    .listen-again-skeleton {
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 16px;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
        padding-left: 0;
        padding-right: 0;
    }
    
    .folder-grid-skeleton {
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
        padding-left: 0;
        padding-right: 0;
    }
    
    .listen-again-title {
        font-size: 26px;
    }
    
    .listen-again-track-card {
        border-radius: 16px;
        width: 140px;
        height: 140px;
    }
    
    .listen-again-track-title {
        font-size: 13px;
    }
    
    .listen-again-track-artist {
        font-size: 11px;
    }
    
    .all-played-track-row {
        padding: 10px 12px;
        gap: 12px;
    }
    
    .all-played-track-row .art {
        width: 40px;
        height: 40px;
    }
    
    .all-played-track-row .title {
        font-size: 14px;
    }
    
    .all-played-track-row .artist {
        font-size: 12px;
    }
}

/* --- SIMPLE SETTINGS MENU --- */

.settings-header {
    margin-bottom: 32px;
}

.settings-title {
    font-size: 48px;
    font-weight: 700;
    margin: 0;
    color: var(--md-sys-color-on-background);
    letter-spacing: -1px;
}

.simple-settings-section {
    background: var(--md-sys-color-surface-variant);
    border-radius: 28px;
    padding: 24px;
    margin-bottom: 20px;
    border: 1px solid var(--md-sys-color-outline);
}

.simple-section-title {
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: var(--md-sys-color-on-surface);
    opacity: 0.6;
    margin: 0 0 16px 0;
}

.simple-setting-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px;
    border-radius: 16px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.simple-setting-row:hover {
    background: rgba(255,255,255,0.05);
}

.simple-setting-info {
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.simple-setting-label {
    font-size: 16px;
    font-weight: 500;
    color: var(--md-sys-color-on-surface);
}

.simple-setting-desc {
    font-size: 13px;
    color: var(--md-sys-color-on-surface);
    opacity: 0.6;
}

.simple-toggle {
    position: relative;
    width: 52px;
    height: 32px;
    cursor: pointer;
}

.simple-toggle-track {
    position: absolute;
    inset: 0;
    background: var(--md-sys-color-outline);
    border-radius: 16px;
    transition: all 0.3s ease;
}

.simple-toggle-thumb {
    position: absolute;
    top: 4px;
    left: 4px;
    width: 24px;
    height: 24px;
    background: white;
    border-radius: 50%;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
}

.simple-toggle input:checked + .simple-toggle-track {
    background: var(--md-sys-color-primary);
}

.simple-toggle input:checked + .simple-toggle-track .simple-toggle-thumb {
    transform: translateX(20px);
}

/* Color grid */
.color-grid {
    display: grid;
    grid-template-columns: repeat(6, 1fr);
    gap: 12px;
}

.color-btn {
    aspect-ratio: 1;
    border-radius: 16px;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.2s ease;
}

.color-btn:hover {
    transform: scale(1.1);
    border-color: white;
}

.pencil-color-btn {
    background: linear-gradient(135deg, #ff0000, #ff7700, #ffdd00, #77ff00, #00ff00, #00ff77, #00ffff, #0077ff, #0000ff);
    background-size: 200% 200%;
    animation: rainbowSpiral 3s ease infinite;
    display: flex;
    align-items: center;
    justify-content: center;
    border: 2px solid rgba(255,255,255,0.3);
}

.pencil-color-btn:hover {
    transform: scale(1.1);
    border-color: white;
    box-shadow: 0 0 20px rgba(255,255,255,0.5);
}

.pencil-color-btn i {
    color: white;
    font-size: 18px;
    text-shadow: 0 1px 3px rgba(0,0,0,0.5);
}

@keyframes rainbowSpiral {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

.hidden-input {
    display: none;
}

/* Danger section */
.danger-section {
    background: transparent;
    border: none;
    padding: 0;
}

.danger-btn {
    width: 100%;
    padding: 18px 24px;
    border-radius: 16px;
    background: #dc2626;
    color: white;
    border: none;
    font-size: 16px;
    font-weight: 500;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    transition: all 0.2s ease;
}

.danger-btn:hover {
    background: #ef4444;
    transform: translateY(-2px);
    box-shadow: 0 4px 20px rgba(220, 38, 38, 0.4);
}

.danger-btn i {
    font-size: 18px;
}

/* Hard Reset Button - More extreme styling */
.hard-reset-btn {
    margin-top: 12px;
    background: linear-gradient(135deg, #7f1d1d 0%, #dc2626 50%, #991b1b 100%);
    border: 2px solid #ef4444;
    animation: pulse-red 2s infinite;
}

.hard-reset-btn:hover {
    background: linear-gradient(135deg, #991b1b 0%, #ef4444 50%, #dc2626 100%);
    transform: translateY(-2px) scale(1.02);
    box-shadow: 0 8px 30px rgba(220, 38, 38, 0.6);
    animation: none;
}

@keyframes pulse-red {
    0%, 100% {
        box-shadow: 0 0 0 0 rgba(220, 38, 38, 0.5);
    }
    50% {
        box-shadow: 0 0 0 8px rgba(220, 38, 38, 0);
    }
}

/* Light mode */
[data-theme="light"] .simple-settings-section {
    background: white;
    box-shadow: 0 2px 8px rgba(0,0,0,0.06);
}

[data-theme="light"] .simple-setting-row:hover {
    background: rgba(0,0,0,0.03);
}

/* Mobile responsive */
@media (max-width: 768px) {
    .settings-title {
        font-size: 36px;
    }
    
    .simple-settings-section {
        padding: 20px;
        border-radius: 24px;
    }
    
    .color-grid {
        grid-template-columns: repeat(4, 1fr);
    }
}

/* --- ALBUM MODAL STYLES --- */

/* Modal overlay */
.album-modal-overlay {
    position: fixed;
    inset: 0;
    background: rgba(0, 0, 0, 0.6);
    z-index: 2000;
    display: none;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(8px);
    transition: opacity 0.3s cubic-bezier(0.2, 0, 0, 1);
}

.album-modal-overlay.visible {
    display: flex;
    opacity: 1;
}

/* Modal container - Material 3 Expressive */
.album-modal {
    background: var(--md-sys-color-surface-variant);
    width: 90%;
    max-width: 480px;
    max-height: 80vh;
    border-radius: 28px;
    display: flex;
    flex-direction: column;
    border: 1px solid var(--md-sys-color-outline);
    box-shadow: 0 24px 48px rgba(0, 0, 0, 0.4);
    transform: scale(0.92) translateY(20px);
    transition: transform 0.3s cubic-bezier(0.2, 0, 0, 1);
    overflow: hidden;
}

.album-modal-overlay.visible .album-modal {
    transform: scale(1) translateY(0);
}

/* Modal header */
.album-modal-header {
    padding: 20px 24px 16px 24px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    border-bottom: 1px solid var(--md-sys-color-outline);
}

.album-modal-title {
    font-size: 20px;
    font-weight: 600;
    color: var(--md-sys-color-on-surface);
    margin: 0;
    line-height: 1.2;
}

.album-modal-subtitle {
    font-size: 14px;
    font-weight: 500;
    color: var(--md-sys-color-on-surface);
    opacity: 0.7;
    padding: 0 24px;
    margin-bottom: 12px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}

.album-modal-close {
    width: 40px;
    height: 40px;
    border-radius: 16px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: transparent;
    border: none;
    color: var(--md-sys-color-on-surface);
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.2, 0, 0, 1);
    opacity: 0.7;
}

.album-modal-close:hover {
    background: var(--md-sys-color-primary-container);
    opacity: 1;
}

.album-modal-close:active {
    transform: scale(0.9);
}

/* Modal content area */
.album-modal-content {
    flex: 1;
    overflow-y: auto;
    padding: 12px 16px;
}

/* Individual track item in album modal */
.album-modal-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 10px 12px;
    border-radius: 16px;
    cursor: pointer;
    transition: all 0.2s cubic-bezier(0.2, 0, 0, 1);
    position: relative;
    margin-bottom: 4px;
}

.album-modal-item:hover {
    background: var(--md-sys-color-surface-variant);
    transform: translateX(4px);
}

.album-modal-item.selected {
    background: var(--md-sys-color-primary-container);
}

.album-modal-item-art {
    width: 56px;
    height: 56px;
    border-radius: 12px;
    overflow: hidden;
    flex-shrink: 0;
    background: var(--md-sys-color-surface);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    display: flex;
    align-items: center;
    justify-content: center;
}

.album-modal-item-art img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.3s ease;
}

.album-modal-item-art img.loaded {
    opacity: 1;
}

.album-modal-item-art .no-art {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--md-sys-color-on-surface);
    opacity: 0.4;
    font-size: 22px;
    background: var(--md-sys-color-surface-variant);
}

.album-modal-item-info {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    gap: 2px;
}

.album-modal-item-title {
    font-size: 15px;
    font-weight: 500;
    color: var(--md-sys-color-on-surface);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.album-modal-item-artist {
    font-size: 13px;
    color: var(--md-sys-color-on-surface);
    opacity: 0.7;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* Custom checkbox styling */
.album-modal-checkbox {
    width: 24px;
    height: 24px;
    border-radius: 8px;
    border: 2px solid var(--md-sys-color-outline);
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    transition: all 0.2s cubic-bezier(0.2, 0, 0, 1);
}

.album-modal-item.selected .album-modal-checkbox {
    background: var(--md-sys-color-primary);
    border-color: var(--md-sys-color-primary);
}

.album-modal-checkbox i {
    color: white;
    font-size: 12px;
    opacity: 0;
    transform: scale(0.8);
    transition: all 0.2s cubic-bezier(0.2, 0, 0, 1);
}

.album-modal-item.selected .album-modal-checkbox i {
    opacity: 1;
    transform: scale(1);
}

/* Modal footer */
.album-modal-footer {
    padding: 16px 24px 24px 24px;
    display: flex;
    justify-content: flex-end;
    gap: 12px;
}

/* Light mode album modal */
[data-theme="light"] .album-modal {
    background: var(--md-sys-color-surface);
    box-shadow: 0 24px 48px rgba(0, 0, 0, 0.15);
}

[data-theme="light"] .album-modal-item:hover {
    background: rgba(0, 0, 0, 0.04);
}

[data-theme="light"] .album-modal-item.selected {
    background: var(--md-sys-color-primary-container);
}

[data-theme="light"] .album-modal-close:hover {
    background: rgba(0, 0, 0, 0.08);
}

#loadControls { display: flex; gap: 12px; align-items: center; margin-top: 8px; }
#logOverlay { position: fixed; inset: 0; background: rgba(0,0,0,0.8); display: none; align-items: center; justify-content: center; z-index: 2000; backdrop-filter: blur(10px); }
#logModal {
    background: var(--md-sys-color-surface-variant); width: 90%; max-width: 900px; height: 80%; border-radius: 24px; padding: 32px;
    overflow: hidden; display: flex; flex-direction: column; border: 1px solid var(--md-sys-color-outline);
}
#logHeader { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
#logContent { flex: 1; overflow-y: auto; background: #111; border-radius: 12px; padding: 16px; font-family: 'Roboto Mono', monospace; font-size: 13px; white-space: pre-wrap; color: #ccc; line-height: 1.5; }
.theme-toggle-container {
    display: flex; align-items: center; justify-content: space-between; background: var(--md-sys-color-surface-variant);
    padding: 16px 20px; border-radius: 16px; margin-top: 24px; border: 1px solid var(--md-sys-color-outline);
}
.theme-toggle-label { font-size: 15px; font-weight: 500; }
.theme-switch { position: relative; display: inline-block; width: 54px; height: 28px; }
.theme-switch input { opacity: 0; width: 0; height: 0; }
.slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #555; transition: .4s; border-radius: 28px; }
.slider:before { position: absolute; content: ""; height: 24px; width: 24px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; }
input:checked + .slider { background-color: var(--md-sys-color-primary); }
input:checked + .slider:before { transform: translateX(26px); }

/* --- EQUALIZER STYLES --- */

/* Page Header */
.eq-page-header {
    margin-bottom: 32px;
}

.eq-page-title {
    font-size: 52px;
    font-weight: 700;
    margin: 0 0 8px 0;
    letter-spacing: -1px;
    background: linear-gradient(135deg, var(--md-sys-color-on-background), var(--md-sys-color-primary));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.eq-page-subtitle {
    font-size: 16px;
    opacity: 0.7;
    margin: 0;
}

/* Main Container */
.eq-container {
    max-width: 900px;
    margin: 0 auto;
    background: var(--md-sys-color-surface-variant);
    border-radius: 32px;
    padding: 32px;
    border: 1px solid var(--md-sys-color-outline);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
}

/* Header Section */
.eq-header {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    margin-bottom: 32px;
    padding-bottom: 24px;
    border-bottom: 1px solid var(--md-sys-color-outline);
    flex-wrap: wrap;
    gap: 16px;
}

.eq-header-info {
    display: flex;
    flex-direction: column;
    gap: 4px;
}

.eq-section-label {
    font-size: 12px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    opacity: 0.6;
}

.eq-header-title {
    font-size: 24px;
    font-weight: 600;
    margin: 0;
}

/* Presets */
.eq-presets {
    display: flex;
    gap: 12px;
    align-items: center;
}

.eq-preset-dropdown {
    position: relative;
}

.eq-preset-dropdown select {
    appearance: none;
    background: var(--md-sys-color-surface);
    color: var(--md-sys-color-on-surface);
    border: 1px solid var(--md-sys-color-outline);
    padding: 12px 40px 12px 16px;
    border-radius: 16px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    min-width: 140px;
    transition: all 0.3s var(--motion-standard);
}

.eq-preset-dropdown select:hover {
    border-color: var(--md-sys-color-primary);
    background: var(--md-sys-color-primary-container);
}

.eq-preset-dropdown i {
    position: absolute;
    right: 14px;
    top: 50%;
    transform: translateY(-50%);
    pointer-events: none;
    opacity: 0.6;
    font-size: 12px;
}

.eq-presets .m3-btn {
    padding: 12px 16px;
    border-radius: 16px;
}

/* Sections */
.eq-section {
    margin-bottom: 28px;
    padding: 24px;
    background: rgba(0, 0, 0, 0.15);
    border-radius: 24px;
    border: 1px solid rgba(255, 255, 255, 0.05);
}

.eq-section-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 20px;
}

.eq-section-header i {
    font-size: 18px;
    color: var(--md-sys-color-primary);
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--md-sys-color-primary-container);
    border-radius: 12px;
}

.eq-section-header h3 {
    font-size: 18px;
    font-weight: 600;
    margin: 0;
}

/* Tone Sliders */
.tone-slider-row {
    display: flex;
    align-items: center;
    gap: 16px;
    margin-bottom: 16px;
}

.tone-slider-row:last-child {
    margin-bottom: 0;
}

.tone-label {
    width: 100px;
    display: flex;
    align-items: center;
    gap: 10px;
    font-weight: 600;
    font-size: 14px;
}

.tone-label i {
    font-size: 14px;
    opacity: 0.7;
}

.tone-range {
    -webkit-appearance: none;
    appearance: none;
    flex: 1;
    height: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    cursor: pointer;
}

.tone-range::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 24px;
    height: 24px;
    background: var(--md-sys-color-primary);
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3), 0 0 12px color-mix(in srgb, var(--md-sys-color-primary) 40%, transparent);
    cursor: pointer;
    transition: transform 0.2s var(--motion-standard), box-shadow 0.2s var(--motion-standard);
}

.tone-range::-webkit-slider-thumb:hover {
    transform: scale(1.15);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4), 0 0 20px color-mix(in srgb, var(--md-sys-color-primary) 50%, transparent);
}

.tone-range::-webkit-slider-runnable-track {
    height: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
}

.tone-range::-moz-range-thumb {
    width: 24px;
    height: 24px;
    background: var(--md-sys-color-primary);
    border-radius: 50%;
    border: 3px solid white;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3), 0 0 12px color-mix(in srgb, var(--md-sys-color-primary) 40%, transparent);
    cursor: pointer;
}

.tone-range::-moz-range-track {
    height: 8px;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
}

.tone-value {
    width: 55px;
    text-align: right;
    font-size: 14px;
    font-weight: 600;
    opacity: 0.9;
    font-variant-numeric: tabular-nums;
    padding: 6px 12px;
    background: var(--md-sys-color-primary-container);
    border-radius: 12px;
    color: var(--md-sys-color-primary);
}

/* Graphic EQ Section */
.eq-graphic-section {
    background: linear-gradient(135deg, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.1));
}

.eq-visualizer-container {
    padding: 16px 8px;
    overflow-x: auto;
}

.eq-sliders-grid {
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    height: 220px;
    min-width: 600px;
    padding: 0 16px;
}

.eq-slider-col {
    display: flex;
    flex-direction: column;
    align-items: center;
    height: 100%;
    flex: 1;
    max-width: 60px;
}

.eq-slider-track {
    flex: 1;
    width: 12px;
    background: rgba(255, 255, 255, 0.08);
    border-radius: 12px;
    position: relative;
    display: flex;
    justify-content: center;
    box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.05);
}

/* Vertical range input trick */
.eq-range {
    -webkit-appearance: none;
    appearance: none;
    width: 200px;
    height: 28px;
    background: transparent;
    transform: rotate(-90deg);
    transform-origin: center;
    position: absolute;
    top: 86px;
    cursor: pointer;
}

.eq-range::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 24px;
    height: 24px;
    background: linear-gradient(145deg, var(--md-sys-color-primary), color-mix(in srgb, var(--md-sys-color-primary) 70%, #000));
    border-radius: 50%;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4), 0 0 16px color-mix(in srgb, var(--md-sys-color-primary) 50%, transparent);
    border: 3px solid white;
    margin-top: -9px;
    transition: transform 0.15s ease, box-shadow 0.15s ease;
}

.eq-range::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.5), 0 0 24px color-mix(in srgb, var(--md-sys-color-primary) 70%, transparent);
}

.eq-range::-webkit-slider-thumb:active {
    transform: scale(1.1);
}

.eq-range::-moz-range-thumb {
    width: 24px;
    height: 24px;
    background: linear-gradient(145deg, var(--md-sys-color-primary), color-mix(in srgb, var(--md-sys-color-primary) 70%, #000));
    border-radius: 50%;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4), 0 0 16px color-mix(in srgb, var(--md-sys-color-primary) 50%, transparent);
    border: 3px solid white;
    cursor: pointer;
}

.eq-range::-webkit-slider-runnable-track {
    width: 100%;
    height: 8px;
    background: linear-gradient(90deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
    border-radius: 8px;
}

.eq-range::-moz-range-track {
    width: 100%;
    height: 8px;
    background: linear-gradient(90deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.08));
    border-radius: 8px;
}

.eq-freq-label {
    margin-top: 12px;
    font-size: 11px;
    opacity: 0.7;
    font-weight: 500;
    white-space: nowrap;
    text-align: center;
}

/* Quick Preset Chips */
.eq-quick-presets {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    padding-top: 20px;
    border-top: 1px solid var(--md-sys-color-outline);
}

.eq-preset-chip {
    padding: 10px 20px;
    border-radius: 100px !important;
    font-size: 13px !important;
    font-weight: 500 !important;
    transition: all 0.3s var(--motion-standard);
}

.eq-preset-chip:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

/* Light mode adjustments */
[data-theme="light"] .eq-container {
    background: var(--md-sys-color-surface);
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
}

[data-theme="light"] .eq-section {
    background: rgba(0, 0, 0, 0.04);
    border-color: rgba(0, 0, 0, 0.08);
}

[data-theme="light"] .tone-range {
    background: rgba(0, 0, 0, 0.1);
}

[data-theme="light"] .tone-range::-webkit-slider-runnable-track {
    background: rgba(0, 0, 0, 0.1);
}

[data-theme="light"] .tone-range::-moz-range-track {
    background: rgba(0, 0, 0, 0.1);
}

[data-theme="light"] .eq-visualizer-container {
    background: rgba(0, 0, 0, 0.02);
    border-radius: 16px;
}

[data-theme="light"] .eq-slider-track {
    background: rgba(0, 0, 0, 0.08);
}

[data-theme="light"] .eq-quick-presets {
    border-top-color: rgba(0, 0, 0, 0.1);
}

/* Mobile responsive */
@media (max-width: 768px) {
    .eq-page-title {
        font-size: 40px;
    }
    
    .eq-container {
        padding: 24px;
        border-radius: 24px;
    }
    
    .eq-header {
        flex-direction: column;
        align-items: stretch;
    }
    
    .eq-presets {
        justify-content: flex-start;
    }
    
    .eq-section {
        padding: 20px;
        border-radius: 20px;
    }
    
    .tone-label {
        width: 70px;
        font-size: 13px;
    }
    
    .tone-slider-row {
        gap: 12px;
    }
    
    .eq-sliders-grid {
        min-width: 100%;
        padding: 0 8px;
    }
    
    .eq-slider-col {
        max-width: 30px;
    }
    
    .eq-slider-track {
        width: 8px;
    }
}

.mobile-player-overlay {
    position: fixed; inset: 0; background: var(--md-sys-color-background);
    z-index: 2500; display: flex; flex-direction: column; padding: 24px 32px;
    transform: translateY(100%); transition: transform 0.4s cubic-bezier(0.2, 0, 0, 1);
}
.mobile-player-overlay.active { transform: translateY(0); }
.mp-header { display: flex; align-items: center; justify-content: space-between; margin-bottom: 32px; margin-top: env(safe-area-inset-top); }
.mp-art-container {
    width: 100%; aspect-ratio: 1/1; border-radius: 24px; background: var(--md-sys-color-surface-variant);
    overflow: hidden; margin-bottom: 40px; box-shadow: 0 12px 48px rgba(0,0,0,0.6); align-self: center; max-width: 400px;
    display: flex; align-items: center; justify-content: center;
}
#fsArt i { font-size: 80px; opacity: 0.3; }
.mp-info-container { margin-bottom: 32px; display: flex; flex-direction: column; gap: 4px; }
.mp-progress-container { display: flex; align-items: center; gap: 16px; margin-bottom: 32px; }
.mp-controls-container { display: flex; align-items: center; justify-content: space-between; padding: 0 16px; margin-top: auto; margin-bottom: 40px; }
.mp-btn { font-size: 24px; color: var(--md-sys-color-on-background); background: none; border: none; cursor: pointer; transition: all 0.2s; }
.mp-btn:active { transform: scale(0.9); }
.mp-play-btn {
    width: 72px; height: 72px; background: var(--md-sys-color-primary); border-radius: 50%;
    color: white; display: flex; align-items: center; justify-content: center; font-size: 28px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
}

.mobile-nav { display: none; position: fixed; bottom: 0; left: 0; right: 0; height: 64px; background: var(--md-sys-color-surface); border-top: 1px solid var(--md-sys-color-outline); z-index: 1000; justify-content: space-around; align-items: center; padding-bottom: env(safe-area-inset-bottom); }
.mobile-nav-item { display: flex; flex-direction: column; align-items: center; justify-content: center; flex: 1; height: 100%; color: var(--md-sys-color-on-surface); opacity: 0.6; transition: all 0.3s ease; }
.mobile-nav-item.active { opacity: 1; color: var(--md-sys-color-primary); }
.mobile-nav-item i { font-size: 20px; margin-bottom: 4px; }
.mobile-nav-item span { font-size: 10px; font-weight: 500; }

@media (max-width: 768px) {
    :root { --nav-height: 64px; }
    .nav-rail { display: none; }
    .mobile-nav { display: flex; }
    .main-container { padding: 20px 16px; padding-bottom: 140px; }
    .folder-grid { 
        grid-template-columns: repeat(2, 1fr); 
        gap: 12px;
        width: 100%;
        margin-left: auto;
        margin-right: auto;
        padding-left: 0;
        padding-right: 0;
    }
    .playlist-card:hover .play-overlay { opacity: 1; pointer-events: auto; }
    
    .side-sheet { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; z-index: 3000; transform: translateY(100%); border-left: none; }
    .side-sheet.collapsed { transform: translateY(100%); width: 100%; }
    .side-sheet:not(.collapsed) { transform: translateY(0); }

    .player-bar {
        bottom: var(--nav-height); left: 0; right: 0; height: 68px; padding: 0 12px; position: fixed;
        border-top: 1px solid var(--md-sys-color-outline); background: var(--md-sys-color-surface-variant);
        align-items: center; z-index: 1000;
    }
    
    .player-bar > div:first-child { flex: 1; min-width: 0; gap: 12px; }
    #npArt { width: 48px; height: 48px; box-shadow: none; border-radius: 8px; }
    #npTitle { font-size: 14px; transition: opacity 0.3s ease; }
    #npArtist { font-size: 12px; transition: opacity 0.3s ease; }
    
    /* Fullscreen player transitions */
    #fsTitle, #fsArtist, #deTitle, #deArtist { transition: opacity 0.3s ease; }
    #npAlbum { display: none; }

    .player-bar > div:nth-child(2) { flex: 0 0 auto; width: auto; flex-direction: row; gap: 0; position: static; }
    .player-bar > div:nth-child(2) > div:first-child { gap: 12px; flex-direction: row; }
    
    #btnShuffle, #btnRepeat, #curTime, #durTime, .fa-backward-step { display: none; }
    
    .play-btn { width: 42px; height: 42px; font-size: 18px; background: transparent; color: var(--md-sys-color-on-surface); border: 1px solid var(--md-sys-color-outline); }
    .fa-forward-step { font-size: 20px; padding: 8px; }

    .player-bar > div:nth-child(2) > div:last-child {
        position: absolute; top: -4px; left: 0; right: 0; width: 100%; max-width: none !important;
        height: 4px; background: transparent; margin: 0;
    }
    .player-bar > div:nth-child(2) > div:last-child > div:nth-child(2) {
        border-radius: 0; background: rgba(255,255,255,0.1);
    }
    #progFill { border-radius: 0; box-shadow: none; }
    #progScrub { top: -10px; height: 20px; }

    .player-bar > div:last-child { display: none !important; }

    h1 { font-size: 32px !important; }
    .playlist-header { flex-direction: column; align-items: flex-start; gap: 16px; }
    .playlist-cover { width: 160px; height: 160px; align-self: center; }
    .playlist-info { width: 100%; min-width: 0; text-align: center; }
    .playlist-controls, .playlist-management { justify-content: center; }
    #playlistBreadcrumb { justify-content: center; }
    
    /* Hide extended view button on mobile */
    #playerBarExtendedBtn { display: none !important; }
    
    /* Adjust EQ for mobile */
    .eq-dials-area { gap: 20px; }
    .eq-slider-col { width: 20px; }
    .eq-range { width: 160px; top: 70px; }
    .eq-sliders-grid { gap: 4px; }
    
    /* Mobile playlist table adjustments */
    .song-row td.meta-album { display: none; }
    .song-row td:first-child { width: 48px; }
    .playlist-drag-handle { padding: 8px 12px !important; }
    .song-row { cursor: pointer; }
}

/* === DESKTOP EXPANDED VIEW === */
.desktop-extended {
	position: fixed;
	inset: 0;
	z-index: 1600;
	overflow-y: auto;
	overflow-x: hidden;
	transition: transform 0.3s cubic-bezier(0.2, 0, 0, 1);
	background: var(--md-sys-color-primary-dark);
	will-change: transform;
}

.desktop-extended.collapsed {
	transform: translateY(100%);
}

/* Art container at top */
.desktop-extended-art {
	position: relative;
	width: 100%;
	display: flex;
	justify-content: center;
	padding: 40px 0 16px 0;
	min-height: auto;
}

/* Blurred background layer */
.desktop-extended-art-bg {
	position: absolute;
	inset: 0;
	background-size: cover;
	background-position: center center;
	filter: blur(12px);
	transform: scale(1.1);
	opacity: 0;
	transition: opacity 0.2s ease;
	z-index: 0;
	will-change: opacity;
}

/* Gradient overlay to fade into darker accent color at bottom */
.desktop-extended-art-bg::after {
	content: '';
	position: absolute;
	inset: 0;
	background: linear-gradient(to bottom, transparent 0%, var(--md-sys-color-primary-dark) 100%);
	pointer-events: none;
}

.desktop-extended-art-bg.visible {
	opacity: 1;
}



/* Main album art */
.desktop-extended-art-img {
	position: relative;
	width: 100%;
	max-width: 500px;
	aspect-ratio: 1;
	object-fit: cover;
	border-radius: 16px;
	box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
	z-index: 1;
	opacity: 0;
	transition: opacity 0.2s ease;
	will-change: opacity;
}

.desktop-extended-art-img.visible {
	opacity: 1;
}

/* Player controls area */
.clean-player {
	position: relative;
	z-index: 2;
	padding: 0 24px 40px 24px;
	text-align: center;
	display: flex;
	flex-direction: column;
	align-items: center;
	gap: 0;
}

.clean-controls-panel {
	background: color-mix(in srgb, var(--md-sys-color-primary) 60%, black);
	border-radius: 24px;
	padding: 32px 24px 24px 24px;
	width: 100%;
	max-width: 500px;
	box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
}

.clean-info-panel {
	text-align: center;
	width: 100%;
	max-width: 500px;
}

.clean-title {
	font-size: 28px;
	font-weight: 700;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
	margin: 0;
	line-height: 1.3;
}

.clean-artist {
	opacity: 0.7;
	font-size: 18px;
	margin: 8px 0 0 0;
}

.clean-progress {
	width: 100%;
	max-width: 500px;
	margin: 24px auto 0 auto;
	display: flex;
	align-items: center;
	gap: 12px;
}

.clean-time {
	font-size: 12px;
	opacity: 0.9;
	min-width: 40px;
	text-align: center;
	font-variant-numeric: tabular-nums;
	text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
}

.clean-bar-bg {
	flex: 1;
	height: 6px;
	background: rgba(0, 0, 0, 0.4);
	border-radius: 3px;
	position: relative;
	cursor: pointer;
	overflow: hidden;
}

.clean-bar-fill {
	height: 100%;
	background: linear-gradient(90deg, var(--md-sys-color-primary), color-mix(in srgb, var(--md-sys-color-primary) 70%, white));
	box-shadow: 0 0 12px var(--md-sys-color-primary);
	border-radius: 3px;
	width: 0%;
	position: absolute;
	top: 0;
	left: 0;
	transition: width 0.18s linear;
}

.clean-scrub {
	position: absolute;
	top: -14px;
	left: 0;
	width: 100%;
	height: 34px;
	opacity: 0;
	cursor: pointer;
}

.clean-controls {
	margin-top: 20px;
	display: flex;
	justify-content: center;
	align-items: center;
	gap: 24px;
}

.clean-btn {
	background: none;
	border: none;
	color: var(--desktop-extended-text, white);
	cursor: pointer;
	transition: all 0.3s ease;
	padding: 10px;
	border-radius: 50%;
}

.clean-btn:hover {
	opacity: 1;
	transform: scale(1.15);
}

.clean-btn:active {
	transform: scale(0.95);
}

.clean-btn.play-btn-large {
	width: 64px;
	height: 64px;
	background: var(--md-sys-color-primary);
	font-size: 28px;
	box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
}

.clean-btn.play-btn-large:hover {
	background: color-mix(in srgb, var(--md-sys-color-primary) 90%, white);
}

.clean-btn#deShuffleBtn,
.clean-btn#deRepeatBtn {
	font-size: 18px;
	opacity: 0.6;
}

.clean-btn#deShuffleBtn.active,
.clean-btn#deRepeatBtn.active {
	opacity: 1;
	color: var(--md-sys-color-primary);
}

.clean-btn#deShuffleBtn:hover,
.clean-btn#deRepeatBtn:hover {
	opacity: 0.9;
}

.clean-btn.on-play-btn-large {
	animation: none;
}

/* Skip buttons in expanded view */
.clean-controls .fa-backward-step,
.clean-controls .fa-forward-step {
	font-size: 22px;
}

.clean-controls .fa-backward-step:hover,
.clean-controls .fa-forward-step:hover {
	transform: scale(1.15);
}

.clean-volume {
	display: flex;
	align-items: center;
	justify-content: center;
	gap: 12px;
	margin-top: 20px;
	color: var(--desktop-extended-text, white);
}

.clean-queue {
	position: relative;
	z-index: 2;
	width: 100%;
	max-width: 600px;
	margin: 0 auto;
	padding: 24px 24px 100px 24px;
}

.clean-queue h3 {
	opacity: 0.8;
	letter-spacing: 1.5px;
	font-size: 11px;
	margin: 0 0 16px 0;
	text-transform: uppercase;
	font-weight: 700;
	color: white;
}

.clean-queue-item {
	padding: 12px 16px;
	border-radius: 8px;
	display: flex;
	justify-content: space-between;
	align-items: center;
	cursor: pointer;
	transition: all 0.2s ease;
	margin-bottom: 4px;
	background: rgba(255, 255, 255, 0.1);
	backdrop-filter: blur(10px);
}

.clean-queue-item:hover {
	background: rgba(255, 255, 255, 0.2);
	transform: translateX(4px) scale(1.01);
}

.clean-queue-item.active {
	background: rgba(255, 255, 255, 0.25);
	border-left: 3px solid white;
}

/* Desktop Extended View Queue - using same structure as sidebar */
.clean-queue .queue-item {
	padding: 12px 16px;
	border-radius: 8px;
	margin-bottom: 4px;
	background: rgba(255, 255, 255, 0.1);
	backdrop-filter: blur(10px);
}

.clean-queue .queue-item:hover {
	background: rgba(255, 255, 255, 0.2);
	transform: translateX(6px);
}

.clean-queue .queue-item.active {
	background: rgba(255, 255, 255, 0.25);
	border-left: 4px solid white;
}

.clean-queue .queue-item .queue-drag-handle {
	opacity: 0.6;
	color: white;
}

.clean-queue .queue-item .queue-drag-handle:hover {
	opacity: 1;
}

.clean-queue .queue-item .q-artist {
	opacity: 0.8 !important;
}

.clean-queue .queue-item .queue-ellipsis {
	color: white !important;
	opacity: 0.6 !important;
}

/* Queue ellipsis button */
.queue-ellipsis {
	cursor: pointer;
	padding: 6px 10px;
	border-radius: 4px;
	transition: all 0.2s ease;
	color: white;
	background: transparent;
	border: none;
	font-size: 16px;
	opacity: 0.6;
	z-index: 20;
}

.queue-ellipsis:hover {
	opacity: 1 !important;
	background: rgba(255, 255, 255, 0.2);
	transform: scale(1.1);
}
	transform: scale(1.1);
}

.clean-queue .queue-ellipsis {
	color: white;
	opacity: 0.7 !important;
}

/* Light mode ellipsis */
[data-theme="light"] .queue-ellipsis {
    color: rgba(0, 0, 0, 0.5);
}
[data-theme="light"] .queue-ellipsis:hover {
	background: rgba(0, 0, 0, 0.1);
}
[data-theme="light"] .queue-ellipsis:hover i {
    color: black;
}

/* Light Mode Fixes */
[data-theme="light"] .folder-card {
	background: var(--md-sys-color-surface);
}
[data-theme="light"] .folder-card:hover {
	box-shadow: 0 16px 32px rgba(0,0,0,0.15);
}
[data-theme="light"] .folder-info {
	background: linear-gradient(to top, rgba(0,0,0,0.6) 0%, transparent 60%);
}
[data-theme="light"] .folder-info span {
	color: white;
	text-shadow: 0 1px 4px rgba(0,0,0,0.8);
}
[data-theme="light"] .playlist-card:hover .play-overlay {
	background: linear-gradient(to top, rgba(0,0,0,0.5) 0%, transparent 60%);
}
[data-theme="light"] .play-overlay .control-btn {
	box-shadow: 0 4px 16px rgba(0,0,0,0.3);
}
[data-theme="light"] .play-overlay .btn-label {
	text-shadow: 0 1px 4px rgba(0,0,0,0.8);
}
[data-theme="light"] .playlist-cover {
	box-shadow: 0 8px 32px rgba(0,0,0,0.2);
}
[data-theme="light"] .play-btn {
	color: white;
}
[data-theme="light"] .action-btn {
	color: white;
}
[data-theme="light"] .search-wrapper {
	width: 100%;
	max-width: 100%;
	margin: 0 auto 16px 0;
}
[data-theme="light"] .search-input {
	background: #f5f5f5;
	color: #1f1f1f;
}
[data-theme="light"] .search-input:hover {
	background: #eeeeee;
}
[data-theme="light"] .search-input:focus {
	background: #eeeeee;
	box-shadow: 0 0 0 2px var(--md-sys-color-primary);
}
[data-theme="light"] .search-input-icon {
	color: #757575;
}
[data-theme="light"] .search-results {
	background: white;
	box-shadow: 0 8px 32px rgba(0,0,0,0.12);
	border-color: rgba(0,0,0,0.12);
}
[data-theme="light"] .search-result-item:hover {
	background: rgba(0,0,0,0.04);
}
[data-theme="light"] .search-result-item.active {
	background: var(--md-sys-color-primary-container);
}
[data-theme="light"] .search-result-item-art {
	background: #e0e0e0;
	box-shadow: 0 2px 6px rgba(0,0,0,0.1);
}
[data-theme="light"] .search-result-item-art i {
	color: #9e9e9e;
}
[data-theme="light"] .search-result-item-title {
	color: #1f1f1f;
}
[data-theme="light"] .search-result-item-artist {
	color: #616161;
}
[data-theme="light"] .search-results-header {
	color: #757575;
	border-color: rgba(0,0,0,0.12);
}
[data-theme="light"] .search-no-results {
	color: #757575;
}
[data-theme="light"] .search-result-add-btn {
	background: var(--md-sys-color-primary-container);
	color: var(--md-sys-color-primary);
}
[data-theme="light"] .search-result-add-btn:hover {
	background: var(--md-sys-color-primary);
	color: white;
}
[data-theme="light"] .search-result-add-btn:active {
	transform: scale(0.95);
}
[data-theme="light"] .progress-container {
	background: rgba(0,0,0,0.1);
}
[data-theme="light"] .progress-container .progress-bar {
	box-shadow: 0 0 8px var(--md-sys-color-primary);
}
[data-theme="light"] #buffFill {
	background: rgba(0,0,0,0.2);
}
[data-theme="light"] #progFill {
	background: linear-gradient(90deg, var(--md-sys-color-primary), color-mix(in srgb, var(--md-sys-color-primary) 60%, black));
	box-shadow: 0 0 8px var(--md-sys-color-primary);
}
[data-theme="light"] .clean-bar-bg {
	background: rgba(255, 255, 255, 0.4);
}
[data-theme="light"] .clean-queue-item:hover {
	background: rgba(0, 0, 0, 0.1);
}
[data-theme="light"] .clean-close-fab {
	background: rgba(0,0,0,0.2);
	color: white;
}
[data-theme="light"] .clean-close-fab:hover {
	background: rgba(0,0,0,0.3);
}
[data-theme="light"] #logContent {
	background: #f5f5f5;
	color: #333;
}
[data-theme="light"] .mp-art-container {
	box-shadow: 0 12px 48px rgba(0,0,0,0.2);
}
[data-theme="light"] .mp-play-btn {
	color: white;
	box-shadow: 0 8px 24px rgba(0,0,0,0.3);
}
[data-theme="light"] .eq-range::-webkit-slider-runnable-track {
	background: linear-gradient(90deg, rgba(0,0,0,0.15), rgba(0,0,0,0.08));
}
[data-theme="light"] .eq-range::-moz-range-track {
	background: linear-gradient(90deg, rgba(0,0,0,0.15), rgba(0,0,0,0.08));
}
[data-theme="light"] .tone-range {
	background: rgba(0,0,0,0.12);
}
[data-theme="light"] #playerBarProgressBg {
	--progress-bg: rgba(0,0,0,0.15);
}
[data-theme="light"] #buffFill {
	background: rgba(0,0,0,0.25);
}
[data-theme="light"] #fsProgressBg {
	--progress-bg: rgba(0,0,0,0.15);
}
[data-theme="light"] #fsBuffFill {
	background: rgba(0,0,0,0.25);
}
[data-theme="light"] .clean-bar-bg {
	--progress-bg: rgba(255,255,255,0.4);
}
[data-theme="light"] .eq-range::-webkit-slider-thumb {
	border-color: var(--md-sys-color-surface);
}
[data-theme="light"] .eq-range::-moz-range-thumb {
	border-color: var(--md-sys-color-surface);
}
[data-theme="light"] #logOverlay,
[data-theme="light"] #modalOverlay,
[data-theme="light"] #albumModalOverlay {
	background: rgba(0,0,0,0.4);
}
[data-theme="light"] .album-modal {
    background: white;
    box-shadow: 0 24px 48px rgba(0,0,0,0.15);
}
[data-theme="light"] .album-modal .m3-btn-text {
    color: var(--md-sys-color-primary);
}
[data-theme="light"] .album-modal .m3-btn-text:hover {
    background: var(--md-sys-color-primary-container);
}
[data-theme="light"] .album-modal-item:hover {
    background: rgba(0,0,0,0.04);
}
[data-theme="light"] .album-modal-item.selected {
    background: var(--md-sys-color-primary-container);
}
[data-theme="light"] .album-modal-close:hover {
    background: rgba(0,0,0,0.08);
}
[data-theme="light"] .song-row td {
	color: var(--md-sys-color-on-surface);
}
[data-theme="light"] .queue-item {
	color: var(--md-sys-color-on-surface);
	border-bottom: 1px solid rgba(0, 0, 0, 0.08);
}
[data-theme="light"] .queue-item:hover {
	background: rgba(0,0,0,0.04);
}
[data-theme="light"] .queue-item.active {
	background: var(--md-sys-color-primary-container);
	border-left-color: var(--md-sys-color-primary);
}
[data-theme="light"] .queue-drag-handle {
	color: rgba(0, 0, 0, 0.4);
}
[data-theme="light"] .queue-drag-handle:hover {
	color: rgba(0, 0, 0, 0.7);
}
[data-theme="light"] .clean-queue-item {
	color: white;
}
[data-theme="light"] .clean-queue-item.active {
	background: rgba(255, 255, 255, 0.2);
	border-left-color: white;
}
[data-theme="light"] .clean-queue-item:hover {
	background: rgba(255, 255, 255, 0.15);
}
[data-theme="light"] .clean-q-artist {
	opacity: 0.9;
}
[data-theme="light"] .clean-time {
	opacity: 0.9;
	text-shadow: 0 1px 2px rgba(255, 255, 255, 0.3);
}
[data-theme="light"] .clean-btn {
	color: white;
}
[data-theme="light"] .nav-item {
	color: var(--md-sys-color-on-surface);
}
[data-theme="light"] .nav-item.active {
	color: var(--md-sys-color-primary);
}
[data-theme="light"] .modal h2 {
	color: var(--md-sys-color-on-surface);
}
[data-theme="light"] #modalList {
	color: var(--md-sys-color-on-surface);
}
[data-theme="light"] #logHeader h2 {
	color: var(--md-sys-color-on-surface);
}
[data-theme="light"] .mobile-nav-item {
	color: var(--md-sys-color-on-surface);
}
[data-theme="light"] .mobile-nav-item.active {
	color: var(--md-sys-color-primary);
}
[data-theme="light"] .mobile-player-overlay {
	color: var(--md-sys-color-on-background);
}
[data-theme="light"] .mp-info-container {
	color: var(--md-sys-color-on-background);
}
[data-theme="light"] .mp-btn {
	color: var(--md-sys-color-on-background);
}
[data-theme="light"] .desktop-extended {
	color: white;
}
[data-theme="light"] .desktop-extended-bg {
	background: var(--md-sys-color-primary);
}
[data-theme="light"] .clean-title {
	color: white;
	text-shadow: 0 2px 4px rgba(0,0,0,0.3);
}
[data-theme="light"] .clean-artist {
	color: rgba(255,255,255,0.9);
	text-shadow: 0 1px 2px rgba(0,0,0,0.3);
}
[data-theme="light"] .clean-controls {
	color: white;
}

/* Extended view queue items in light mode */
[data-theme="light"] .clean-queue .queue-item {
	color: white;
	background: rgba(255, 255, 255, 0.1);
}
[data-theme="light"] .clean-queue .queue-item:hover {
	background: rgba(255, 255, 255, 0.2);
}
[data-theme="light"] .clean-queue .queue-item.active {
	background: rgba(255, 255, 255, 0.25);
	border-left-color: white;
}
[data-theme="light"] .clean-queue .queue-item .q-artist {
	opacity: 0.9 !important;
	color: rgba(255,255,255,0.9) !important;
}
[data-theme="light"] .clean-queue h3 {
	opacity: 0.9;
	color: white;
}
[data-theme="light"] .clean-volume {
	color: white;
}
[data-theme="light"] .clean-volume i {
	opacity: 0.9;
}

/* Light mode icon visibility */
[data-theme="light"] .fa-music {
    color: rgba(0, 0, 0, 0.3);
}
[data-theme="light"] .fa-bookmark {
    color: inherit;
}
[data-theme="light"] .fa-trash {
    color: inherit;
}
[data-theme="light"] .fa-grip-vertical {
    color: rgba(0, 0, 0, 0.4);
}
[data-theme="light"] .fa-ellipsis {
    color: rgba(0, 0, 0, 0.5);
}
.clean-close-fab {
	position: fixed;
	top: 24px;
	right: 24px;
	background: rgba(255, 255, 255, 0.2);
	backdrop-filter: blur(10px);
	border: none;
	color: white;
	width: 44px;
	height: 44px;
	border-radius: 50%;
	cursor: pointer;
	z-index: 10;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 18px;
	transition: all 0.2s ease;
	box-shadow: 0 2px 10px rgba(0,0,0,0.2);
}

.clean-close-fab:hover {
	background: rgba(255, 255, 255, 0.3);
	transform: scale(1.1);
}

.clean-close-fab:active {
	transform: scale(0.95);
}

/* Playlist Modal Styles */
.playlist-modal {
	background: var(--md-sys-color-surface-variant);
	width: 380px;
	max-height: 480px;
	border-radius: 28px;
	border: 1px solid var(--md-sys-color-outline);
	display: flex;
	flex-direction: column;
	overflow: hidden;
	box-shadow: 0 16px 48px rgba(0, 0, 0, 0.4);
}

.playlist-modal-header {
	display: flex;
	align-items: center;
	justify-content: space-between;
	padding: 20px 24px 16px 24px;
	border-bottom: 1px solid var(--md-sys-color-outline);
}

.playlist-modal-header h2 {
	margin: 0;
	font-size: 20px;
	font-weight: 600;
}

.modal-close-btn {
	background: transparent;
	border: none;
	color: var(--md-sys-color-on-surface);
	width: 36px;
	height: 36px;
	border-radius: 50%;
	cursor: pointer;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 18px;
	opacity: 0.7;
	transition: all 0.2s ease;
}

.modal-close-btn:hover {
	background: rgba(255, 255, 255, 0.1);
	opacity: 1;
}

.playlist-modal-content {
	flex: 1;
	overflow: hidden;
	display: flex;
	flex-direction: column;
}

.playlist-modal-list {
	flex: 1;
	overflow-y: auto;
	padding: 8px;
	max-height: 280px;
}

/* --- SEARCH COMPONENT --- */
.search-wrapper {
	position: relative;
	width: 100%;
	max-width: 100%;
	margin: 0 auto 16px 0;
}

.search-container {
	position: relative;
	width: 100%;
}

.search-input-wrapper {
	position: relative;
	width: 100%;
}

.search-input-icon {
	position: absolute;
	left: 20px;
	top: 50%;
	transform: translateY(-50%);
	color: var(--md-sys-color-on-surface-variant);
	opacity: 0.7;
	font-size: 20px;
	pointer-events: none;
	transition: all 0.2s ease;
}

.search-input {
	width: 100%;
	padding: 18px 20px 18px 56px;
	border-radius: 16px;
	border: none;
	background: var(--md-sys-color-surface-variant);
	color: var(--md-sys-color-on-surface);
	font-size: 16px;
	font-family: inherit;
	box-sizing: border-box;
	transition: all 0.2s ease;
}

.search-input::placeholder {
	color: var(--md-sys-color-on-surface-variant);
	opacity: 0.5;
}

.search-input:hover {
	background: var(--md-sys-color-surface);
}

.search-input:focus {
	outline: none;
	background: var(--md-sys-color-surface);
	box-shadow: 0 0 0 2px var(--md-sys-color-primary);
}

.search-input:focus + .search-input-icon {
	opacity: 1;
	color: var(--md-sys-color-primary);
}

.search-results {
	position: absolute;
	top: calc(100% + 8px);
	left: 0;
	right: 0;
	background: var(--md-sys-color-surface);
	border: 1px solid var(--md-sys-color-outline);
	border-radius: 28px;
	max-height: 320px;
	overflow-y: auto;
	overflow-x: hidden;
	z-index: 1000;
	box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
	display: none;
}

.search-results.visible {
	display: block;
}

.search-results::-webkit-scrollbar {
	width: 10px;
}

.search-results::-webkit-scrollbar-track {
	background: transparent;
	padding-right: 4px;
}

.search-results::-webkit-scrollbar-thumb {
	background: var(--md-sys-color-outline);
	border-radius: 5px;
}

.search-results::-webkit-scrollbar-thumb:hover {
	background: var(--md-sys-color-on-surface);
	opacity: 0.6;
}

.search-results-header {
	padding: 16px 20px 12px 20px;
	font-size: 12px;
	font-weight: 600;
	text-transform: uppercase;
	letter-spacing: 0.5px;
	color: var(--md-sys-color-on-surface);
	opacity: 0.5;
	border-bottom: 1px solid var(--md-sys-color-outline);
}

.search-result-item {
	padding: 14px 20px;
	display: flex;
	align-items: center;
	gap: 16px;
	cursor: pointer;
	transition: all 0.15s ease;
}

.search-result-item:hover {
	background: var(--md-sys-color-surface-variant);
}

.search-result-item.active {
	background: var(--md-sys-color-primary-container);
}

.search-result-item-art {
	width: 52px;
	height: 52px;
	border-radius: 12px;
	overflow: hidden;
	flex-shrink: 0;
	background: var(--md-sys-color-surface-variant);
	display: flex;
	align-items: center;
	justify-content: center;
	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

.search-result-item-art img {
	width: 100%;
	height: 100%;
	object-fit: cover;
}

.search-result-item-art i {
	font-size: 24px;
	color: var(--md-sys-color-on-surface);
	opacity: 0.3;
}

.search-result-content {
	flex: 1;
	min-width: 0;
	display: flex;
	flex-direction: column;
	gap: 3px;
}

.search-result-item-title {
	font-size: 15px;
	font-weight: 600;
	color: var(--md-sys-color-on-surface);
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}

.search-result-item-artist {
	font-size: 13px;
	color: var(--md-sys-color-on-surface);
	opacity: 0.6;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}

.search-result-add-btn {
	width: 44px;
	height: 44px;
	border-radius: 50%;
	background: var(--md-sys-color-primary-container);
	color: var(--md-sys-color-primary);
	border: none;
	cursor: pointer;
	font-size: 18px;
	transition: all 0.2s ease;
	display: flex;
	align-items: center;
	justify-content: center;
	flex-shrink: 0;
}

.search-result-add-btn:hover {
	background: var(--md-sys-color-primary);
	color: var(--md-sys-color-on-primary);
	transform: scale(1.1);
}

.search-result-add-btn:active {
	transform: scale(0.95);
}

.search-no-results {
	padding: 40px 20px;
	text-align: center;
	color: var(--md-sys-color-on-surface);
	opacity: 0.5;
	font-size: 15px;
}

.playlist-modal-item {
	display: flex;
	align-items: center;
	gap: 14px;
	padding: 12px 16px;
	border-radius: 14px;
	cursor: pointer;
	transition: all 0.2s ease;
	margin-bottom: 4px;
}

.playlist-modal-item:hover {
	background: var(--md-sys-color-primary-container);
}

.playlist-modal-item-icon {
	width: 44px;
	height: 44px;
	border-radius: 10px;
	background: var(--md-sys-color-surface);
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 20px;
	color: var(--md-sys-color-primary);
	flex-shrink: 0;
}

.playlist-modal-item-info {
	flex: 1;
	min-width: 0;
}

.playlist-modal-item-name {
	font-weight: 500;
	font-size: 15px;
	white-space: nowrap;
	overflow: hidden;
	text-overflow: ellipsis;
}

.playlist-modal-item-count {
	font-size: 13px;
	opacity: 0.6;
	margin-top: 2px;
}

.playlist-modal-item-arrow {
	opacity: 0;
	transition: all 0.2s ease;
	color: var(--md-sys-color-primary);
}

.playlist-modal-item:hover .playlist-modal-item-arrow {
	opacity: 1;
	transform: translateX(4px);
}

.playlist-modal-footer {
	padding: 16px 24px 20px 24px;
	border-top: 1px solid var(--md-sys-color-outline);
}

[data-theme="light"] .clean-close-fab {
	background: rgba(0,0,0,0.25);
	color: white;
}
[data-theme="light"] .clean-close-fab:hover {
	background: rgba(0,0,0,0.35);
}

/* Hide the player bar button when the extended view is NOT collapsed */
body:has(.desktop-extended:not(.collapsed)) #playerBarExpandedBtn {
	display: none;
}

#playerBarExpandedBtn {
	background: none;
	border: none;
	color: var(--md-sys-color-on-surface);
	cursor: pointer;
	opacity: 0.7;
	transition: all 0.2s ease;
	padding: 8px;
	display: flex;
	align-items: center;
	justify-content: center;
	font-size: 18px;
}

#playerBarExpandedBtn:hover {
	opacity: 1;
	transform: scale(1.1);
	color: var(--md-sys-color-primary);
}
</style>
</head>
<body>
<div id="modalOverlay" onclick="closeModal()" style="position:fixed;inset:0;background:rgba(0,0,0,0.7);display:none;align-items:center;justify-content:center;z-index:2000;backdrop-filter:blur(8px);transition:opacity 0.3s ease;">
    <div class="playlist-modal" onclick="event.stopPropagation()">
        <div class="playlist-modal-header">
            <h2>Add to Playlist</h2>
            <button class="modal-close-btn" onclick="closeModal()">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
        <div class="playlist-modal-content">
            <div id="modalList" class="playlist-modal-list"></div>
        </div>
        <div class="playlist-modal-footer">
            <button class="m3-btn m3-btn-filled" onclick="createNewPlaylist(true)" style="width:100%;">
                <i class="fa-solid fa-plus"></i>
                <span>New Playlist</span>
            </button>
        </div>
    </div>
</div>

<div id="logOverlay" onclick="closeLog()" style="position:fixed;inset:0;background:rgba(0,0,0,0.8);display:none;align-items:center;justify-content:center;z-index:2000;backdrop-filter:blur(10px);">
    <div id="logModal" onclick="event.stopPropagation()">
        <div id="logHeader">
            <h2 style="margin:0;">Load Log <small id="logStatus" style="opacity:0.7;"></small></h2>
            <div style="display:flex;gap:12px;align-items:center;">
                <label style="display:flex;align-items:center;gap:6px;font-size:13px;">
                    <input type="checkbox" id="autoScroll" checked> Auto-scroll
                </label>
                <button class="action-btn" onclick="closeLog()">Close</button>
            </div>
        </div>
        <div id="logContent"></div>
    </div>
</div>
<div id="albumModalOverlay" class="album-modal-overlay" onclick="closeAlbumModal()">
    <div class="album-modal" onclick="event.stopPropagation()">
        <div class="album-modal-header">
            <h2 class="album-modal-title">Add from Album</h2>
            <button class="album-modal-close" onclick="closeAlbumModal()">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
        <div id="albumModalTitle" class="album-modal-subtitle"></div>
        <div class="album-modal-content" id="albumSongList"></div>
        <div class="album-modal-footer">
            <button class="m3-btn m3-btn-modal-action" onclick="deselectAllAlbumSongs()"><i class="fa-solid fa-minus"></i><span>None</span></button>
            <button class="m3-btn m3-btn-modal-action" onclick="selectAllAlbumSongs()"><i class="fa-solid fa-check"></i><span>All</span></button>
            <div style="flex:1;"></div>
            <button class="m3-btn m3-btn-tonal" onclick="closeAlbumModal()">Cancel</button>
            <button class="m3-btn m3-btn-filled" onclick="addSelectedAlbumSongs()">Add</button>
        </div>
    </div>
</div>

<!-- Folder Add to Playlist Modal -->
<div id="folderAddModalOverlay" class="album-modal-overlay" onclick="closeFolderAddModal()">
    <div class="album-modal" style="max-width: 520px;" onclick="event.stopPropagation()">
        <div class="album-modal-header">
            <h2 class="album-modal-title">Add to Playlist</h2>
            <button class="album-modal-close" onclick="closeFolderAddModal()">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
        <div id="folderAddModalSubtitle" class="album-modal-subtitle"></div>
        <div class="album-modal-content" id="folderSongList"></div>
        <div class="album-modal-footer">
            <button class="m3-btn m3-btn-modal-action" onclick="deselectAllFolderSongs()"><i class="fa-solid fa-minus"></i><span>None</span></button>
            <button class="m3-btn m3-btn-modal-action" onclick="selectAllFolderSongs()"><i class="fa-solid fa-check"></i><span>All</span></button>
            <div style="flex:1;"></div>
            <button class="m3-btn m3-btn-tonal" onclick="closeFolderAddModal()">Cancel</button>
            <button class="m3-btn m3-btn-filled" onclick="openPlaylistSelectionForFolder()">Add</button>
        </div>
    </div>
</div>

<!-- Playlist Selection Modal (for folder add) -->
<div id="playlistSelectModalOverlay" class="album-modal-overlay" onclick="closePlaylistSelectModal()">
    <div class="album-modal" style="max-width: 400px;" onclick="event.stopPropagation()">
        <div class="album-modal-header">
            <h2 class="album-modal-title">Select Playlist</h2>
            <button class="album-modal-close" onclick="closePlaylistSelectModal()">
                <i class="fa-solid fa-xmark"></i>
            </button>
        </div>
        <div class="album-modal-content" id="playlistSelectList" style="padding: 8px 0;"></div>
        <div class="album-modal-footer" style="border-top: none; padding-top: 0;">
            <button class="m3-btn m3-btn-filled" style="width: 100%;" onclick="createNewPlaylistForFolder()">
                <i class="fa-solid fa-plus"></i>
                <span>New Playlist</span>
            </button>
        </div>
    </div>
</div>

<div id="mobilePlayer" class="mobile-player-overlay">
    <div class="mp-header">
        <button class="mp-btn" onclick="closeMobilePlayer()"><i class="fa-solid fa-chevron-down"></i></button>
        <span style="font-weight:600;text-transform:uppercase;letter-spacing:1px;font-size:12px;">Now Playing</span>
        <button class="mp-btn" id="queueMobileBtn" onclick="toggleSidebar()" style="font-size:20px;"><i class="fa-solid fa-list-ul"></i></button>
    </div>
    <div class="mp-art-container" id="fsArt">
        <i class="fa-solid fa-music"></i>
    </div>
    <div class="mp-info-container">
        <h2 id="fsTitle" class="truncate" style="font-size:28px;margin:0;">No Track</h2>
        <h3 id="fsArtist" class="truncate" style="font-size:18px;margin:0;opacity:0.7;font-weight:400;">Select music</h3>
        <p id="fsAlbum" class="truncate" style="font-size:14px;margin:0;opacity:0.5;"></p>
    </div>
    <div class="mp-progress-container">
        <span id="fsCurTime" style="font-size:12px;font-variant-numeric:tabular-nums;opacity:0.7;">0:00</span>
        <div id="fsProgressBg" style="flex:1;height:4px;background:var(--progress-bg, rgba(255,255,255,0.15));border-radius:2px;position:relative;">
            <div id="fsBuffFill" style="position:absolute;height:100%;width:0%;background:rgba(255,255,255,0.25);border-radius:2px;"></div>
            <div id="fsProgFill" style="position:absolute;height:100%;width:0%;background:var(--md-sys-color-primary);border-radius:2px;z-index:2;"></div>
            <input type="range" id="fsProgScrub" value="0" step="0.1" oninput="scrub(this.value)" style="width:100%;position:absolute;top:-10px;height:24px;opacity:0;cursor:pointer;z-index:3;">
        </div>
        <span id="fsDurTime" style="font-size:12px;font-variant-numeric:tabular-nums;opacity:0.7;">0:00</span>
    </div>
    <div class="mp-controls-container">
        <button class="mp-btn" id="fsBtnShuffle" onclick="toggleShuffle()" style="opacity:0.5;"><i class="fa-solid fa-shuffle"></i></button>
        <button class="mp-btn" onclick="skip(-1)" style="font-size:32px;"><i class="fa-solid fa-backward-step"></i></button>
        <div class="mp-play-btn" onclick="togglePlay()"><i id="fsPlayIcon" class="fa-solid fa-play"></i></div>
        <button class="mp-btn" onclick="skip(1)" style="font-size:32px;"><i class="fa-solid fa-forward-step"></i></button>
        <button class="mp-btn" id="fsBtnRepeat" onclick="toggleRepeat()" style="opacity:0.5;"><i class="fa-solid fa-repeat"></i></button>
    </div>
</div>

<div class="app-shell">
    <nav class="nav-rail">
        <div class="nav-item active" data-screen="library" onclick="goHome(this)"><div class="nav-icon-wrapper"><i class="fa-solid fa-house"></i></div><div class="nav-label">Home</div></div>
        <div class="nav-item" data-screen="playlist" onclick="nav(this)"><div class="nav-icon-wrapper"><i class="fa-solid fa-compact-disc"></i></div><div class="nav-label">Playlists</div></div>
        <div class="nav-item" data-screen="equalizer" onclick="nav(this)"><div class="nav-icon-wrapper"><i class="fa-solid fa-sliders-h"></i></div><div class="nav-label">Equalizer</div></div>
        <div class="nav-item" id="queueNavBtn" onclick="toggleSidebar()"><div class="nav-icon-wrapper"><i class="fa-solid fa-list-ul"></i></div><div class="nav-label">Queue</div></div>
        <div class="nav-item" data-screen="settings" onclick="nav(this)" style="margin-top:auto;"><div class="nav-icon-wrapper"><i class="fa-solid fa-cog"></i></div><div class="nav-label">Settings</div></div>
    </nav>
    <main class="main-container">
        <div id="library-screen" class="screen active">
            <div id="listenAgainSection" class="listen-again-container">
                <!-- Skeleton loading state -->
                <div class="listen-again-skeleton" id="listenAgainSkeleton">
                    <div class="listen-again-skeleton-item">
                        <div class="skeleton-art"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-title"></div>
                            <div class="skeleton-subtitle"></div>
                        </div>
                    </div>
                    <div class="listen-again-skeleton-item">
                        <div class="skeleton-art"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-title"></div>
                            <div class="skeleton-subtitle"></div>
                        </div>
                    </div>
                    <div class="listen-again-skeleton-item">
                        <div class="skeleton-art"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-title"></div>
                            <div class="skeleton-subtitle"></div>
                        </div>
                    </div>
                    <div class="listen-again-skeleton-item">
                        <div class="skeleton-art"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-title"></div>
                            <div class="skeleton-subtitle"></div>
                        </div>
                    </div>
                    <div class="listen-again-skeleton-item">
                        <div class="skeleton-art"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-title"></div>
                            <div class="skeleton-subtitle"></div>
                        </div>
                    </div>
                    <div class="listen-again-skeleton-item">
                        <div class="skeleton-art"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-title"></div>
                            <div class="skeleton-subtitle"></div>
                        </div>
                    </div>
                </div>
                <!-- Actual content rendered by JavaScript -->
                <div id="listenAgainContent" style="display:none;"></div>
            </div>
            
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:24px;">
                <div>
                    <h1 id="viewTitle" style="font-size:48px;margin:0;display:none;">Library</h1>
                    <div id="folderActions" style="display:none;margin-top:16px;gap:12px;align-items:center;">
                        <button class="m3-btn m3-btn-filled" onclick="playCurrentFolderRecursive()">
                            <i class="fa-solid fa-play"></i>
                            <span>Play All</span>
                        </button>
                        <button class="m3-btn m3-btn-tonal" onclick="shuffleCurrentFolderRecursive()">
                            <i class="fa-solid fa-shuffle"></i>
                            <span>Shuffle Play</span>
                        </button>
                        <button class="m3-btn m3-btn-tonal" onclick="openFolderAddModal()">
                            <i class="fa-solid fa-bookmark"></i>
                            <span>Add to Playlist</span>
                        </button>
                    </div>
                </div>
                <div style="display:flex;flex-direction:column;align-items:flex-end;gap:8px;">
                    <div id="progressContainer" class="progress-container">
                        <div id="progressBar" class="progress-bar"></div>
                    </div>
                    <div id="loadControls" style="display:none;gap:12px;align-items:center;">
                        <button id="cancelBtn" class="action-btn" onclick="cancelLoad()" style="background:#ff4444;border:none;color:white;">
                            <i class="fa-solid fa-stop"></i> Cancel
                        </button>
                        <button class="action-btn" onclick="showLog()" style="background:#444;border:none;color:white;">
                            <i class="fa-solid fa-list"></i> View Log
                        </button>
                    </div>
                    <small id="progressText" style="color:#aaa;font-size:12px;opacity:0.8;"></small>
                </div>
            </div>
            
            <!-- Unified loading overlay - shown initially, hidden when both sections are ready -->
            <div id="initialLoading" class="initial-loading-overlay">
                <div class="loading-spinner"></div>
                <p class="loading-text">Loading your library...</p>
                <p class="loading-subtext">Organizing your music</p>
            </div>
            
            <div id="breadcrumb" style="display:flex;gap:8px;margin-bottom:32px;align-items:center;flex-wrap:wrap;display:none;"></div>
            
            <!-- Folder grid skeleton loading -->
            <div id="folderGridSkeleton" class="folder-grid-skeleton">
                <div class="skeleton-folder">
                    <div class="skeleton-art"></div>
                    <div class="skeleton-text">
                        <div class="skeleton-name"></div>
                        <div class="skeleton-count"></div>
                    </div>
                </div>
                <div class="skeleton-folder">
                    <div class="skeleton-art"></div>
                    <div class="skeleton-text">
                        <div class="skeleton-name"></div>
                        <div class="skeleton-count"></div>
                    </div>
                </div>
                <div class="skeleton-folder">
                    <div class="skeleton-art"></div>
                    <div class="skeleton-text">
                        <div class="skeleton-name"></div>
                        <div class="skeleton-count"></div>
                    </div>
                </div>
                <div class="skeleton-folder">
                    <div class="skeleton-art"></div>
                    <div class="skeleton-text">
                        <div class="skeleton-name"></div>
                        <div class="skeleton-count"></div>
                    </div>
                </div>
                <div class="skeleton-folder">
                    <div class="skeleton-art"></div>
                    <div class="skeleton-text">
                        <div class="skeleton-name"></div>
                        <div class="skeleton-count"></div>
                    </div>
                </div>
                <div class="skeleton-folder">
                    <div class="skeleton-art"></div>
                    <div class="skeleton-text">
                        <div class="skeleton-name"></div>
                        <div class="skeleton-count"></div>
                    </div>
                </div>
                <div class="skeleton-folder">
                    <div class="skeleton-art"></div>
                    <div class="skeleton-text">
                        <div class="skeleton-name"></div>
                        <div class="skeleton-count"></div>
                    </div>
                </div>
                <div class="skeleton-folder">
                    <div class="skeleton-art"></div>
                    <div class="skeleton-text">
                        <div class="skeleton-name"></div>
                        <div class="skeleton-count"></div>
                    </div>
                </div>
            </div>
            
            <div id="folderGrid" class="folder-grid" style="display:none;"></div>
            <table style="width:100%;border-collapse:separate;border-spacing:0 4px;margin-top:20px;"><tbody id="libSongBody"></tbody></table>
        </div>
        
        <div id="equalizer-screen" class="screen">
            <div class="eq-page-header">
                <h1 class="eq-page-title">Equalizer</h1>
                <p class="eq-page-subtitle">Customize your sound</p>
            </div>
            
            <div class="eq-container">
                <!-- Header Section -->
                <div class="eq-header">
                    <div class="eq-header-info">
                        <span class="eq-section-label">Presets</span>
                        <h2 class="eq-header-title">Sound Profiles</h2>
                    </div>
                    <div class="eq-presets">
                        <div class="eq-preset-dropdown">
                            <select onchange="applyEqPreset(this.value)">
                                <option value="flat">Flat</option>
                                <option value="rock">Rock</option>
                                <option value="pop">Pop</option>
                                <option value="jazz">Jazz</option>
                                <option value="classical">Classical</option>
                                <option value="bass">Bass Boost</option>
                                <option value="vocal">Vocal Boost</option>
                            </select>
                            <i class="fa-solid fa-chevron-down"></i>
                        </div>
                        <button class="m3-btn m3-btn-tonal" onclick="resetEqualizer()" title="Reset to Default">
                            <i class="fa-solid fa-arrow-rotate-left"></i>
                            <span>Reset</span>
                        </button>
                    </div>
                </div>

                <!-- Bass & Treble Section -->
                <div class="eq-section">
                    <div class="eq-section-header">
                        <i class="fa-solid fa-sliders"></i>
                        <h3>Tone Controls</h3>
                    </div>
                    <div class="tone-slider-row">
                        <div class="tone-label">
                            <i class="fa-solid fa-bass"></i>
                            <span>Bass</span>
                        </div>
                        <input type="range" id="bassSlider" class="tone-range" min="0" max="100" value="0">
                        <div id="bassValue" class="tone-value">0%</div>
                    </div>
                    
                    <div class="tone-slider-row">
                        <div class="tone-label">
                            <i class="fa-solid fa-music"></i>
                            <span>Treble</span>
                        </div>
                        <input type="range" id="trebleSlider" class="tone-range" min="0" max="100" value="0">
                        <div id="trebleValue" class="tone-value">0%</div>
                    </div>
                </div>

                <!-- 10-Band EQ Section -->
                <div class="eq-section eq-graphic-section">
                    <div class="eq-section-header">
                        <i class="fa-solid fa-chart-simple"></i>
                        <h3>10-Band Equalizer</h3>
                    </div>
                    <div class="eq-visualizer-container">
                        <div class="eq-sliders-grid" id="eqSliders"></div>
                    </div>
                </div>

                <!-- Quick Preset Buttons -->
                <div class="eq-quick-presets">
                    <button class="m3-btn m3-btn-tonal eq-preset-chip" onclick="applyEqPreset('flat')">Flat</button>
                    <button class="m3-btn m3-btn-tonal eq-preset-chip" onclick="applyEqPreset('bass')">Bass</button>
                    <button class="m3-btn m3-btn-tonal eq-preset-chip" onclick="applyEqPreset('vocal')">Vocal</button>
                    <button class="m3-btn m3-btn-tonal eq-preset-chip" onclick="applyEqPreset('rock')">Rock</button>
                    <button class="m3-btn m3-btn-tonal eq-preset-chip" onclick="applyEqPreset('pop')">Pop</button>
                </div>
            </div>
        </div>

        <div id="playlist-screen" class="screen">
            <h1 style="font-size:48px;margin:0 0 24px 0;">Playlists</h1>
            <div id="playlistGridContainer">
                <div style="display:flex;justify-content:flex-start;align-items:center;margin-bottom:32px;gap:12px;">
                    <button class="m3-btn m3-btn-tonal" onclick="exportPlaylists()">
                        <i class="fa-solid fa-file-export"></i>
                        <span>Export</span>
                    </button>
                    <button class="m3-btn m3-btn-tonal" onclick="document.getElementById('importFile').click()">
                        <i class="fa-solid fa-file-import"></i>
                        <span>Import</span>
                    </button>
                    <input type="file" id="importFile" accept=".goot2" style="display:none" onchange="importPlaylists(this)">
                </div>
                <div id="playlistGrid" class="folder-grid"></div>
            </div>
            <div id="playlistContentView" style="display:none;">
                <div class="playlist-breadcrumb" id="playlistBreadcrumb"></div>
                <div class="playlist-header">
                    <div class="playlist-cover" id="playlistCover">
                        <div class="no-art"><i class="fa-solid fa-compact-disc"></i></div>
                    </div>
                    <div class="playlist-info">
                        <h2 id="currentPlaylistTitle" style="font-size:40px;margin:0 0 8px 0;"></h2>
                        <div class="playlist-controls">
                            <div class="play-btn control-btn" onclick="playPlaylist(currentPlaylistName)" style="width:64px;height:64px;font-size:28px;">
                                <i class="fa-solid fa-play"></i>
                            </div>
                            <div class="play-btn control-btn shuffle" onclick="shuffleAndPlayPlaylist(currentPlaylistName)" style="width:64px;height:64px;font-size:26px;">
                                <i class="fa-solid fa-shuffle"></i>
                            </div>
                        </div>
                        <div class="playlist-management">
                            <button class="m3-btn m3-btn-tonal" id="pinToListenAgainBtn" onclick="togglePinCurrentPlaylist()">
                                <i class="fa-solid fa-heart"></i>
                                <span id="pinToListenAgainLabel">Pin to Listen Again</span>
                            </button>
                            <button class="m3-btn m3-btn-tonal" onclick="renameCurrentPlaylist()">
                                <i class="fa-solid fa-pen"></i>
                                <span>Rename</span>
                            </button>
                            <button class="m3-btn m3-btn-tonal playlist-delete-btn" onclick="deleteCurrentPlaylist()">
                                <i class="fa-solid fa-trash"></i>
                                <span>Delete</span>
                            </button>
                        </div>
                    </div>
                </div>
                <div class="search-wrapper">
                    <div class="search-container">
                        <div class="search-input-wrapper">
                            <input type="text" class="search-input" placeholder="Search cache (title/artist/album/genre/etc)..." oninput="searchSongsToAdd(this.value)">
                            <i class="search-input-icon fa-solid fa-magnifying-glass"></i>
                        </div>
                        <div id="searchResults" class="search-results"></div>
                    </div>
                </div>
                <table style="width:100%;"><tbody id="playlistSongBody"></tbody></table>
            </div>
        </div>
        <div id="settings-screen" class="screen">
            <div class="settings-header">
                <h1 class="settings-title">Settings</h1>
            </div>

            <!-- Appearance Section -->
            <div class="simple-settings-section">
                <h2 class="simple-section-title">Appearance</h2>

                <!-- Dark Mode Toggle - Entire row is clickable -->
                <label class="simple-setting-row" style="cursor: pointer;">
                    <div class="simple-setting-info">
                        <span class="simple-setting-label" id="themeModeLabel">Dark Mode</span>
                        <span class="simple-setting-desc">Tap to switch themes</span>
                    </div>
                    <div class="simple-toggle">
                        <input type="checkbox" id="themeToggle" onchange="toggleTheme()" checked>
                        <span class="simple-toggle-track">
                            <span class="simple-toggle-thumb"></span>
                        </span>
                    </div>
                </label>
            </div>

            <!-- Accent Color Section -->
            <div class="simple-settings-section">
                <h2 class="simple-section-title">Accent Color</h2>
                <div class="color-grid">
                    <button class="color-btn" style="background:#FF4D4D;" onclick="updateTheme('#FF4D4D')"></button>
                    <button class="color-btn" style="background:#FF6B6B;" onclick="updateTheme('#FF6B6B')"></button>
                    <button class="color-btn" style="background:#F59E0B;" onclick="updateTheme('#F59E0B')"></button>
                    <button class="color-btn" style="background:#84CC16;" onclick="updateTheme('#84CC16')"></button>
                    <button class="color-btn" style="background:#22C55E;" onclick="updateTheme('#22C55E')"></button>
                    <button class="color-btn" style="background:#14B8A6;" onclick="updateTheme('#14B8A6')"></button>
                    <button class="color-btn" style="background:#0EA5E9;" onclick="updateTheme('#0EA5E9')"></button>
                    <button class="color-btn" style="background:#3B82F6;" onclick="updateTheme('#3B82F6')"></button>
                    <button class="color-btn" style="background:#6366F1;" onclick="updateTheme('#6366F1')"></button>
                    <button class="color-btn" style="background:#8B5CF6;" onclick="updateTheme('#8B5CF6')"></button>
                    <button class="color-btn" style="background:#EC4899;" onclick="updateTheme('#EC4899')"></button>
                    <button class="color-btn pencil-color-btn" onclick="document.getElementById('accentPicker').click()">
                        <i class="fa-solid fa-pencil"></i>
                    </button>
                </div>
                <input type="color" id="accentPicker" onchange="updateTheme(this.value)" class="hidden-input">
            </div>

            <!-- Match Album Art Toggle -->
            <div class="simple-settings-section">
                <label class="simple-setting-row" style="cursor: pointer;">
                    <div class="simple-setting-info">
                        <span class="simple-setting-label">Match Album Art</span>
                        <span class="simple-setting-desc">Extract colors from artwork</span>
                    </div>
                    <div class="simple-toggle">
                        <input type="checkbox" id="albumColorToggle" onchange="toggleAlbumColorMode()">
                        <span class="simple-toggle-track">
                            <span class="simple-toggle-thumb"></span>
                        </span>
                    </div>
                </label>
            </div>

            <!-- Audio Section -->
            <div class="simple-settings-section">
                <h2 class="simple-section-title">Audio</h2>
                <label class="simple-setting-row" style="cursor: pointer;">
                    <div class="simple-setting-info">
                        <span class="simple-setting-label">Volume Normalization</span>
                        <span class="simple-setting-desc">Consistent volume across tracks</span>
                    </div>
                    <div class="simple-toggle">
                        <input type="checkbox" id="normToggle" onchange="toggleNormalization()">
                        <span class="simple-toggle-track">
                            <span class="simple-toggle-thumb"></span>
                        </span>
                    </div>
                </label>

                <!-- Target Loudness Slider -->
                <div class="lufs-control-section">
                    <div class="lufs-header">
                        <div class="lufs-icon">
                            <i class="fa-solid fa-wave-square"></i>
                        </div>
                        <div class="lufs-title-area">
                            <span class="lufs-label">Target Loudness</span>
                            <span class="lufs-value" id="normTargetValue">-14 LUFS</span>
                        </div>
                    </div>
                    
                    <div class="lufs-slider-container">
                        <input type="range" id="normTargetSlider" class="lufs-slider" min="-23" max="-8" value="-14" step="1" oninput="updateLufsDisplay(this.value)" onchange="updateNormTarget(this.value)">
                        <div class="lufs-track">
                            <div class="lufs-progress" id="lufsProgress"></div>
                        </div>
                        <div class="lufs-markers">
                            <div class="lufs-marker" data-value="-23">
                                <span class="marker-line"></span>
                                <span class="marker-label">-23</span>
                                <span class="marker-desc">Quiet</span>
                            </div>
                            <div class="lufs-marker" data-value="-18">
                                <span class="marker-line"></span>
                                <span class="marker-label">-18</span>
                            </div>
                            <div class="lufs-marker" data-value="-14">
                                <span class="marker-line"></span>
                                <span class="marker-label">-14</span>
                                <span class="marker-desc">Standard</span>
                            </div>
                            <div class="lufs-marker" data-value="-10">
                                <span class="marker-line"></span>
                                <span class="marker-label">-10</span>
                            </div>
                            <div class="lufs-marker" data-value="-8">
                                <span class="marker-line"></span>
                                <span class="marker-label">-8</span>
                                <span class="marker-desc">Loud</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Analyze Current Track Button -->
                <button class="m3-btn m3-btn-tonal" onclick="manualAnalyzeCurrentTrack()" style="width: 100%; margin-top: 16px;">
                    <i class="fa-solid fa-wave-square"></i>
                    Analyze Current Track
                </button>
            </div>

            <!-- Danger Zone - Remove All Metadata Button Only -->
            <div class="simple-settings-section danger-section">
                <h2 class="simple-section-title" style="color: #dc2626;">Danger Zone</h2>
                <button class="danger-btn" onclick="clearAllCache()">
                    <i class="fa-solid fa-trash"></i>
                    Remove All Metadata
                </button>
                <button class="danger-btn hard-reset-btn" onclick="hardReset()">
                    <i class="fa-solid fa-bomb"></i>
                    Hard Reset - Remove All Data
                </button>
            </div>
        </div>
        
        <!-- All Played Tracks Screen (not in sidebar) -->
        <div id="all-played-screen" class="screen">
            <div class="all-played-header">
                <div class="breadcrumb" id="allPlayedBreadcrumb" style="display:flex;gap:8px;margin-bottom:24px;align-items:center;flex-wrap:wrap;"></div>
                <h1 class="all-played-title">All Played Tracks</h1>
                <p class="all-played-subtitle">Your most played tracks</p>
            </div>
            <div id="allPlayedTracksContainer" class="all-played-tracks-container"></div>
        </div>
    </main>
    <aside class="side-sheet" id="sidebar">
        <div style="padding:24px;border-bottom:1px solid var(--md-sys-color-outline);display:flex;justify-content:space-between;align-items:center;">
            <b style="letter-spacing:1px;text-transform:uppercase;font-size:12px;opacity:0.6;">Current Queue</b>
            <button onclick="toggleSidebar()" style="background:none;border:none;color:inherit;cursor:pointer;"><i class="fa-solid fa-xmark"></i></button>
        </div>
        <div id="queueList" style="flex:1;overflow-y:auto;padding:8px 0;"></div>
    </aside>
    
    <nav class="mobile-nav">
        <div class="mobile-nav-item active" onclick="goHome(this)" data-screen="library">
            <i class="fa-solid fa-house"></i>
            <span>Home</span>
        </div>
        <div class="mobile-nav-item" onclick="nav(this)" data-screen="playlist">
            <i class="fa-solid fa-compact-disc"></i>
            <span>Playlists</span>
        </div>
        <div class="mobile-nav-item" onclick="nav(this)" data-screen="equalizer">
            <i class="fa-solid fa-sliders-h"></i>
            <span>EQ</span>
        </div>
        <div class="mobile-nav-item" onclick="toggleSidebar()">
            <i class="fa-solid fa-list-ul"></i>
            <span>Queue</span>
        </div>
        <div class="mobile-nav-item" onclick="nav(this)" data-screen="settings">
            <i class="fa-solid fa-sliders"></i>
            <span>Settings</span>
        </div>
    </nav>
</div>
<footer class="player-bar" onclick="openMobilePlayer()">
    <div style="width:340px;display:flex;align-items:center;gap:16px;">
        <div id="npArt" style="width:64px;height:64px;border-radius:12px;background:var(--md-sys-color-surface-variant);overflow:hidden;box-shadow:0 4px 16px rgba(0,0,0,0.5);transition:all 0.3s ease;">
            <div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;">
                <i class="fa-solid fa-music" style="opacity:0.35;font-size:28px;"></i>
            </div>
        </div>
        <div style="flex:1;overflow:hidden;">
            <div id="npTitle" class="truncate" style="font-weight:700;font-size:15px;line-height:1.3;">No Track</div>
            <div id="npArtist" class="truncate" style="font-size:13px;opacity:0.8;margin:2px 0;">Select music</div>
            <div id="npAlbum" class="truncate" style="font-size:12px;opacity:0.6;"></div>
        </div>
    </div>
    <div style="flex:1;display:flex;flex-direction:column;align-items:center;gap:8px;">
        <div style="display:flex;align-items:center;gap:24px;">
            <i class="fa-solid fa-shuffle" id="btnShuffle" onclick="event.stopPropagation(); toggleShuffle()" style="cursor:pointer;font-size:18px;opacity:0.5;transition:all 0.3s;"></i>
            <i class="fa-solid fa-backward-step" onclick="event.stopPropagation(); skip(-1)" style="cursor:pointer;font-size:22px;"></i>
            <div class="play-btn" onclick="event.stopPropagation(); togglePlay()"><i id="playIcon" class="fa-solid fa-play"></i></div>
            <i class="fa-solid fa-forward-step" onclick="event.stopPropagation(); skip(1)" style="cursor:pointer;font-size:22px;"></i>
            <i class="fa-solid fa-repeat" id="btnRepeat" onclick="event.stopPropagation(); toggleRepeat()" style="cursor:pointer;font-size:18px;opacity:0.5;transition:all 0.3s;"></i>
        </div>
        <div style="width:100%;max-width:700px;display:flex;align-items:center;gap:14px;">
            <span id="curTime" style="font-size:12px;min-width:40px;">0:00</span>
            <div id="playerBarProgressBg" style="flex:1;height:6px;background:var(--progress-bg, rgba(255,255,255,0.15));border-radius:3px;position:relative;overflow:hidden;">
                <div id="buffFill" style="position:absolute;height:100%;width:0%;background:rgba(255,255,255,0.25);border-radius:3px;"></div>
                <div id="progFill" style="position:absolute;height:100%;width:0%;background:linear-gradient(90deg,var(--md-sys-color-primary),color-mix(in srgb,var(--md-sys-color-primary) 70%,white));border-radius:3px;box-shadow:0 0 12px var(--md-sys-color-primary);transition:width 0.18s linear;z-index:2;"></div>
                <input type="range" id="progScrub" value="0" step="0.1" oninput="event.stopPropagation(); scrub(this.value)" onclick="event.stopPropagation()" style="width:100%;position:absolute;top:-8px;opacity:0;cursor:pointer;z-index:3;">
            </div>
            <span id="durTime" style="font-size:12px;min-width:40px;">0:00</span>
        </div>
    </div>
    <div style="width:200px;display:flex;align-items:center;justify-content:flex-end;gap:12px;padding-right:20px;">
        
        <button id="playerBarExtendedBtn" class="mp-btn" onclick="event.stopPropagation(); toggleDesktopExtended()" title="Open Extended View">
            <i class="fa-solid fa-up-right-and-down-left-from-center"></i>
        </button>

        <i id="volIcon" class="fa-solid fa-volume-high" onclick="event.stopPropagation(); toggleMute()" style="cursor:pointer;width:24px;text-align:center;font-size:16px;opacity:0.8;"></i>
        <div style="width:100px;display:flex;align-items:center;">
            <input type="range" id="volSlider" min="0" max="1" step="0.01" value="1" oninput="event.stopPropagation(); setVolume(this.value)" onclick="event.stopPropagation()" style="width:100%;cursor:pointer;height:4px;accent-color:var(--md-sys-color-primary);">
        </div>
    </div>
</footer>

<audio id="player" crossorigin="anonymous" preload="auto"></audio>

<div id="desktopExtended" class="desktop-extended collapsed">
		<div id="desktopExtendedArtBg" class="desktop-extended-art-bg"></div>
		<div class="desktop-extended-art">
			<img id="desktopExtendedArtImg" class="desktop-extended-art-img" src="" alt="">
		</div>
		<button class="clean-close-fab" onclick="toggleDesktopExtended()">
			<i class="fa-solid fa-chevron-down"></i>
		</button>

		<div class="clean-player">
			<div class="clean-controls-panel">
				<div class="clean-info-panel">
					<div id="deTitle" class="clean-title">No Track</div>
					<div id="deArtist" class="clean-artist">Select music</div>

					<div class="clean-progress">
						<span id="deCurTime" class="clean-time">0:00</span>
						<div class="clean-bar-bg">
							<div id="deProgFill" class="clean-bar-fill"></div>
							<input type="range" id="deProgScrub" class="clean-scrub" value="0" step="0.1" oninput="scrub(this.value)">
						</div>
						<span id="deDurTime" class="clean-time">0:00</span>
					</div>

					<div class="clean-controls">
						<button class="clean-btn" id="deShuffleBtn" onclick="toggleShuffle()"><i class="fa-solid fa-shuffle"></i></button>
						<button class="clean-btn" onclick="skip(-1)"><i class="fa-solid fa-backward-step"></i></button>
						<button class="clean-btn play-btn-large" onclick="togglePlay()"><i id="dePlayIcon" class="fa-solid fa-play"></i></button>
						<button class="clean-btn" onclick="skip(1)"><i class="fa-solid fa-forward-step"></i></button>
						<button class="clean-btn" id="deRepeatBtn" onclick="toggleRepeat()"><i class="fa-solid fa-repeat"></i></button>
					</div>

					<div class="clean-volume">
						<i class="fa-solid fa-volume-high" id="deVolIcon" style="font-size:14px;opacity:0.7;"></i>
						<input type="range" id="deVolSlider" min="0" max="1" step="0.01" value="1" oninput="setVolume(this.value)" style="width:100px;cursor:pointer;accent-color:var(--md-sys-color-primary);">
					</div>
				</div>
			</div>

			<div class="clean-queue">
				<h3>Up Next</h3>
				<div id="deQueueList" style="text-align:left;"></div>
			</div>
		</div>
	</div>

<script>

// Horizontal scroll functions for Listen Again
let listenAgainCanScrollLeft = false;
let listenAgainCanScrollRight = false;

function updateListenAgainScrollButtons() {
    const container = document.querySelector('.listen-again-scroll-container');
    if (container) {
        listenAgainCanScrollLeft = container.scrollLeft > 0;
        listenAgainCanScrollRight = container.scrollLeft < container.scrollWidth - container.clientWidth - 10;
        
        const prevBtn = document.querySelector('.listen-again-carousel-prev');
        const nextBtn = document.querySelector('.listen-again-carousel-next');
        if (prevBtn) prevBtn.disabled = !listenAgainCanScrollLeft;
        if (nextBtn) nextBtn.disabled = !listenAgainCanScrollRight;
    }
}

function scrollListenAgain(direction) {
    const container = document.querySelector('.listen-again-scroll-container');
    if (container) {
        const scrollAmount = 816; // Scroll 4 cards at once (4 * 204px)
        container.scrollBy({ left: direction * scrollAmount, behavior: 'smooth' });
    }
}

// Update scroll button state based on scroll position (uses visibility instead of disabled)
function updateListenAgainScrollState() {
    const container = document.querySelector('.listen-again-scroll-container');
    const prevBtn = document.getElementById('listenAgainPrevBtn');
    const nextBtn = document.getElementById('listenAgainNextBtn');
    
    if (container && prevBtn && nextBtn) {
        const scrollLeft = container.scrollLeft;
        const scrollWidth = container.scrollWidth;
        const clientWidth = container.clientWidth;
        
        const canScrollLeft = scrollLeft > 0;
        const canScrollRight = scrollLeft < scrollWidth - clientWidth - 10;
        
        // Use visibility instead of disabled for cleaner UI
        prevBtn.style.visibility = canScrollLeft ? 'visible' : 'hidden';
        nextBtn.style.visibility = canScrollRight ? 'visible' : 'hidden';
    }
}

// Initialize scroll state on load
document.addEventListener('DOMContentLoaded', () => {
    setTimeout(updateListenAgainScrollState, 500);
});

// Update scroll buttons on resize
window.addEventListener('resize', () => {
    setTimeout(updateListenAgainScrollState, 100);
});

const WORKER_URL = "https://gootapimask.jpm333678.workers.dev/";
const ROOT_ID = "1kje6wQMhMxvuI-2eYsAMVvs09JYLDo2s";

// Helper function to get image URL with proper MIME type override (for HEIC files)
function getImageUrl(id, mimeType = null) {
    if (mimeType) {
        return `${WORKER_URL}?id=${id}&mime=${encodeURIComponent(mimeType)}`;
    }
    return `${WORKER_URL}?id=${id}`;
}

// Helper function to check if a file is a HEIC/HEIF image
function isHeicFile(fileName) {
    const name = fileName.toLowerCase();
    return name.endsWith('.heic') || name.endsWith('.heif');
}

// Get appropriate MIME type for image files
function getImageMimeType(fileName, mimeType) {
    // If already a standard image type, use it as-is
    if (mimeType && (mimeType.startsWith('image/jpeg') || mimeType.startsWith('image/png') || 
        mimeType.startsWith('image/gif') || mimeType.startsWith('image/webp'))) {
        return mimeType;
    }
    // For HEIC/HEIF files, convert to JPEG for browser compatibility
    if (isHeicFile(fileName)) {
        return 'image/jpeg';
    }
    return mimeType;
}

let stack = [{id: ROOT_ID, name: "Home"}];
let queue = [], originalQueue = [];
let qIndex = -1;
let currentPlaylistName = "";
let currentQueueSource = null;
let trackMetadata = {}; // Will be loaded from IndexedDB
let tempArtCache = {};
let albumArtCache = {};
let playlists = JSON.parse(localStorage.getItem('goot_playlists') || '{}');
let playlistCovers = {}; // Will be loaded from IndexedDB
let shuffleMode = false;
let repeatMode = 0;
let isLoadingAll = false;
let shouldCancelLoad = false;
let loadLog = [];
let totalFilesToLoad = 0;
let processedFiles = 0;
let logModalOpen = false;
let playlistSortable = null;
let currentAlbumMap = {};
let pendingMetadataLoads = new Set();
let isBulkMetadataLoading = false; // Flag to prevent color extraction lag during bulk loading

// ========== NEW: Comprehensive IndexedDB for ALL data ==========
// Consolidated database for track metadata, play counts, playlists, and album art
const DB_NAME = 'GootPlayerDB';
const DB_VERSION = 2; // Incremented to trigger upgrade for new stores
let metaDB = null;
let metaDBReady = false;

// Initialize the main metadata database
async function initMetaDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        
        request.onerror = () => {
            console.error('[MetaDB] Failed to open:', request.error);
            reject(request.error);
        };
        
        request.onsuccess = () => {
            metaDB = request.result;
            
            // Handle version change (e.g., after database deletion)
            metaDB.onversionchange = () => {
                console.log('[MetaDB] Version change detected, closing connection');
                metaDB.close();
                metaDBReady = false;
            };
            
            console.log('[MetaDB] Database opened successfully');
            metaDBReady = true;
            resolve(metaDB);
        };
        
        request.onupgradeneeded = (e) => {
            const db = e.target.result;
            
            console.log('[MetaDB] Creating/upgrading database stores');
            
            // Store for track metadata
            if (!db.objectStoreNames.contains('trackMetadata')) {
                db.createObjectStore('trackMetadata', { keyPath: 'id' });
            }
            
            // Store for play counts
            if (!db.objectStoreNames.contains('playCounts')) {
                db.createObjectStore('playCounts', { keyPath: 'trackId' });
            }
            
            // Store for playlists (backup of localStorage)
            if (!db.objectStoreNames.contains('playlists')) {
                db.createObjectStore('playlists', { keyPath: 'name' });
            }
            
            // Store for playlist covers
            if (!db.objectStoreNames.contains('playlistCovers')) {
                db.createObjectStore('playlistCovers', { keyPath: 'name' });
            }
            
            // Store for album art (images)
            if (!db.objectStoreNames.contains('albumArt')) {
                const store = db.createObjectStore('albumArt', { keyPath: 'key' });
                store.createIndex('timestamp', 'timestamp');
            }
            
            // Store for Listen Again / most played tracks
            if (!db.objectStoreNames.contains('mostPlayed')) {
                db.createObjectStore('mostPlayed', { keyPath: 'id' });
            }
            
            // Store for album counts
            if (!db.objectStoreNames.contains('albumCounts')) {
                db.createObjectStore('albumCounts', { keyPath: 'id' });
            }
            
            console.log('[MetaDB] Database upgrade complete');
        };
    });
}

// Load track metadata from IndexedDB
async function loadTrackMetadataFromDB() {
    if (!metaDB) await initMetaDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = metaDB.transaction(['trackMetadata'], 'readonly');
            const store = transaction.objectStore('trackMetadata');
            const request = store.getAll();
            
            request.onsuccess = () => {
                const result = request.result || [];
                // Convert array to object
                result.forEach(item => {
                    trackMetadata[item.id] = item.data;
                });
                console.log('[MetaDB] Loaded', Object.keys(trackMetadata).length, 'track metadata entries');
                resolve(trackMetadata);
            };
            
            request.onerror = () => {
                console.error('[MetaDB] Failed to load metadata:', request.error);
                resolve({});
            };
        } catch (e) {
            console.error('[MetaDB] Error loading metadata:', e);
            resolve({});
        }
    });
}

// Save single track metadata to IndexedDB
async function saveTrackMetadataToDB(id, data) {
    if (!metaDB) await initMetaDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = metaDB.transaction(['trackMetadata'], 'readwrite');
            const store = transaction.objectStore('trackMetadata');
            
            store.put({ id, data, timestamp: Date.now() });
            
            transaction.oncomplete = () => resolve(true);
            transaction.onerror = () => reject(transaction.error);
        } catch (e) {
            console.error('[MetaDB] Error saving metadata:', e);
            reject(e);
        }
    });
}

// Load play counts from IndexedDB
async function loadPlayCountsFromDB() {
    if (!metaDB) await initMetaDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = metaDB.transaction(['playCounts'], 'readonly');
            const store = transaction.objectStore('playCounts');
            const request = store.getAll();
            
            request.onsuccess = () => {
                const result = request.result || [];
                const counts = {};
                result.forEach(item => {
                    counts[item.trackId] = item.count;
                });
                console.log('[MetaDB] Loaded', Object.keys(counts).length, 'play counts');
                resolve(counts);
            };
            
            request.onerror = () => {
                console.error('[MetaDB] Failed to load play counts:', request.error);
                resolve({});
            };
        } catch (e) {
            console.error('[MetaDB] Error loading play counts:', e);
            resolve({});
        }
    });
}

// Save play count to IndexedDB
async function savePlayCountToDB(trackId, count) {
    if (!metaDB) await initMetaDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = metaDB.transaction(['playCounts'], 'readwrite');
            const store = transaction.objectStore('playCounts');
            store.put({ trackId, count, timestamp: Date.now() });
            
            transaction.oncomplete = () => resolve(true);
            transaction.onerror = () => reject(transaction.error);
        } catch (e) {
            console.error('[MetaDB] Error saving play count:', e);
            reject(e);
        }
    });
}

// Clear all play counts (for testing)
async function clearPlayCountsDB() {
    if (!metaDB) await initMetaDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = metaDB.transaction(['playCounts'], 'readwrite');
            const store = transaction.objectStore('playCounts');
            store.clear();
            
            transaction.oncomplete = () => resolve(true);
            transaction.onerror = () => reject(transaction.error);
        } catch (e) {
            reject(e);
        }
    });
}

// Save playlist covers to IndexedDB
async function savePlaylistCoversToDB(coversData) {
    if (!metaDB) await initMetaDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = metaDB.transaction(['playlistCovers'], 'readwrite');
            const store = transaction.objectStore('playlistCovers');
            
            // Clear existing and save all covers
            store.clear();
            Object.entries(coversData).forEach(([name, cover]) => {
                store.put({ name, cover, timestamp: Date.now() });
            });
            
            transaction.oncomplete = () => {
                console.log('[DB] Saved playlist covers to IndexedDB');
                resolve(true);
            };
            transaction.onerror = () => reject(transaction.error);
        } catch (e) {
            reject(e);
        }
    });
}

// Load playlist covers from IndexedDB
async function loadPlaylistCoversFromDB() {
    if (!metaDB) await initMetaDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = metaDB.transaction(['playlistCovers'], 'readonly');
            const store = transaction.objectStore('playlistCovers');
            const request = store.getAll();
            
            request.onsuccess = () => {
                const result = request.result || [];
                const coversData = {};
                result.forEach(item => {
                    coversData[item.name] = item.cover;
                });
                console.log('[DB] Loaded playlist covers from IndexedDB:', Object.keys(coversData).length, 'covers');
                resolve(coversData);
            };
            
            request.onerror = () => {
                console.error('[DB] Failed to load playlist covers:', request.error);
                resolve({});
            };
        } catch (e) {
            console.error('[DB] Error loading playlist covers:', e);
            resolve({});
        }
    });
}

// Save most played tracks to IndexedDB (Listen Again feature)
async function saveMostPlayedToDB(trackData) {
    if (!metaDB) await initMetaDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = metaDB.transaction(['mostPlayed'], 'readwrite');
            const store = transaction.objectStore('mostPlayed');
            
            // Clear existing and save all tracks
            store.clear();
            trackData.forEach(track => {
                store.put({
                    id: track.id,
                    title: track.title,
                    artist: track.artist,
                    album: track.album,
                    albumArt: track.albumArt,
                    playCount: track.playCount,
                    timestamp: Date.now()
                });
            });
            
            transaction.oncomplete = () => {
                console.log('[MetaDB] Saved', trackData.length, 'most played tracks to IndexedDB');
                resolve(true);
            };
            transaction.onerror = () => reject(transaction.error);
        } catch (e) {
            console.error('[MetaDB] Error saving most played:', e);
            reject(e);
        }
    });
}

// Load most played tracks from IndexedDB (Listen Again feature)
async function loadMostPlayedFromDB() {
    if (!metaDB) await initMetaDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = metaDB.transaction(['mostPlayed'], 'readonly');
            const store = transaction.objectStore('mostPlayed');
            const request = store.getAll();
            
            request.onsuccess = () => {
                const result = request.result || [];
                console.log('[MetaDB] Loaded', result.length, 'most played tracks from IndexedDB');
                resolve(result);
            };
            
            request.onerror = () => {
                console.error('[MetaDB] Failed to load most played:', request.error);
                resolve([]);
            };
        } catch (e) {
            console.error('[MetaDB] Error loading most played:', e);
            resolve([]);
        }
    });
}

// Migrate existing localStorage data to IndexedDB
async function migrateLocalStorageToDB() {
    console.log('[MetaDB] Starting migration from localStorage...');
    
    // Migrate track metadata
    try {
        const savedMeta = localStorage.getItem('goot_meta_cache');
        if (savedMeta) {
            const meta = JSON.parse(savedMeta);
            let migrated = 0;
            
            for (const [id, data] of Object.entries(meta)) {
                await saveTrackMetadataToDB(id, data);
                migrated++;
            }
            console.log('[MetaDB] Migrated', migrated, 'track metadata entries');
        }
    } catch (e) {
        console.error('[MetaDB] Error migrating metadata:', e);
    }
    
    // Migrate play counts
    try {
        const savedCounts = localStorage.getItem('goot_play_counts');
        if (savedCounts) {
            const counts = JSON.parse(savedCounts);
            let migrated = 0;
            
            for (const [trackId, count] of Object.entries(counts)) {
                await savePlayCountToDB(trackId, count);
                migrated++;
            }
            console.log('[MetaDB] Migrated', migrated, 'play counts');
        }
    } catch (e) {
        console.error('[MetaDB] Error migrating play counts:', e);
    }
    
    // Migrate most played (Listen Again) data
    try {
        const savedMostPlayed = localStorage.getItem('goot_most_played');
        if (savedMostPlayed) {
            const tracks = JSON.parse(savedMostPlayed);
            if (tracks.length > 0) {
                await saveMostPlayedToDB(tracks);
                console.log('[MetaDB] Migrated', tracks.length, 'most played tracks');
            }
        }
    } catch (e) {
        console.error('[MetaDB] Error migrating most played:', e);
    }
    
    console.log('[MetaDB] Migration complete');
}

// Initialize the main database
async function initAllDatabases() {
    try {
        await initMetaDB();
        console.log('[DB] Database initialized');
        
        // Migrate localStorage data to IndexedDB
        await migrateLocalStorageToDB();
        
        // Load data from IndexedDB
        const [trackMeta, loadedPlayCounts, loadedPlaylistCovers] = await Promise.all([
            loadTrackMetadataFromDB(),
            loadPlayCountsFromDB(),
            loadPlaylistCoversFromDB()
        ]);
        
        // FIX: Assign loaded track metadata to global variable
        if (trackMeta && Object.keys(trackMeta).length > 0) {
            trackMetadata = trackMeta;
            console.log('[DB] Track metadata assigned to global variable:', Object.keys(trackMetadata).length, 'tracks');
        }
        
        // FIX: Assign loaded play counts to global variable
        if (loadedPlayCounts && Object.keys(loadedPlayCounts).length > 0) {
            playCounts = loadedPlayCounts;
            console.log('[DB] Play counts assigned to global variable:', Object.keys(playCounts).length, 'tracks');
        }
        
        // Assign loaded playlist covers to global variable
        if (loadedPlaylistCovers && Object.keys(loadedPlaylistCovers).length > 0) {
            playlistCovers = loadedPlaylistCovers;
            console.log('[DB] Playlist covers assigned to global variable:', Object.keys(playlistCovers).length, 'covers');
        }
        
        // Refresh all UI elements with loaded metadata from IndexedDB
        await refreshAllUIMetadata();
        
        // Don't render Listen Again here - it will be rendered by init() after folders load
        // This ensures proper timing and avoids race conditions
        // listenAgainRendered = false; // Will be set in init()
        
        // Pre-build the tracks list for later use
        setTimeout(async () => {
            if (Object.keys(playCounts).length > 0) {
                await refreshMostPlayedCache();
            }
        }, 100);
        
    } catch (e) {
        console.error('[DB] Error initializing databases:', e);
    }
}

// Refresh ALL UI elements with metadata loaded from IndexedDB
// This ensures instant updates across all views when metadata is available
// Add debounce state for UI refresh
let uiRefreshDebounceTimer = null;
let uiRefreshInProgress = false;
let uiRefreshPending = false;
let listenAgainRendered = false; // Flag to prevent double rendering
let listenAgainCurrentPage = 0; // Current page for pagination
let listenAgainTotalPages = 1; // Total number of pages

// Calculate items per page based on screen width and sidebar state
function getListenAgainPageSize() {
    const cardWidth = 180;
    const gap = 24;
    const cardTotal = cardWidth + gap;
    
    // Get the actual Listen Again carousel width by measuring
    const listenAgainSection = document.querySelector('.listen-again-container');
    if (listenAgainSection) {
        const sectionWidth = listenAgainSection.offsetWidth;
        // Subtract padding (60px * 2)
        const usableWidth = sectionWidth - 120;
        const items = Math.floor(usableWidth / cardTotal);
        // Return minimum of 4, no maximum - let it show as many as fit
        return Math.max(4, items);
    }
    
    // Fallback: check sidebar state
    const sidebar = document.getElementById("sidebar");
    const isSidebarCollapsed = sidebar && sidebar.classList.contains("collapsed");
    
    // Estimate from viewport - adjust for sidebar state
    let containerWidth = window.innerWidth - 88 - 120; // nav + padding
    if (!isSidebarCollapsed) {
        containerWidth -= 380; // sidebar width
    }
    const items = Math.floor(containerWidth / cardTotal);
    return Math.max(4, items);
}

async function refreshAllUIMetadata() {
    // Debounce: if a refresh is already in progress or recently completed, skip this call
    if (uiRefreshInProgress) {
        uiRefreshPending = true;
        console.log('[MetaUI] Refresh already in progress, queuing request');
        return;
    }
    
    // Check if we recently refreshed (within 100ms) - debounce rapid calls
    if (uiRefreshDebounceTimer) {
        console.log('[MetaUI] Refreshing too fast, skipping');
        return;
    }
    
    uiRefreshInProgress = true;
    uiRefreshDebounceTimer = setTimeout(() => {
        uiRefreshDebounceTimer = null;
    }, 100);
    
    console.log('[MetaUI] Refreshing all UI elements with loaded metadata');
    
    // 1. OPTIMIZATION: Only update currently visible elements, not all tracks
    // This significantly reduces DOM operations during navigation
    
    // Update visible table rows in current view only
    const visibleRows = document.querySelectorAll('#libSongBody tr[id^=\"row-\"]');
    const visibleRowIds = new Set();
    visibleRows.forEach(row => {
        const trackId = row.id.replace('row-', '');
        if (trackId) {
            visibleRowIds.add(trackId);
            const m = trackMetadata[trackId];
            if (m) {
                const titleEl = row.querySelector('.meta-title');
                const artistEl = row.querySelector('.meta-artist');
                const albumEl = row.querySelector('.meta-album');
                if (titleEl) titleEl.innerText = m.title || "Unknown";
                if (artistEl) artistEl.innerText = m.artist || "Unknown";
                if (albumEl) albumEl.innerText = m.album || "Unknown";
            }
        }
    });
    
    // Update visible queue items only
    const visibleQueueItems = document.querySelectorAll('#queueList .queue-item[id^=\"q-item-\"]');
    visibleQueueItems.forEach(qItem => {
        const trackId = qItem.id.replace('q-item-', '');
        if (trackId) {
            const m = trackMetadata[trackId];
            if (m) {
                const tEl = qItem.querySelector('.q-title');
                const aEl = qItem.querySelector('.q-artist');
                if (tEl) tEl.innerText = m.title || "Unknown";
                if (aEl) aEl.innerText = m.artist || "Unknown";
                // Apply album art if available
                if (m.albumArt) {
                    applyArtToUI(trackId, m.albumArt);
                    updateFolderModalArt(trackId);
                }
            }
        }
    });
    
    // Update visible playlist tracks (if a playlist is currently displayed)
    const visiblePlaylistRows = document.querySelectorAll('#playlistSongBody tr[id^=\"row-\"]');
    visiblePlaylistRows.forEach(row => {
        const trackId = row.id.replace('row-', '');
        if (trackId && !visibleRowIds.has(trackId)) {
            const m = trackMetadata[trackId];
            if (m) {
                const titleEl = row.querySelector('.meta-title');
                const artistEl = row.querySelector('.meta-artist');
                const albumEl = row.querySelector('.meta-album');
                if (titleEl) titleEl.innerText = m.title || "Unknown";
                if (artistEl) artistEl.innerText = m.artist || "Unknown";
                if (albumEl) albumEl.innerText = m.album || "Unknown";
            }
        }
    });
    
    // 2. Update queue display
    renderQueue();
    
    // 3. Update player bar and desktop extended view if a track is playing
    if (queue[qIndex]?.id) {
        const currentId = queue[qIndex].id;
        const m = trackMetadata[currentId] || {};
        
        const npTitle = document.getElementById("npTitle");
        const npArtist = document.getElementById("npArtist");
        const npAlbum = document.getElementById("npAlbum");
        const fsTitle = document.getElementById("fsTitle");
        const fsArtist = document.getElementById("fsArtist");
        const fsAlbum = document.getElementById("fsAlbum");
        
        if (npTitle) npTitle.innerText = m.title || queue[currentId]?.title || queue[currentId]?.name || "Unknown Track";
        if (npArtist) npArtist.innerText = m.artist || queue[currentId]?.artist || "Unknown Artist";
        if (npAlbum) npAlbum.innerText = m.album || queue[currentId]?.album || "Unknown Album";
        if (fsTitle) fsTitle.innerText = m.title || queue[currentId]?.title || queue[currentId]?.name || "Unknown Track";
        if (fsArtist) fsArtist.innerText = m.artist || queue[currentId]?.artist || "Unknown Artist";
        if (fsAlbum) fsAlbum.innerText = m.album || queue[currentId]?.album || "Unknown Album";
        
        // Update Desktop Extended View
        const deTitle = document.getElementById("deTitle");
        const deArtist = document.getElementById("deArtist");
        if (deTitle) deTitle.innerText = m.title || queue[currentId]?.title || queue[currentId]?.name || "Unknown Track";
        if (deArtist) deArtist.innerText = m.artist || queue[currentId]?.artist || "Unknown Artist";
        
        // Update album art in player
        if (m.albumArt) {
            applyArtToUI(currentId, m.albumArt);
        }
    }
    
    // 4. Update search results if visible
    if (document.getElementById("searchResults")?.style.display === "block") {
        const searchInput = document.querySelector(".search-input");
        if (searchInput) {
            searchSongsToAdd(searchInput.value || "");
        }
    }
    
    // 5. OPTIMIZATION: Defer color extraction - don't block navigation with heavy processing
    // Color extraction is purely cosmetic and can wait
    if (typeof extractColorsDeferred === 'undefined') {
        extractColorsDeferred = {};
    }
    
    // Only extract colors for currently visible tracks, not all tracks
    const visibleTrackIds = [];
    document.querySelectorAll('[id^=\"row-\"]').forEach(row => {
        const trackId = row.id.replace('row-', '');
        if (trackId && !extractColorsDeferred[trackId]) {
            visibleTrackIds.push(trackId);
            extractColorsDeferred[trackId] = true;
        }
    });
    
    // Process colors in small batches with delays to not block the UI
    if (visibleTrackIds.length > 0) {
        const batchSize = 5;
        let currentIndex = 0;
        
        function processNextBatch() {
            const batch = visibleTrackIds.slice(currentIndex, currentIndex + batchSize);
            if (batch.length === 0) return;
            
            batch.forEach(trackId => {
                const m = trackMetadata[trackId];
                if (m?.albumArt) {
                    extractColorFromAlbumArt(trackId);
                }
            });
            
            currentIndex += batchSize;
            
            // Continue with next batch after a small delay
            if (currentIndex < visibleTrackIds.length) {
                setTimeout(processNextBatch, 50);
            }
        }
        
        // Start processing after a longer delay to not interfere with navigation
        setTimeout(processNextBatch, 500);
    }
    
    console.log('[MetaUI] UI refresh complete');
    
    // Handle debounce/pending state
    uiRefreshInProgress = false;
    if (uiRefreshPending) {
        uiRefreshPending = false;
        // If there was a pending refresh, trigger it after a short delay
        setTimeout(() => refreshAllUIMetadata(), 50);
    }
}

// Start database initialization immediately
initAllDatabases();

// Handle window resize for dynamic Listen Again page size
let resizeTimeout;
window.addEventListener('resize', () => {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
        const pageSize = getListenAgainPageSize();
        // Re-render Listen Again with new page size if on home page
        if (stack.length <= 1) {
            renderListenAgainSection(true).catch(() => {});
        }
    }, 250);
});

// Volume Normalization - Web Audio API
let audioContext = null;
let normEnabled = true;
let normTargetLUFS = -14;
let trackLoudnessCache = {};
let normGainNode = null;
let currentNormGain = 1.0;

const player = document.getElementById("player");

// ========== Unified Image Cache (uses metaDB from above) ==========
const STORE_NAME = 'albumArt';

async function saveImageToDB(key, base64Data) {
    if (!metaDB) await initMetaDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = metaDB.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            
            // Convert base64 to Blob for more efficient storage
            const byteCharacters = atob(base64Data.split(',')[1] || base64Data);
            const byteNumbers = new Array(byteCharacters.length);
            for (let i = 0; i < byteCharacters.length; i++) {
                byteNumbers[i] = byteCharacters.charCodeAt(i);
            }
            const byteArray = new Uint8Array(byteNumbers);
            const blob = new Blob([byteArray], { type: base64Data.split(';')[0].split(':')[1] || 'image/jpeg' });
            
            const request = store.put({ key, data: blob, timestamp: Date.now() });
            
            request.onsuccess = () => resolve(true);
            request.onerror = () => {
                // If quota exceeded, try to clear old entries
                if (request.error.name === 'QuotaExceededError') {
                    clearOldImages().then(() => {
                        // Retry once
                        store.put({ key, data: blob, timestamp: Date.now() }).onsuccess = () => resolve(true);
                        store.put({ key, data: blob, timestamp: Date.now() }).onerror = () => reject(request.error);
                    }).catch(() => reject(request.error));
                } else {
                    reject(request.error);
                }
            };
        } catch (e) {
            reject(e);
        }
    });
}

async function loadImageFromDB(key) {
    if (!metaDB) await initMetaDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = metaDB.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.get(key);
            
            request.onsuccess = () => {
                if (request.result) {
                    // Convert Blob back to base64 data URL
                    const blob = request.result.data;
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(reader.error);
                    reader.readAsDataURL(blob);
                } else {
                    resolve(null);
                }
            };
            request.onerror = () => reject(request.error);
        } catch (e) {
            reject(e);
        }
    });
}

async function clearOldImages() {
    if (!metaDB) await initMetaDB();
    
    return new Promise((resolve, reject) => {
        try {
            const transaction = metaDB.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.index('timestamp').openCursor();
            let deleted = 0;
            const toDelete = 50; // Delete oldest 50 entries when quota exceeded
            
            request.onsuccess = (e) => {
                const cursor = e.target.result;
                if (cursor && deleted < toDelete) {
                    cursor.delete();
                    deleted++;
                    cursor.continue();
                }
            };
            
            transaction.oncomplete = () => resolve(deleted);
            transaction.onerror = () => reject(transaction.error);
        } catch (e) {
            reject(e);
        }
    });
}

// Initialize IndexedDB on load - handled by initAllDatabases()

// Helper function to load album art from IndexedDB
async function loadAlbumArtFromDB(albumName) {
    try {
        const art = await loadImageFromDB(`album_${albumName}`);
        return art;
    } catch (e) {
        return null;
    }
}

// ========== End IndexedDB Image Cache ==========

// --- EQUALIZER VARS ---
let audioCtx;
let sourceNode;
let bassNode;
let trebleNode;
let eqBands = [];
let limiterNode = null;
const eqFrequencies = [60, 170, 310, 600, 1000, 3000, 6000, 12000, 14000, 16000];

// Initialize EQ state with defaults, reset if cached state is invalid
let eqState = JSON.parse(localStorage.getItem('goot_eq_state') || '{"bass":0,"treble":0,"bands":[0,0,0,0,0,0,0,0,0,0]}');

// Validate and reset EQ state if it has invalid values
if (eqState.bass < 0 || eqState.bass > 100 || eqState.treble < 0 || eqState.treble > 100) {
    eqState = { bass: 0, treble: 0, bands: [0,0,0,0,0,0,0,0,0,0] };
    localStorage.setItem('goot_eq_state', JSON.stringify(eqState));
}

// Reset EQ state to ensure clean start (fixes random audio fluctuation)
function resetEqState() {
    eqState = { bass: 0, treble: 0, bands: [0,0,0,0,0,0,0,0,0,0] };
    localStorage.setItem('goot_eq_state', JSON.stringify(eqState));
    return eqState;
}

// Call reset on first load if no valid saved state
if (!localStorage.getItem('goot_eq_state')) {
    resetEqState();
}

// Helper function to filter out m3u playlist files
function filterM3uFiles(items) {
    return items.filter(item => !item.id?.toLowerCase()?.endsWith('.m3u') && !item.name?.toLowerCase()?.endsWith('.m3u'));
}

const EQ_PRESETS = {
    flat: { bass: -12, treble: -12, bands: [0,0,0,0,0,0,0,0,0,0] },
    rock: { bass: -6, treble: -6, bands: [1,1,0,0,0,0,0,0,1,1] },
    pop: { bass: -12, treble: -12, bands: [1,1,1,0,0,0,0,0,0,0] },
    jazz: { bass: -6, treble: -12, bands: [1,1,0,0,0,0,0,0,0,1] },
    classical: { bass: -6, treble: -12, bands: [1,1,0,0,0,0,0,0,1,1] },
    bass: { bass: -3, treble: -12, bands: [2,1,1,0,0,0,0,0,0,0] },
    vocal: { bass: -12, treble: -6, bands: [-1,-1,0,0,1,1,1,0,0,0] }
};

// --- Panic Mode Variables ---
let pPressCount = 0;
let pPressTimer = null;
const PANIC_DELAY = 1000; // 1 second window for 3 presses

// --- Panic Mode Function ---
function triggerPanicMode() {
    // Open Google Classroom in a new tab/window
    window.open('https://classroom.google.com/', '_blank');
    
    // Close current tab
    window.close();
    
    // If window.close fails (browsers may block it), redirect to classroom
    setTimeout(() => {
        window.location.href = 'https://classroom.google.com/';
    }, 100);
}

// --- Keydown Listener ---
document.addEventListener('keydown', (e) => {
    // Don't trigger if user is typing in an input field
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
    
    // Panic mode: press 'p' 3 times quickly
    if (e.key === 'p' || e.key === 'P') {
        pPressCount++;
        
        if (pPressCount === 1) {
            // Start timer for first press
            pPressTimer = setTimeout(() => {
                pPressCount = 0;
            }, PANIC_DELAY);
        } else if (pPressCount >= 3) {
            // 3 presses detected within time window
            triggerPanicMode();
            pPressCount = 0;
            if (pPressTimer) {
                clearTimeout(pPressTimer);
                pPressTimer = null;
            }
        }
    }
    
    if (e.key === ' ' || e.code === 'Space') {
        e.preventDefault(); // Prevent scrolling
        togglePlay();
    }
});

function initEqualizerUI() {
    // Restore sliders
    document.getElementById('bassSlider').value = eqState.bass;
    document.getElementById('bassValue').innerText = eqState.bass + '%';
    
    document.getElementById('trebleSlider').value = eqState.treble;
    document.getElementById('trebleValue').innerText = eqState.treble + '%';
    
    // Generate sliders
    const container = document.getElementById('eqSliders');
    container.innerHTML = '';
    eqFrequencies.forEach((freq, index) => {
        const val = eqState.bands[index] || 0;
        const col = document.createElement('div');
        col.className = 'eq-slider-col';
        col.innerHTML = `
            <div class="eq-slider-track">
                <input type="range" class="eq-range" min="-12" max="12" step="0.5" value="${val}" 
                       oninput="updateEqBand(${index}, this.value)">
            </div>
            <div class="eq-freq-label">${freq >= 1000 ? (freq/1000)+'k' : freq}</div>
        `;
        container.appendChild(col);
    });
}

function initAudioContext() {
    if (audioCtx) return audioCtx;
    try {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        audioCtx = new AudioContext();
        audioContext = audioCtx; // Sync for normalization code
        
        // Resume context if it's suspended (required for autoplay policy)
        if (audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
        
        sourceNode = audioCtx.createMediaElementSource(player);
        
        // 1. Bass Node (Low Shelf)
        bassNode = audioCtx.createBiquadFilter();
        bassNode.type = 'lowshelf';
        bassNode.frequency.value = 100;
        bassNode.gain.value = (eqState.bass / 100) * 12;
        
        // 2. Treble Node (High Shelf)
        trebleNode = audioCtx.createBiquadFilter();
        trebleNode.type = 'highshelf';
        trebleNode.frequency.value = 10000;
        trebleNode.gain.value = (eqState.treble / 100) * 12;

        // Chain Source -> Bass -> Treble
        sourceNode.connect(bassNode);
        bassNode.connect(trebleNode);
        
        let prevNode = trebleNode;

        // 3. EQ Bands (Peaking)
        eqBands = [];
        eqFrequencies.forEach((freq, idx) => {
            const band = audioCtx.createBiquadFilter();
            band.type = 'peaking';
            band.frequency.value = freq;
            band.Q.value = 1;
            band.gain.value = eqState.bands[idx] || 0;
            
            prevNode.connect(band);
            prevNode = band;
            eqBands.push(band);
        });

        // 4. Volume Normalization Gain Node (inserted before limiter)
        normGainNode = audioCtx.createGain();
        normGainNode.gain.value = 1.0;
        prevNode.connect(normGainNode);
        prevNode = normGainNode;

        // 5. Limiter (DynamicsCompressor) to prevent clipping
        limiterNode = audioCtx.createDynamicsCompressor();
        limiterNode.threshold.setValueAtTime(-1, audioCtx.currentTime); // Less aggressive threshold
        limiterNode.knee.setValueAtTime(0, audioCtx.currentTime);
        limiterNode.ratio.setValueAtTime(20, audioCtx.currentTime); // Higher ratio for hard limiting
        limiterNode.attack.setValueAtTime(0.001, audioCtx.currentTime);
        limiterNode.release.setValueAtTime(0.1, audioCtx.currentTime);
        
        // 6. Final Gain
        const finalGain = audioCtx.createGain();
        finalGain.gain.value = 1.0;

        // Connect chain to destination
        prevNode.connect(limiterNode);
        limiterNode.connect(finalGain);
        finalGain.connect(audioCtx.destination);
        
        return audioCtx;
    } catch(e) {
        console.warn("Web Audio API failed or not supported:", e);
        return null;
    }
}

function updateBass(val) {
    val = parseInt(val);
    eqState.bass = val;
    if(bassNode) {
        // Map 0-100% to 0-12dB
        bassNode.gain.setTargetAtTime((val / 100) * 12, audioCtx.currentTime, 0.01);
    }
    document.getElementById('bassValue').innerText = val + '%';
    saveEqState();
}

function updateTreble(val) {
    val = parseInt(val);
    eqState.treble = val;
    if(trebleNode) {
        // Map 0-100% to 0-12dB
        trebleNode.gain.setTargetAtTime((val / 100) * 12, audioCtx.currentTime, 0.01);
    }
    document.getElementById('trebleValue').innerText = val + '%';
    saveEqState();
}

function updateEqBand(index, val) {
    val = parseFloat(val);
    eqState.bands[index] = val;
    if(eqBands[index]) eqBands[index].gain.value = val;
    saveEqState();
}

function applyEqPreset(name) {
    const p = EQ_PRESETS[name];
    if(!p) return;
    
    // Map preset dB values to 0-100% for bass/treble
    // Using reduced range (0-6dB) to prevent clipping
    const bassPercent = Math.round(((p.bass + 12) / 24) * 100);
    const treblePercent = Math.round(((p.treble + 12) / 24) * 100);
    
    // Update State
    eqState.bass = bassPercent;
    eqState.treble = treblePercent;
    eqState.bands = [...p.bands];
    
    // Update UI
    document.getElementById('bassSlider').value = bassPercent;
    document.getElementById('bassValue').innerText = bassPercent + '%';
    document.getElementById('trebleSlider').value = treblePercent;
    document.getElementById('trebleValue').innerText = treblePercent + '%';
    
    const sliders = document.querySelectorAll('#eqSliders .eq-range');
    sliders.forEach((input, i) => {
        if(i < eqState.bands.length) input.value = eqState.bands[i];
    });

    // Update Audio
    if(bassNode) bassNode.gain.setTargetAtTime((bassPercent / 100) * 12, audioCtx.currentTime, 0.01);
    if(trebleNode) trebleNode.gain.setTargetAtTime((treblePercent / 100) * 12, audioCtx.currentTime, 0.01);
    eqBands.forEach((b, i) => {
        if(b) b.gain.value = eqState.bands[i];
    });
    
    saveEqState();
}

// Reset equalizer to default (flat) settings
function resetEqualizer() {
    // Reset state to defaults
    eqState = { bass: 0, treble: 0, bands: [0,0,0,0,0,0,0,0,0,0] };
    
    // Update UI
    document.getElementById('bassSlider').value = 0;
    document.getElementById('bassValue').innerText = '0%';
    document.getElementById('trebleSlider').value = 0;
    document.getElementById('trebleValue').innerText = '0%';
    
    const sliders = document.querySelectorAll('#eqSliders .eq-range');
    sliders.forEach((input) => {
        input.value = 0;
    });
    
    // Reset preset dropdown to flat
    document.querySelector('.eq-presets select').value = 'flat';
    
    // Update Audio
    if(bassNode) bassNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
    if(trebleNode) trebleNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.01);
    eqBands.forEach((b) => {
        if(b) b.gain.value = 0;
    });
    
    saveEqState();
}

function saveEqState() {
    localStorage.setItem('goot_eq_state', JSON.stringify(eqState));
}

async function getFolderContents(parentId) {
    const res = await fetch(`${WORKER_URL}?list=${parentId}`);
    if (!res.ok) {
        throw new Error(`Failed to fetch folder contents (status ${res.status})`);
    }
    const json = await res.json();
    return json.files || json || [];
}

function setTheme(theme) {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('goot_theme', theme);
    
    const toggle = document.getElementById('themeToggle');
    if (toggle) toggle.checked = (theme === 'light');
    
    const label = document.getElementById('themeModeLabel');
    if (label) {
        label.textContent = theme === 'dark' ? 'Light Mode' : 'Dark Mode';
    }
}
function toggleTheme() {
    const current = document.documentElement.getAttribute('data-theme') || 'dark';
    const newTheme = current === 'dark' ? 'light' : 'dark';
    setTheme(newTheme);
    
    // Update toggle visual state
    const toggle = document.getElementById('themeToggle');
    const track = toggle?.parentElement.querySelector('.simple-toggle-track');
    if (toggle) toggle.checked = (newTheme === 'light');
}
const savedTheme = localStorage.getItem('goot_theme') || 'dark';
setTheme(savedTheme);

function initPlaylistSortable() {
    if (playlistSortable) playlistSortable.destroy();
    playlistSortable = new Sortable(document.getElementById('playlistSongBody'), {
        animation: 200,
        handle: '.playlist-drag-handle',
        ghostClass: 'sortable-ghost',
        onEnd: (evt) => {
            if (evt.oldIndex === evt.newIndex) return;
            const tracks = playlists[currentPlaylistName];
            const movedItem = tracks.splice(evt.oldIndex, 1)[0];
            tracks.splice(evt.newIndex, 0, movedItem);
            localStorage.setItem('goot_playlists', JSON.stringify(playlists));
            const currentId = queue[qIndex]?.id;
            renderTrackTable(tracks, document.getElementById("playlistSongBody"), true, currentPlaylistName, true, false);
            if (tracks.length > 0) {
                loadMetaAndArt(tracks[0].id, '');
            }
            if (currentQueueSource === `playlist:${currentPlaylistName}`) {
                queue = tracks.map(e => ({id: e.id}));
                const newIdx = currentId ? queue.findIndex(t => t.id === currentId) : -1;
                if (newIdx !== -1) qIndex = newIdx;
                // Defer renderQueue for smoother UI
                setTimeout(() => renderQueue(), 0);
            }
            initPlaylistSortable();
        }
    });
}

// Save playlist covers to both IndexedDB (primary) - helper function  
function savePlaylistCovers() {
    // Save to IndexedDB
    savePlaylistCoversToDB(playlistCovers).catch(err => {
        console.warn('[DB] Failed to save playlist covers to IndexedDB:', err);
    });
}

async function init() {
    // Wait for IndexedDB to be ready before doing anything
    if (!metaDBReady) {
        console.log('[Init] Waiting for IndexedDB to initialize...');
        await new Promise(resolve => {
            const checkDB = setInterval(() => {
                if (metaDBReady) {
                    clearInterval(checkDB);
                    resolve();
                }
            }, 50);
            // Timeout after 10 seconds
            setTimeout(() => {
                clearInterval(checkDB);
                resolve();
            }, 10000);
        });
    }
    
    // Initialize default settings in localStorage if not set
    if (localStorage.getItem('goot_norm_enabled') === null) {
        localStorage.setItem('goot_norm_enabled', 'true');
    }
    if (localStorage.getItem('goot_album_color') === null) {
        localStorage.setItem('goot_album_color', 'true');
    }
    
    // Load normalization settings
    loadNormSettings();
    
    initEqualizerUI();
    updateTheme(localStorage.getItem('goot_accent') || '#ff0000');
    
    // Set album color toggle state
    document.getElementById('albumColorToggle').checked = localStorage.getItem('goot_album_color') === 'true';
    
    if (window.innerWidth <= 768) {
        document.getElementById("sidebar").classList.add("collapsed");
    }
    
    new Sortable(document.getElementById('queueList'), {
        animation: 200,
        handle: '.queue-drag-handle',
        ghostClass: 'sortable-ghost',
        dragClass: 'queue-sort-drag',
        onEnd: (evt) => {
            const item = queue.splice(evt.oldIndex, 1)[0];
            queue.splice(evt.newIndex, 0, item);
            if (qIndex === evt.oldIndex) qIndex = evt.newIndex;
            currentQueueSource = null;
            // Defer renderQueue for smoother drag end experience
            setTimeout(() => renderQueue(), 0);
        }
    });
    
    // Desktop extended view queue sorting
    new Sortable(document.getElementById('deQueueList'), {
        animation: 200,
        handle: '.queue-drag-handle',
        ghostClass: 'sortable-ghost',
        dragClass: 'queue-sort-drag',
        onEnd: (evt) => {
            const item = queue.splice(evt.oldIndex, 1)[0];
            queue.splice(evt.newIndex, 0, item);
            if (qIndex === evt.oldIndex) qIndex = evt.newIndex;
            currentQueueSource = null;
            // Defer renderQueue for smoother drag end experience
            setTimeout(() => renderQueue(), 0);
        }
    });
    
    renderPlaylists();
    
    // Load folder grid and Listen Again section IN PARALLEL
    // Both will render simultaneously on the home page
    const loadFoldersPromise = loadFolders(ROOT_ID);
    
    // Ensure playCounts is loaded (should already be from initAllDatabases)
    if (Object.keys(playCounts).length === 0) {
        await loadPlayCounts();
    }
    
    // Load album counts and pinned items (only if not already loaded by loadPlayCounts)
    if (Object.keys(albumPlayCounts).length === 0) {
        await loadAlbumCounts();
    }
    loadPinnedItems();
    
    // Start Listen Again rendering in background (non-blocking)
    renderListenAgainSection().catch(() => {});
    
    // Wait for folders to load first (this is the slow part)
    try {
        await loadFoldersPromise;
    } catch (e) {
        console.error('Error loading folders:', e);
    }
    
    // Hide loading overlay NOW - folders are ready
    const loadingOverlay = document.getElementById('initialLoading');
    if (loadingOverlay) {
        loadingOverlay.style.display = 'none';
    }
    
    // Hide folder grid skeleton and show actual grid
    const folderGridSkeleton = document.getElementById('folderGridSkeleton');
    if (folderGridSkeleton) {
        folderGridSkeleton.style.display = 'none';
    }
    
    // Show folder grid
    const grid = document.getElementById('folderGrid');
    if (grid) {
        grid.style.display = '';
    }
    
    // Hide Listen Again skeleton and show actual content
    const listenAgainSkeleton = document.getElementById('listenAgainSkeleton');
    const listenAgainContent = document.getElementById('listenAgainContent');
    if (listenAgainSkeleton) {
        listenAgainSkeleton.style.display = 'none';
    }
    if (listenAgainContent) {
        listenAgainContent.style.display = '';
    }
    
    // Show Listen Again section ONLY on root folder (handle both elements)
    document.querySelectorAll('#listenAgainSection').forEach(el => {
        el.style.display = stack.length <= 1 ? 'block' : 'none';
    });
    
    // FIX: After everything is loaded, ensure Listen Again is properly rendered
    // Sometimes on first load the data isn't ready yet, so we re-check after a delay
    setTimeout(async () => {
        // Check if Listen Again shows empty but there should be content
        const hasPlayCounts = Object.keys(playCounts).length > 0;
        const hasPinnedItems = (pinnedItems.tracks?.length > 0) || (pinnedItems.albums?.length > 0) || (pinnedItems.playlists?.length > 0);
        
        if (hasPlayCounts || hasPinnedItems) {
            // Check if section is showing empty state
            const containers = document.querySelectorAll('#listenAgainSection');
            let showingEmpty = false;
            containers.forEach(c => {
                const emptyState = c.querySelector('.listen-again-empty');
                if (emptyState && emptyState.style.display !== 'none') {
                    showingEmpty = true;
                }
            });
            
            // If showing empty but should have content, re-render
            if (showingEmpty) {
                console.log('[ListenAgain] Re-rendering - data loaded but showing empty');
                listenAgainRendered = false;
                await renderListenAgainSection(true);
            }
        }
    }, 500);
    
    const breadcrumb = document.getElementById('breadcrumb');
    if (breadcrumb) {
        breadcrumb.style.display = 'flex';
    }
    
    // Show folder actions based on current navigation depth
    const folderActions = document.getElementById('folderActions');
    if (folderActions) {
        if (stack.length > 1) {
            folderActions.style.display = 'flex';
        } else {
            folderActions.style.display = 'none';
        }
    }
    
    // Update queue button visibility based on initial queue state
    }

async function loadFolders(id) {
    // Show Listen Again when navigating back to home
    if (stack.length <= 1) {
        document.querySelectorAll('#listenAgainSection').forEach(el => {
            el.style.display = '';
        });
        // Re-render Listen Again to show updated pinned items
        renderListenAgainSection(true).catch(() => {});
    } else {
        // Hide Listen Again when navigating to subfolders (only show at root)
        document.querySelectorAll('#listenAgainSection').forEach(el => {
            el.style.display = 'none';
        });
    }
    
    const grid = document.getElementById("folderGrid");
    const listBody = document.getElementById("libSongBody");
    
    // Keep hidden until init() shows everything together
    grid.style.display = 'none';
    listBody.innerHTML = ''; 

    let files = [];
    try {
        files = await getFolderContents(id);
        files = files.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));
        
        // Auto-detect folder cover from images in folder
        const currentFolderName = stack[stack.length - 1].name;
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.heic', '.heif', '.bmp', '.svg'];
        const coverImage = files.find(f => {
            const name = f.name.toLowerCase();
            return f.mimeType.startsWith('image/') || 
                   imageExtensions.some(ext => name.endsWith(ext));
        });
        
        if (coverImage && currentFolderName) {
            const mimeType = getImageMimeType(coverImage.name, coverImage.mimeType);
            playlistCovers[currentFolderName] = getImageUrl(coverImage.id, mimeType);
            savePlaylistCovers();
        }
        
        grid.innerHTML = "";
        
        if (files.length === 0) {
            grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:40px;opacity:0.5;">Folder is empty</div>';
        }

        files.filter(f => f.mimeType === 'application/vnd.google-apps.folder').forEach(f => {
            const card = document.createElement("div");
            card.className = "folder-card playlist-card";
            card.dataset.folderId = f.id;
            card.dataset.folderName = f.name;

            // Check if this is a subfolder (not the root level)
            const isSubfolder = stack.length > 1;
            const playOverlay = isSubfolder ? `
                <div class="play-overlay">
                    <div class="control-group">
                        <div class="control-btn" onclick="playFolderFromCard(event, '${f.id}')">
                            <i class="fa-solid fa-play"></i>
                        </div>
                        <div class="control-btn shuffle" onclick="shuffleFolderFromCard(event, '${f.id}')">
                            <i class="fa-solid fa-shuffle"></i>
                        </div>
                        <div class="btn-label">Shuffle Play</div>
                    </div>
                </div>
            ` : '';

            card.innerHTML = `
                <div class="folder-art" id="f-art-${f.id}"><i class="fa-solid fa-folder" style="opacity:0.2;font-size:40px;"></i></div>
                <div class="folder-info"><span>${f.name}</span></div>
                ${playOverlay}
                ${isSubfolder ? `
                <button class="pin-btn labeled-pin-btn" data-folder-id="${f.id}" data-folder-name="${encodeURIComponent(f.name)}" title="Pin to Listen Again">
                    <i class="fa-solid fa-heart"></i>
                    <span>Pin</span>
                </button>
                ` : ''}
            `;
            
            // Attach pin button click handler programmatically
            if (isSubfolder) {
                const pinBtn = card.querySelector('.pin-btn');
                pinBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    const folderId = pinBtn.dataset.folderId;
                    const folderName = pinBtn.dataset.folderName;
                    
                    // Get the cover art from the folder's art element
                    const artContainer = card.querySelector('.folder-art');
                    const artImg = artContainer.querySelector('img');
                    let art = '';
                    if (artImg && artImg.src && !artImg.src.includes('fa-folder')) {
                        art = artImg.src;
                    }
                    
                    handlePinClickWithArt(e, folderId, folderName, art);
                });
            }
            
            card.onclick = (e) => {
                // Prevent navigating into folder if clicking on play/shuffle/pin buttons
                const target = e.target;
                if (target.closest('.control-btn') || target.closest('.pin-btn') || target.closest('.labeled-pin-btn')) {
                    // Don't navigate - the button will handle its own action
                    return;
                }
                stack.push({id:f.id,name:f.name}); loadFolders(f.id);
            };
            grid.appendChild(card);
            // Faster staggered loading - batches of 5 cards with 20ms delay
            const cardIndex = grid.querySelectorAll('.folder-card').length - 1;
            setTimeout(() => card.classList.add('loaded'), Math.floor(cardIndex / 5) * 20);
        });
        
        // Fetch folder art in batches to reduce API calls
        const folderIds = files.filter(f => f.mimeType === 'application/vnd.google-apps.folder').map(f => f.id);
        fetchFolderArtBatch(folderIds);
        
        const tracks = files.filter(f => f.mimeType.includes('audio'));
        renderTrackTable(tracks, listBody);
        
        document.getElementById("viewTitle").innerText = stack[stack.length-1].name;
        updateBreadcrumbs();
    } catch(e) {
        console.error('Error loading folders:', e);
        grid.innerHTML = `<div style="grid-column:1/-1;text-align:center;padding:40px;color:#ff4444;"><i class="fa-solid fa-triangle-exclamation" style="font-size:32px;margin-bottom:12px;"></i><br>Error loading content.<br><small>${e.message || "Network Error"}</small><br><button class="action-btn" style="margin-top:16px;" onclick="loadFolders('${id}')">Retry</button></div>`;
    }
    
    // Refresh all UI elements with any newly loaded metadata from IndexedDB
    await refreshAllUIMetadata();
    
    // Show the grid after loading completes (for non-initial loads via goHome)
    // For initial load, init() handles showing everything together
    if (grid) {
        grid.style.display = '';
    }
    if (listBody) {
        listBody.style.display = '';
    }
    const breadcrumb = document.getElementById('breadcrumb');
    if (breadcrumb) {
        breadcrumb.style.display = 'flex';
    }
    // Show folder actions based on current navigation depth
    const folderActions = document.getElementById('folderActions');
    if (folderActions) {
        if (stack.length > 1) {
            folderActions.style.display = 'flex';
        } else {
            folderActions.style.display = 'none';
        }
    }
    // Show Listen Again section when at root folder (after navigating back home)
    if (stack.length <= 1) {
        document.querySelectorAll('#listenAgainSection').forEach(el => {
            el.style.display = 'block';
        });
    }
}

// Batch fetch folder art to reduce API calls
async function fetchFolderArtBatch(folderIds) {
    if (!folderIds || folderIds.length === 0) return;
    
    // Process in parallel batches
    const batchSize = 5;
    for (let i = 0; i < folderIds.length; i += batchSize) {
        const batch = folderIds.slice(i, i + batchSize);
        await Promise.all(batch.map(fid => fetchFolderArt(fid)));
    }
}

async function fetchFolderArt(fid) {
    const container = document.getElementById(`f-art-${fid}`);
    if (!container) {
        console.log('Container not found for folder:', fid);
        return;
    }
    
    try {
        const files = await getFolderContents(fid);
        // Look for any image file, not just files with "cover" in the name
        const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.heic', '.heif', '.bmp', '.svg'];
        const cover = files.find(f => {
            const name = f.name.toLowerCase();
            return f.mimeType.startsWith('image/') || 
                   imageExtensions.some(ext => name.endsWith(ext));
        });
        
        if (cover) {
            const mimeType = getImageMimeType(cover.name, cover.mimeType);
            const imageUrl = getImageUrl(cover.id, mimeType);
            console.log('Loading cover for folder', fid, ':', cover.name, '->', imageUrl);
            
            const img = new Image();
            img.onload = () => {
                console.log('Cover loaded for folder:', fid);
                img.classList.add('loaded');
                const icon = container.querySelector('i');
                if (icon) icon.style.opacity = "0";
            };
            img.onerror = () => {
                console.error('Failed to load cover for folder', fid, ':', imageUrl);
            };
            img.src = imageUrl;
            container.appendChild(img);
        } else {
            console.log('No cover image found for folder:', fid, '- files:', files.map(f => f.name));
        }
    } catch(e) {
        console.error('Error fetching folder art:', e);
    }
}

function renderTrackTable(tracks, container, isPlaylist = false, pName = "", animate = true, loadMeta = true) {
    container.innerHTML = "";
    // Filter out m3u playlist files
    tracks = filterM3uFiles(tracks);
    
    tracks.forEach((t, i) => {
        const m = trackMetadata[t.id] || {title: t.name || "...", artist: "...", album: "..."};
        const tr = document.createElement("tr");
        tr.className = "song-row";
        tr.id = `row-${t.id}`;
        
        // Check if track is pinned
        const pinned = isPinned('tracks', t.id);
        
        // Add drag handle column for playlist view
        const handleColumn = isPlaylist ? `<td class="playlist-drag-handle-cell" style="padding:0;"><div class="playlist-drag-handle"><i class="fa-solid fa-grip-vertical"></i></div></td>` : '';
        
        tr.innerHTML = `
            ${handleColumn}
            <td style="width:64px;"><div class="track-art-${t.id}" style="width:48px;height:48px;border-radius:8px;background:var(--md-sys-color-surface-variant);overflow:hidden;display:flex;align-items:center;justify-content:center;position:relative;">
                ${pinned ? '<div class="pinned-badge" style="position:absolute;top:-4px;right:-4px;width:20px;height:20px;"><i class="fa-solid fa-heart"></i></div>' : ''}
                <i class="fa-solid fa-music" style="opacity:0.2"></i>
            </div></td>
            <td><div class="meta-title truncate" style="font-weight:600;font-size:14px;">${m.title}</div><div class="meta-artist" style="font-size:12px;opacity:0.5">${m.artist}</div></td>
            <td class="meta-album truncate" style="font-size:12px;opacity:0.5">${m.album}</td>
            <td style="text-align:right">
                <div class="track-actions" style="display:flex;gap:8px;justify-content:flex-end;">
                    ${pinned ? `
                    <button class="m3-btn m3-btn-tonal" onclick="event.stopPropagation(); unpinTrackFromRow('${t.id}')" title="Remove from Listen Again">
                        <i class="fa-solid fa-xmark"></i>
                        <span>Remove</span>
                    </button>
                    ` : `
                    <button class="m3-btn m3-btn-tonal" onclick="event.stopPropagation(); togglePinTrack('${t.id}')" title="Pin to Listen Again">
                        <i class="fa-solid fa-heart"></i>
                        <span>Pin</span>
                    </button>
                    `}
                    <button class="m3-btn m3-btn-tonal" onclick="event.stopPropagation(); addToQueue('${t.id}')" title="Add to Queue">
                        <i class="fa-solid fa-list" style="font-size:16px;"></i>
                        <span>Add to Queue</span>
                    </button>
                    <button class="m3-btn m3-btn-tonal" onclick="event.stopPropagation(); ${isPlaylist ? `removeFromPlaylist(event, '${pName}', '${t.id}')` : `openPlaylistModal(event, '${t.id}')`}" title="${isPlaylist ? 'Remove from Playlist' : 'Add to Playlist'}">
                        <i class="fa-solid ${isPlaylist ? 'fa-minus' : 'fa-bookmark'}" style="font-size:16px;"></i>
                        <span>${isPlaylist ? 'Remove' : 'Add to Playlist'}</span>
                    </button>
                </div>
            </td>`;
        
        // IMMEDIATELY apply album art if available in trackMetadata (loaded from IndexedDB)
        if (m.albumArt) {
            setTimeout(() => applyArtToUI(t.id, m.albumArt), 0);
        }
        
        tr.onclick = e => {
            // Don't trigger if clicking on drag handle or action button
            if(!e.target.closest('button') && !e.target.closest('.playlist-drag-handle')) {
                queue = tracks.map(track => ({id: track.id}));
                qIndex = i;
                currentQueueSource = isPlaylist ? `playlist:${pName}` : null;
                // play() will handle renderQueue() deferred
                play(i);
            }
        };
        container.appendChild(tr);
    });
    
    // Trigger staggered animation for song rows
    const rows = container.querySelectorAll('.song-row');
    console.log('[Animation] Found', rows.length, 'song rows');
    
    // Safety: ensure all rows become visible after animation completes
    const safetyTimeout = setTimeout(() => {
        rows.forEach(row => row.classList.add('loaded'));
        console.log('[Animation] Safety timeout: forced loaded class on all rows');
    }, 500 + (rows.length * 30));
    
    if (animate) {
        rows.forEach((row, index) => {
            setTimeout(() => {
                row.classList.add('loaded');
                clearTimeout(safetyTimeout); // Cancel safety if animation works
                console.log('[Animation] Added loaded to row', index);
            }, 30 * index);
        });
    } else {
        clearTimeout(safetyTimeout);
        rows.forEach(row => row.classList.add('loaded'));
    }
    
    // Load metadata in parallel (all at once) - only if loadMeta is true
    if (loadMeta) {
        loadMetadataSequentially(tracks, 0);
    }
}

// Wrapper function for rendering playlist tracks (used by openPinnedPlaylistFromCard)
function renderPlaylistTracks(tracks, container, playlistName) {
    console.log('[Playlist] Calling renderTrackTable with', tracks.length, 'tracks');
    renderTrackTable(tracks, container, true, playlistName, true, true);
}

async function loadMetadataSequentially(tracks, index) {
    // No longer sequential - load all at once in parallel, but skip if already loading
    if (index === 0 && tracks.length > 0) {
        // Set bulk loading flag to prevent color extraction lag
        isBulkMetadataLoading = true;
        
        // Add performance optimization class to main container
        const mainContainer = document.querySelector('.main-container');
        if (mainContainer) {
            mainContainer.classList.add('bulk-loading');
        }
        
        // Filter to only tracks that actually need metadata loading
        const tracksNeedingLoad = tracks.filter(t => !pendingMetadataLoads.has(t.id) && !trackMetadata[t.id]?.albumArt);
        if (tracksNeedingLoad.length > 0) {
            const loadPromise = Promise.all(tracksNeedingLoad.map(t => loadMetaAndArt(t.id, t.name || '')));
            
            // Wait for all loads to complete, then clear bulk loading flag
            loadPromise.then(() => {
                // Small delay to let final UI updates complete
                setTimeout(() => {
                    isBulkMetadataLoading = false;
                    // Remove performance optimization class
                    if (mainContainer) {
                        mainContainer.classList.remove('bulk-loading');
                    }
                    // Batch extract colors for any tracks that need it
                    batchExtractColors(tracksNeedingLoad.map(t => t.id));
                }, 200);
            }).catch(() => {});
        } else {
            // No tracks needed loading, clear flag immediately
            isBulkMetadataLoading = false;
            if (mainContainer) {
                mainContainer.classList.remove('bulk-loading');
            }
        }
    }
}

// Batch extract colors for multiple tracks (called after bulk loading completes)
function batchExtractColors(trackIds) {
    if (trackIds.length === 0) return;
    
    // Only process tracks that need color extraction
    const tracksNeedingColor = trackIds.filter(id => {
        const album = trackMetadata[id]?.album;
        return album && album !== "Unknown";
    });
    
    if (tracksNeedingColor.length === 0) return;
    
    // Process in small batches with delays to avoid UI freeze
    const batchSize = 3;
    let currentIndex = 0;
    
    function processNextBatch() {
        const batch = tracksNeedingColor.slice(currentIndex, currentIndex + batchSize);
        if (batch.length === 0) return;
        
        batch.forEach(id => extractColorFromAlbumArt(id));
        
        currentIndex += batchSize;
        if (currentIndex < tracksNeedingColor.length) {
            // Schedule next batch
            setTimeout(processNextBatch, 100);
        }
    }
    
    // Start processing
    processNextBatch();
}

async function loadMetaAndArt(id, name) {
    if (pendingMetadataLoads.has(id)) return;
    
    const existingMeta = trackMetadata[id];
    
    // Check if we should return early (metadata AND album art already loaded)
    if (existingMeta && existingMeta.title !== "Unknown" && existingMeta.artist !== "Unknown" && existingMeta.albumArt) {
        // Album art already in memory, apply it
        applyArtToUI(id, existingMeta.albumArt);
        updateFolderModalArt(id);
        updatePlaylistCoverIfNeeded(id, existingMeta.albumArt);
        return;
    }
    
    // Check album art caches first (before checking metadata)
    const album = existingMeta?.album || "Unknown";
    
    if (album && album !== "Unknown" && albumArtCache[album]) {
        applyArtToUI(id, albumArtCache[album]);
        updateFolderModalArt(id);
        updatePlaylistCoverIfNeeded(id, albumArtCache[album]);
        // Also save to trackMetadata for future reference
        if (existingMeta) {
            existingMeta.albumArt = albumArtCache[album];
            saveTrackMetadataToDB(id, existingMeta).catch(() => {});
        }
        return;
    }
    
    if (tempArtCache[id]) {
        applyArtToUI(id, tempArtCache[id]);
        updateFolderModalArt(id);
        updatePlaylistCoverIfNeeded(id, tempArtCache[id]);
        // Also save to trackMetadata for future reference
        if (existingMeta) {
            existingMeta.albumArt = tempArtCache[id];
            saveTrackMetadataToDB(id, existingMeta).catch(() => {});
        }
        return;
    }
    
    // Try to load from IndexedDB if not in memory cache
    if (album && album !== "Unknown") {
        try {
            const dbArt = await loadImageFromDB(`album_${album}`);
            if (dbArt) {
                albumArtCache[album] = dbArt;
                applyArtToUI(id, dbArt);
                updateFolderModalArt(id);
                updatePlaylistCoverIfNeeded(id, dbArt);
                // Also save to trackMetadata for future reference
                if (existingMeta) {
                    existingMeta.albumArt = dbArt;
                    saveTrackMetadataToDB(id, existingMeta).catch(() => {});
                }
                return;
            }
        } catch (e) {
            console.warn('[MetaDB] Failed to load album art from DB:', e);
        }
    }
    
    // If we get here, we need to extract metadata (no album art found anywhere)
    pendingMetadataLoads.add(id);
    
    try {
        const res = await fetch(`${WORKER_URL}?id=${id}`, {
            mode: 'cors',
            credentials: 'omit',
            cache: 'no-store',
            headers: { 'Range': 'bytes=0-4194303' }  // 4 MB
        });
        if(!res.ok) throw new Error("Fetch failed");
        const buf = await res.arrayBuffer();
        jsmediatags.read(new Blob([buf]), {
            onSuccess: tag => {
                const m = {
                    title: tag.tags.title || name || "Unknown",
                    artist: tag.tags.artist || "Unknown",
                    album: tag.tags.album || "Unknown",
                    genre: tag.tags.genre || "",
                    year: tag.tags.year || "",
                    composer: tag.tags.composer || "",
                    track: tag.tags.track || ""
                };
                
                // Only update and save if this is new metadata or has changed
                const existing = trackMetadata[id];
                const hasChanges = !existing || 
                    existing.title !== m.title || 
                    existing.artist !== m.artist || 
                    existing.album !== m.album;
                
                if (hasChanges) {
                    // Preserve existing albumArt if present
                    const existingAlbumArt = existing?.albumArt;
                    trackMetadata[id] = { ...m };
                    if (existingAlbumArt) {
                        trackMetadata[id].albumArt = existingAlbumArt;
                    }
                    // Save to IndexedDB
                    saveTrackMetadataToDB(id, trackMetadata[id]).catch(err => {
                        console.warn('[MetaDB] Failed to save metadata:', err);
                    });
                }
                
                // Update Library/Playlist Table Rows
                document.querySelectorAll(`tr#row-${id}`).forEach(r => {
                    const titleEl = r.querySelector('.meta-title');
                    const artistEl = r.querySelector('.meta-artist');
                    const albumEl = r.querySelector('.meta-album');
                    
                    // Skip animations during bulk loading to prevent lag
                    if (isBulkMetadataLoading) {
                        if (titleEl) titleEl.innerText = m.title;
                        if (artistEl) artistEl.innerText = m.artist;
                        if (albumEl) albumEl.innerText = m.album;
                        return;
                    }
                    
                    // Add updating class to trigger fade
                    [titleEl, artistEl, albumEl].forEach(el => {
                        if (el) {
                            el.classList.add('updating');
                            // Small delay to let the fade start, then update text
                            setTimeout(() => {
                                el.innerText = el === titleEl ? m.title : el === artistEl ? m.artist : m.album;
                                el.classList.remove('updating');
                                el.classList.add('updated');
                                // Clean up the updated class
                                setTimeout(() => el.classList.remove('updated'), 300);
                            }, 50);
                        }
                    });
                });
                
                // Update Queue Items
                document.querySelectorAll(`.q-row-${id}`).forEach(qItem => {
                    const tEl = qItem.querySelector('.q-title');
                    const aEl = qItem.querySelector('.q-artist');
                    
                    // Skip animations during bulk loading to prevent lag
                    if (isBulkMetadataLoading) {
                        if (tEl) tEl.innerText = m.title;
                        if (aEl) aEl.innerText = m.artist;
                        return;
                    }
                    
                    if(tEl) {
                        tEl.classList.add('updating');
                        setTimeout(() => {
                            tEl.innerText = m.title;
                            tEl.classList.remove('updating');
                            tEl.classList.add('updated');
                            setTimeout(() => tEl.classList.remove('updated'), 300);
                        }, 50);
                    }
                    if(aEl) {
                        aEl.classList.add('updating');
                        setTimeout(() => {
                            aEl.innerText = m.artist;
                            aEl.classList.remove('updating');
                            aEl.classList.add('updated');
                            setTimeout(() => aEl.classList.remove('updated'), 300);
                        }, 50);
                    }
                });
                
                // Update Player Bar / Mobile Player / Desktop Extended View if this is the current song
                if (queue[qIndex]?.id === id) {
                    document.getElementById("npTitle").innerText = m.title;
                    document.getElementById("npArtist").innerText = m.artist;
                    document.getElementById("npAlbum").innerText = m.album;
                    document.getElementById("fsTitle").innerText = m.title;
                    document.getElementById("fsArtist").innerText = m.artist;
                    document.getElementById("fsAlbum").innerText = m.album;
                    
                    // Update Desktop Extended View
                    const deTitle = document.getElementById("deTitle");
                    const deArtist = document.getElementById("deArtist");
                    if(deTitle) deTitle.innerText = m.title;
                    if(deArtist) deArtist.innerText = m.artist;
                }

                if (document.getElementById("searchResults")?.style.display === "block") {
                    searchSongsToAdd(document.querySelector(".search-input")?.value || "");
                }
                if (tag.tags.picture) {
                    const {data, format} = tag.tags.picture;
                    let s = ""; for(let i=0;i<data.length;i++) s+=String.fromCharCode(data[i]);
                    const base64 = `data:${format};base64,${btoa(s)}`;
                    tempArtCache[id] = base64;
                    
                    // Store album art in trackMetadata for Listen Again section (in-memory only)
                    // Don't save to localStorage here - it's already saved above and album art makes the string huge
                    if (!trackMetadata[id]) trackMetadata[id] = {};
                    trackMetadata[id].albumArt = base64;
                    
                    // IMMEDIATELY save updated metadata with albumArt to IndexedDB
                    // This ensures Listen Again section has album art on refresh
                    saveTrackMetadataToDB(id, trackMetadata[id]).catch(() => {});
                    
                    // Defer color extraction to not block UI
                    setTimeout(() => extractColorFromAlbumArt(id), 50);
                    
                    if (m.album && m.album !== "Unknown") {
                        albumArtCache[m.album] = base64;
                        // Save to IndexedDB (much larger capacity than localStorage)
                        saveImageToDB(`album_${m.album}`, base64).catch(() => {});
                        
                        // Defer color extraction for other tracks in same album
                        setTimeout(() => {
                            queue.forEach(qt => {
                                const qtMeta = trackMetadata[qt.id];
                                if (qtMeta && qtMeta.album === m.album) {
                                    extractColorFromAlbumArt(qt.id);
                                }
                            });
                        }, 100);
                        
                        // Also update UI for other tracks with same album
                        Object.keys(trackMetadata).forEach(otherId => {
                            if (trackMetadata[otherId].album === m.album && otherId !== id) {
                                applyArtToUI(otherId, base64);
                            }
                        });
                        
                        // Update currently playing track if it's on this album
                        if (queue[qIndex]?.id && trackMetadata[queue[qIndex].id]?.album === m.album) {
                            applyArtToUI(queue[qIndex].id, base64);
                        }
                    }
                    
                    applyArtToUI(id, base64);
                    updateFolderModalArt(id);
                    // Extract color for the current track
                    extractColorFromAlbumArt(id);
                    document.querySelectorAll('.playlist-card, #playlistCover').forEach(el => {
                        if (el.classList.contains('playlist-card')) {
                            const plName = el.dataset.name;
                        if (playlists[plName]?.[0]?.id === id) {
                                const art = el.querySelector('.folder-art');
                                if (art) art.innerHTML = `<img src="${base64}" class="loaded" style="width:100%;height:100%;object-fit:cover;position:absolute;inset:0;">`;
                            }
                        } else if (el.id === 'playlistCover' && currentPlaylistName) {
                            if (playlists[currentPlaylistName]?.[0]?.id === id) {
                                el.innerHTML = `<img src="${base64}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                            }
                        }
                    });
                }
                pendingMetadataLoads.delete(id);
            },
            onError: () => {
                pendingMetadataLoads.delete(id);
            }
        });
    } catch(e) {
        pendingMetadataLoads.delete(id);
    }
}

// Update playlist cover art if this track is the first track in a playlist
function updatePlaylistCoverIfNeeded(trackId, albumArt) {
    document.querySelectorAll('.playlist-card, #playlistCover').forEach(el => {
        if (el.classList.contains('playlist-card')) {
            const plName = el.dataset.name;
            if (playlists[plName]?.[0]?.id === trackId) {
                const art = el.querySelector('.folder-art');
                if (art) {
                    setAlbumArtWithFade(art, albumArt);
                }
            }
        } else if (el.id === 'playlistCover' && currentPlaylistName) {
            if (playlists[currentPlaylistName]?.[0]?.id === trackId) {
                setAlbumArtWithFade(el, albumArt);
            }
        }
    });
}

// Helper function to apply album art with fade-in effect
function setAlbumArtWithFade(container, base64, fallbackUrl = null) {
    if (!container) return;
    
    // Create the image element
    const img = document.createElement('img');
    img.src = base64;
    img.style.cssText = 'width:100%;height:100%;object-fit:cover;';
    
    // Handle completion
    const finishLoad = () => {
        img.classList.add('fade-in');
    };
    
    img.onerror = function() {
        if (fallbackUrl) {
            this.src = fallbackUrl;
            this.onload = finishLoad;
        }
    };
    
    img.onload = finishLoad;
    
    // For cached images, onload might not fire - check if already complete
    if (img.complete) {
        finishLoad();
    }
    
    // Clear and append the image
    container.innerHTML = '';
    container.appendChild(img);
}

function applyArtToUI(id, base64) {
    // Apply to track art elements in all tables with fade-in
    document.querySelectorAll(`.track-art-${id}`).forEach(el => {
        setAlbumArtWithFade(el, base64);
    });
    
    if (queue[qIndex]?.id === id) {
        const npArt = document.getElementById("npArt");
        const fsArt = document.getElementById("fsArt");
        
        if (npArt) {
            setAlbumArtWithFade(npArt, base64);
        }
        if (fsArt) {
            setAlbumArtWithFade(fsArt, base64);
        }
        
        // Update desktop extended view album art
        const deArt = document.getElementById("desktopExtendedArtImg");
        const deBg = document.getElementById("desktopExtendedArtBg");
        if(deArt) {
            deArt.src = base64;
            deArt.style.opacity = '0';
            deArt.style.transition = 'opacity 0.4s ease';
            setTimeout(() => deArt.style.opacity = '1', 10);
        }
        if(deBg) {
            deBg.style.backgroundImage = `url(${base64})`;
            deBg.classList.add('visible');
        }
        
        // Defer color extraction to not block UI
        setTimeout(() => extractColorFromAlbumArt(id), 50);
    }
}

function renderQueue() {
    const qList = document.getElementById("queueList");
    const deQList = document.getElementById("deQueueList");
    
    // Use document fragments to batch DOM insertions
    const sidebarFragment = document.createDocumentFragment();
    const deFragment = document.createDocumentFragment();
    
    qList.innerHTML = "";
    if (deQList) deQList.innerHTML = "";

    // Filter out m3u playlist files from queue display
    const filteredQueue = filterM3uFiles(queue);
    
    filteredQueue.forEach((t,i) => {
        // Find the actual index in the original queue for proper playback
        const actualIndex = queue.findIndex(qt => qt.id === t.id);
        const m = trackMetadata[t.id] || {title:"...",artist:"...",album:"..."};
        const isActive = actualIndex === qIndex;
        
        const album = m.album;
        let artHTML = '<i class="fa-solid fa-music" style="opacity:0.2"></i>';
        
        // Check all sources for album art in order of priority
        if (m.albumArt) {
            // Album art from trackMetadata (loaded from IndexedDB) - highest priority
            artHTML = `<img src="${m.albumArt}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        } else if (tempArtCache[t.id]) {
            artHTML = `<img src="${tempArtCache[t.id]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        } else if (album && album !== "Unknown" && albumArtCache[album]) {
            artHTML = `<img src="${albumArtCache[album]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        } else if (album && album !== "Unknown") {
            // Try to load from IndexedDB asynchronously and update when loaded
            loadImageFromDB(`album_${album}`).then(dbArt => {
                if (dbArt) {
                    albumArtCache[album] = dbArt;
                    // Update trackMetadata for future reference
                    if (trackMetadata[t.id]) {
                        trackMetadata[t.id].albumArt = dbArt;
                        saveTrackMetadataToDB(t.id, trackMetadata[t.id]).catch(() => {});
                    }
                    // Apply to UI
                    applyArtToUI(t.id, dbArt);
                }
            }).catch(() => {});
        }
        
        // Create sidebar queue item
        const item = document.createElement("div");
        item.className = `queue-item ${isActive?'active':''}`;
        item.classList.add(`q-row-${t.id}`);
        
        item.innerHTML = `
            <div class="queue-hover-menu">
                <button class="m3-btn m3-btn-filled" onclick="event.stopPropagation(); openPlaylistModal(event, '${t.id}')">
                    <i class="fa-solid fa-bookmark" style="font-size:14px;"></i>
                    <span>Add to Playlist</span>
                </button>
                <button class="m3-btn m3-btn-tonal" onclick="event.stopPropagation(); removeFromQueue('${t.id}')">
                    <i class="fa-solid fa-trash" style="font-size:14px;"></i>
                    <span>Remove from Queue</span>
                </button>
            </div>
            <div class="queue-item-content">
                <div class="queue-drag-handle"><i class="fa-solid fa-grip-vertical"></i></div>
                <div style="width:44px;height:44px;border-radius:6px;background:var(--md-sys-color-surface-variant);overflow:hidden;display:flex;align-items:center;justify-content:center;" class="track-art-${t.id}">
                    ${artHTML}
                </div>
                <div style="flex:1;overflow:hidden;">
                    <div class="q-title" style="font-weight:600;font-size:14px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${m.title}</div>
                    <div class="q-artist" style="font-size:12px;opacity:0.7;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${m.artist}</div>
                </div>
            </div>
            <button class="queue-ellipsis" onclick="event.stopPropagation()">
                <i class="fa-solid fa-ellipsis"></i>
            </button>
        `;
        
        item.onclick = (e) => {
            if (!e.target.closest('.queue-drag-handle') && !e.target.closest('.m3-btn')) {
                play(actualIndex);
                currentQueueSource = null;
            }
        };
        sidebarFragment.appendChild(item);
        
        // Create desktop extended queue item
        if (deQList) {
            const deItem = document.createElement("div");
            deItem.className = `queue-item ${isActive?'active':''}`;
            deItem.classList.add(`q-row-${t.id}`);
            
            deItem.innerHTML = `
                <div class="queue-hover-menu">
                    <button class="m3-btn m3-btn-filled" onclick="event.stopPropagation(); openPlaylistModal(event, '${t.id}')">
                        <i class="fa-solid fa-bookmark" style="font-size:14px;"></i>
                        <span>Add to Playlist</span>
                    </button>
                    <button class="m3-btn m3-btn-tonal" onclick="event.stopPropagation(); removeFromQueue('${t.id}')">
                        <i class="fa-solid fa-trash" style="font-size:14px;"></i>
                        <span>Remove from Queue</span>
                    </button>
                </div>
                <div class="queue-item-content">
                    <div class="queue-drag-handle"><i class="fa-solid fa-grip-vertical"></i></div>
                    <div style="width:44px;height:44px;border-radius:6px;background:var(--md-sys-color-surface-variant);overflow:hidden;display:flex;align-items:center;justify-content:center;" class="track-art-${t.id}">
                        ${artHTML}
                    </div>
                    <div class="truncate" style="flex:1">
                        <div class="q-title" style="font-weight:600;font-size:14px;">${m.title}</div>
                        <div class="q-artist" style="font-size:12px;opacity:0.7;">${m.artist}</div>
                    </div>
                </div>
                <button class="queue-ellipsis" onclick="event.stopPropagation()">
                    <i class="fa-solid fa-ellipsis"></i>
                </button>
            `;
            
            deItem.onclick = (e) => {
                if (!e.target.closest('.queue-drag-handle') && !e.target.closest('.m3-btn')) {
                    play(actualIndex);
                    currentQueueSource = null;
                }
            };
            deFragment.appendChild(deItem);
        }

        if (!tempArtCache[t.id] && !(album && albumArtCache[album])) {
            loadMetaAndArt(t.id, '');
        }
    });
    
    // Batch append fragments to DOM
    qList.appendChild(sidebarFragment);
    if (deQList) deQList.appendChild(deFragment);
}

function play(idx) {
    if (idx<0 || idx>=queue.length) return;
    const t = queue[idx];
    
    // Reset play tracking for new track - ensures fresh counting
    lastTrackedPosition = {};
    
    qIndex = idx;
    
    player.src = WORKER_URL + "?id=" + t.id;
    
    // Initialize audio context before playing (required for Web Audio API)
    initAudioContext();
    initNormalizationAudio();
    
    // Ensure audio context is running before playback
    const ctx = audioCtx || audioContext;
    if (ctx && ctx.state === 'suspended') {
        ctx.resume().then(() => {
            player.play().then(() => {
                // Automatically open queue sidebar when music starts playing
                const sidebar = document.getElementById("sidebar");
                if (sidebar) {
                    sidebar.classList.remove("collapsed");
                }
            }).catch(()=>{});
            // Analyze and apply normalization after context is ready
            analyzeAndApplyNormalization(t.id);
        });
    } else {
        player.play().then(() => {
            // Automatically open queue sidebar when music starts playing
            const sidebar = document.getElementById("sidebar");
            if (sidebar) {
                sidebar.classList.remove("collapsed");
            }
        }).catch(()=>{});
        // Analyze and apply normalization immediately
        analyzeAndApplyNormalization(t.id);
    }
    
    const m = trackMetadata[t.id] || {title:"Unknown",artist:"Unknown",album:"Unknown"};
    
    document.getElementById("npTitle").innerText = m.title;
    document.getElementById("npArtist").innerText = m.artist;
    document.getElementById("npAlbum").innerText = m.album;
    
    // Clean UI
    const deTitle = document.getElementById("deTitle");
    const deArtist = document.getElementById("deArtist");
    if(deTitle) deTitle.innerText = m.title;
    if(deArtist) deArtist.innerText = m.artist;
    
    document.getElementById("fsTitle").innerText = m.title;
    document.getElementById("fsArtist").innerText = m.artist;
    document.getElementById("fsAlbum").innerText = m.album;

    const album = m.album;
    let artHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;"><i class="fa-solid fa-music" style="opacity:0.35;font-size:28px;"></i></div>';
    let fsArtHTML = '<i class="fa-solid fa-music"></i>';
    let rawSrc = "";
    
    // Priority 1: Use track-specific art if available
    if (tempArtCache[t.id]) {
        rawSrc = tempArtCache[t.id];
        const imgTag = `<img src="${rawSrc}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        artHTML = imgTag;
        fsArtHTML = imgTag;
    } 
    // Priority 2: Use cached album art from any track on same album
    else if (album && album !== "Unknown" && albumArtCache[album]) {
        rawSrc = albumArtCache[album];
        const imgTag = `<img src="${rawSrc}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        artHTML = imgTag;
        fsArtHTML = imgTag;
        // Track now uses album art, so apply it to this track's UI
        applyArtToUI(t.id, rawSrc);
    }
    // Priority 3: Try loading from IndexedDB
    else if (album && album !== "Unknown") {
        loadAlbumArtFromDB(album).then(dbArt => {
            if (dbArt) {
                albumArtCache[album] = dbArt;
                const imgTag = `<img src="${dbArt}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                document.getElementById("npArt").innerHTML = imgTag;
                document.getElementById("fsArt").innerHTML = imgTag;
                applyArtToUI(t.id, dbArt);
                
                // Update desktop extended view
                const deArt = document.getElementById("desktopExtendedArtImg");
                if (deArt) {
                    deArt.src = dbArt;
                    deArt.classList.add('visible');
                }
            }
        });
        // Also trigger metadata load
        if (!pendingMetadataLoads.has(t.id)) {
            loadMetaAndArt(t.id, '');
        }
    }
    // Priority 4: Load metadata for this track (will populate album cache)
    else if (!pendingMetadataLoads.has(t.id)) {
        loadMetaAndArt(t.id, '');
    }
    
    document.getElementById("npArt").innerHTML = artHTML;
    document.getElementById("fsArt").innerHTML = fsArtHTML;
    
    // Update desktop extended view album art
    const deArt = document.getElementById("desktopExtendedArtImg");
    if (deArt) {
        if(rawSrc) {
            deArt.src = rawSrc;
            deArt.classList.add('visible');
        } else {
            deArt.src = "";
            deArt.classList.remove('visible');
        }
    }
    
    // Update desktop extended view blurred background
    const deBg = document.getElementById("desktopExtendedArtBg");
    if(deBg) {
        if(rawSrc) {
            deBg.style.backgroundImage = `url(${rawSrc})`;
            deBg.classList.add('visible');
        } else {
            deBg.style.backgroundImage = '';
            deBg.classList.remove('visible');
        }
    }
    
    // Extract color from album art if feature is enabled - only if art is available
    // Defer to not block UI responsiveness
    if (rawSrc) {
        setTimeout(() => extractColorFromAlbumArt(t.id), 10);
    }
    
    document.body.classList.add('playing');
    // Defer queue rendering to prevent UI blocking
    setTimeout(() => renderQueue(), 0);
}

function playPlaylist(name) {
    const pl = playlists[name];
    if (!pl || pl.length === 0) return;
    currentQueueSource = `playlist:${name}`;
    // Filter out m3u playlist files
    const filtered = filterM3uFiles(pl);
    queue = filtered.map(entry => ({id: entry.id}));
    qIndex = 0;
    // play(0) will handle renderQueue() deferred
    play(0);
}

function shuffleAndPlayPlaylist(name) {
    const pl = playlists[name];
    if (!pl || pl.length === 0) return;
    currentQueueSource = null;
    // Filter out m3u playlist files
    const filtered = filterM3uFiles(pl);
    let shuffled = [...filtered];
    for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    queue = shuffled.map(entry => ({id: entry.id}));
    qIndex = 0;
    // play(0) will handle renderQueue() deferred
    play(0);
}

function playPlaylistFromCard(e) {
    e.stopPropagation();
    const card = e.currentTarget.closest('.playlist-card');
    if (card) playPlaylist(card.dataset.name);
}

function shufflePlayFromCard(e) {
    e.stopPropagation();
    const card = e.currentTarget.closest('.playlist-card');
    if (card) shuffleAndPlayPlaylist(card.dataset.name);
}

// Toggle pin playlist to Listen Again
function togglePinPlaylist(name) {
    if (isPinned('playlists', name)) {
        unpinItem('playlists', name);
    } else {
        // Get playlist cover art
        let art = '';
        const firstId = playlists[name]?.[0]?.id;
        if (firstId) {
            const meta = trackMetadata[firstId];
            art = meta?.albumArt || meta?.art || '';
        }
        
        pinItem('playlists', name, {
            name: name,
            art: art,
            trackCount: Array.isArray(playlists[name]) ? playlists[name].length : 0
        });
    }
}

// Toggle pin track to Listen Again
function togglePinTrack(trackId) {
    const meta = trackMetadata[trackId];
    const queueTrack = queue.find(t => t.id === trackId);
    const track = meta || queueTrack || {};
    
    pinItem('tracks', trackId, {
        id: trackId,
        title: meta?.title || queueTrack?.title || queueTrack?.name || 'Unknown Track',
        artist: meta?.artist || queueTrack?.artist || queueTrack?.artistName || 'Unknown Artist',
        album: meta?.album || queueTrack?.album || '',
        albumArt: meta?.albumArt || meta?.art || queueTrack?.albumArt || queueTrack?.art || '',
        path: meta?.path || queueTrack?.path || '',
        googleUrl: meta?.googleUrl || queueTrack?.googleUrl || queueTrack?.url || ''
    });
    
    // Update pin button UI immediately
    updateTrackPinButton(trackId, true);
}

// Update pin button state for a track row
function updateTrackPinButton(trackId, isPinned) {
    const row = document.querySelector(`#row-${CSS.escape(trackId)}`);
    if (!row) return;
    
    const pinBtn = row.querySelector('.track-actions .m3-btn[onclick*="togglePinTrack"], .track-actions .m3-btn[onclick*="unpinItem"]');
    if (!pinBtn) return;
    
    if (isPinned) {
        // Change to unpin button
        pinBtn.setAttribute('onclick', "event.stopPropagation(); unpinTrackFromRow('" + trackId + "')");
        pinBtn.title = "Remove from Listen Again";
        pinBtn.innerHTML = '<i class="fa-solid fa-xmark"></i><span>Remove</span>';
        
        // Also add pinned badge to art if not present
        const artDiv = row.querySelector(`[class*="track-art-${CSS.escape(trackId)}"]`);
        if (artDiv && !artDiv.querySelector('.pinned-badge')) {
            artDiv.innerHTML = '<div class="pinned-badge" style="position:absolute;top:-4px;right:-4px;width:20px;height:20px;"><i class="fa-solid fa-heart"></i></div>' + artDiv.innerHTML;
        }
    } else {
        // Change back to pin button
        pinBtn.setAttribute('onclick', "event.stopPropagation(); togglePinTrack('" + trackId + "')");
        pinBtn.title = "Pin to Listen Again";
        pinBtn.innerHTML = '<i class="fa-solid fa-heart"></i><span>Pin</span>';
        
        // Remove pinned badge from art
        const badge = row.querySelector('.pinned-badge');
        if (badge) {
            badge.remove();
        }
    }
}

// Unpin track from row (wrapper that updates UI)
function unpinTrackFromRow(trackId) {
    unpinItem('tracks', trackId);
    // Update pin button UI immediately
    updateTrackPinButton(trackId, false);
}

// Play all tracks in a folder
async function playFolderFromCard(e, folderId) {
    e.stopPropagation();
    try {
        const files = await getFolderContents(folderId);
        const tracks = files.filter(f => f.mimeType.includes('audio'));
        // Sort tracks by file name (same as when navigating into folder)
        tracks.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));
        if (tracks.length === 0) {
            showNotification('No audio files in this folder');
            return;
        }

        // Build queue from folder tracks
        queue = tracks.map(f => ({
            id: f.id,
            name: f.name
        }));

        qIndex = 0;
        currentQueueSource = 'folder';

        // Load all metadata in parallel (same as renderTrackTable)
        loadMetadataSequentially(tracks, 0);

        await play(qIndex);
        renderQueue();

        showNotification(`Playing ${queue.length} tracks from folder`);
    } catch (error) {
        console.error('Error playing folder:', error);
        showNotification('Error playing folder');
    }
}

// Shuffle and play all tracks in a folder
async function shuffleFolderFromCard(e, folderId) {
    e.stopPropagation();
    try {
        const files = await getFolderContents(folderId);
        const tracks = files.filter(f => f.mimeType.includes('audio'));
        // Sort tracks by file name (same as when navigating into folder)
        tracks.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));
        if (tracks.length === 0) {
            showNotification('No audio files in this folder');
            return;
        }

        // Build queue from folder tracks
        queue = tracks.map(f => ({
            id: f.id,
            name: f.name
        }));

        // Shuffle queue
        for (let i = queue.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [queue[i], queue[j]] = [queue[j], queue[i]];
        }

        qIndex = 0;
        currentQueueSource = 'folder';

        // Load all metadata in parallel (same as renderTrackTable)
        loadMetadataSequentially(tracks, 0);

        await play(qIndex);
        renderQueue();

        showNotification(`Shuffling ${queue.length} tracks from folder`);
    } catch (error) {
        console.error('Error shuffling folder:', error);
        showNotification('Error playing folder');
    }
}

// Handle pin button click - wrapper to ensure click works
function handlePinClick(event, folderId, folderName) {
    console.log('[Pinned] handlePinClick called:', folderId, folderName);
    event.stopPropagation();
    event.preventDefault();
    togglePinFolder(folderId, folderName, '');
}

// Handle pin button click with art
function handlePinClickWithArt(event, folderId, folderName, art) {
    console.log('[Pinned] handlePinClickWithArt called:', folderId, folderName, art);
    event.stopPropagation();
    event.preventDefault();
    togglePinFolder(folderId, folderName, art);
}

// Toggle pin subfolder to Listen Again
async function togglePinFolder(folderId, folderName, art) {
    console.log('[Pinned] togglePinFolder called:', folderId, folderName, art);
    const name = decodeURIComponent(folderName);
    console.log('[Pinned] Decoded name:', name);
    console.log('[Pinned] Current pinnedItems:', pinnedItems);
    
    if (isPinned('albums', name)) {
        console.log('[Pinned] Folder is already pinned, unpinning...');
        unpinItem('albums', name);
    } else {
        console.log('[Pinned] Folder is not pinned, pinning...');
        pinItem('albums', folderId, {
            name: name,
            folderId: folderId,
            art: art,
            trackCount: 0,
            totalPlays: 0
        });
    }
    console.log('[Pinned] After toggle, pinnedItems:', pinnedItems);
}

// Play a pinned folder from Listen Again section
async function playPinnedFolder(folderId) {
    try {
        const files = await getFolderContents(folderId);
        const tracks = files.filter(f => f.mimeType.includes('audio'));
        // Sort tracks by file name (same as when navigating into folder)
        tracks.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));
        if (tracks.length === 0) {
            showNotification('No audio files in this folder');
            return;
        }

        // Build queue from folder tracks
        queue = tracks.map(f => ({
            id: f.id,
            name: f.name
        }));

        qIndex = 0;
        currentQueueSource = 'folder';

        // Load all metadata in parallel (same as renderTrackTable)
        loadMetadataSequentially(tracks, 0);

        await play(qIndex);
        renderQueue();

        showNotification(`Playing ${queue.length} tracks from folder`);
    } catch (error) {
        console.error('Error playing pinned folder:', error);
        showNotification('Error playing folder');
    }
}

// Open pinned folder (navigate into it)
function openPinnedFolderFromCard(folderId) {
    // First get the folder name from the pinned item data
    const pinnedAlbums = pinnedItems.albums || [];
    const pinnedAlbum = pinnedAlbums.find(p => p.folderId === folderId);
    
    if (pinnedAlbum) {
        const folderName = pinnedAlbum.name;
        stack.push({id: folderId, name: folderName});
        loadFolders(folderId);
    } else {
        // Fallback: just navigate using the folderId (name will be the ID)
        stack.push({id: folderId, name: 'Folder'});
        loadFolders(folderId);
    }
}

// Shuffle and play a pinned folder
async function shufflePinnedFolder(folderId) {
    try {
        const files = await getFolderContents(folderId);
        const tracks = files.filter(f => f.mimeType.includes('audio'));
        // Sort tracks by file name (same as when navigating into folder)
        tracks.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));
        if (tracks.length === 0) {
            showNotification('No audio files in this folder');
            return;
        }

        // Build queue from folder tracks
        queue = tracks.map(f => ({
            id: f.id,
            name: f.name
        }));

        // Shuffle queue
        for (let i = queue.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [queue[i], queue[j]] = [queue[j], queue[i]];
        }

        qIndex = 0;
        currentQueueSource = 'folder';

        // Load all metadata in parallel
        loadMetadataSequentially(tracks, 0);

        await play(qIndex);
        renderQueue();

        showNotification(`Shuffling ${queue.length} tracks from folder`);
    } catch (error) {
        console.error('Error shuffling pinned folder:', error);
        showNotification('Error playing folder');
    }
}

// Open a pinned playlist from Listen Again section (opens detailed view)
function openPinnedPlaylistFromCard(playlistName) {
    console.log('[Playlist] Opening pinned playlist:', playlistName);
    
    // Debug: Check if element exists
    const playlistCard = document.getElementById('listen-playlist-0');
    if (playlistCard) {
        console.log('[Playlist] Card found, data-playlist:', playlistCard.dataset.playlist);
    } else {
        console.log('[Playlist] Card element not found');
    }
    
    const name = decodeURIComponent(playlistName);
    console.log('[Playlist] Decoded name:', name);
    console.log('[Playlist] Available playlists:', Object.keys(playlists));
    console.log('[Playlist] Playlist data exists:', playlists[name] !== undefined);
    console.log('[Playlist] Playlist data:', playlists[name]);
    
    // Debug: Check if DOM elements exist
    const gridContainer = document.getElementById("playlistGridContainer");
    const contentView = document.getElementById("playlistContentView");
    const titleEl = document.getElementById("currentPlaylistTitle");
    const breadcrumbEl = document.getElementById("playlistBreadcrumb");
    const coverEl = document.getElementById("playlistCover");
    const songBody = document.getElementById("playlistSongBody");
    const playlistScreen = document.getElementById('playlist-screen');
    
    console.log('[Playlist] DOM elements:', {
        gridContainer: !!gridContainer,
        contentView: !!contentView,
        titleEl: !!titleEl,
        breadcrumbEl: !!breadcrumbEl,
        coverEl: !!coverEl,
        songBody: !!songBody,
        playlistScreen: !!playlistScreen
    });
    
    if (!gridContainer || !contentView || !playlistScreen) {
        console.error('[Playlist] Required DOM elements missing!');
        showNotification('Error: Required elements not found');
        return;
    }
    
    currentPlaylistName = name;
    
    // Show content view, hide grid
    gridContainer.style.display = "none";
    contentView.style.display = "block";
    titleEl.innerText = name;
    breadcrumbEl.innerHTML = `
        <div class="chip" onclick="backToPlaylistGrid()">Playlists</div>
        <i class="fa-solid fa-chevron-right" style="opacity:0.4;"></i>
        <div class="chip" style="background:var(--md-sys-color-primary-container);color:var(--md-sys-color-primary);">${name}</div>
    `;
    
    // Update pin button state
    updatePinPlaylistButton();
    
    coverEl.innerHTML = '<div class="no-art"><i class="fa-solid fa-compact-disc"></i></div>';
    
    // Try to get art from folder cover first (auto-detected from Google Drive folders)
    if (playlistCovers[name]) {
        const img = new Image();
        img.onload = () => {
            img.classList.add('loaded');
            coverEl.innerHTML = '';
            coverEl.appendChild(img);
        };
        img.src = playlistCovers[name];
    } else if (Array.isArray(playlists[name]) && playlists[name].length > 0) {
        const firstId = playlists[name][0].id;
        const firstMeta = trackMetadata[firstId];
        const album = firstMeta?.album;
        
        if (firstMeta?.albumArt) {
            coverEl.innerHTML = `<img src="${firstMeta.albumArt}" class="loaded" style="width:100%;height:100%;object-fit:cover;position:absolute;inset:0;">`;
        } else if (album && album !== "Unknown") {
            loadAlbumArtFromDB(album).then(art => {
                if (art) {
                    coverEl.innerHTML = `<img src="${art}" class="loaded" style="width:100%;height:100%;object-fit:cover;position:absolute;inset:0;">`;
                }
            });
        }
    }
    
    // Render the playlist content
    const playlistTracks = playlists[name] || [];
    console.log('[Playlist] Rendering tracks:', playlistTracks.length);
    renderPlaylistTracks(playlistTracks, songBody, name);
    
    // Navigate to the playlist screen
    const allScreens = document.querySelectorAll('.screen');
    console.log('[Playlist] Total screens found:', allScreens.length);
    
    allScreens.forEach(s => {
        s.classList.remove('active');
    });
    
    playlistScreen.classList.add('active');
    
    // Debug: Check if screen is now active
    console.log('[Playlist] Screen active state:', playlistScreen.classList.contains('active'));
    
    // Show notification for debugging
    showNotification(`Opened playlist: ${name}`);
    
    console.log('[Playlist] Playlist view activated');
}

// Recursively get all audio files from a folder and its subfolders
async function getAllAudioFilesRecursive(folderId) {
    const allFiles = [];

    async function traverse(folderId) {
        const files = await getFolderContents(folderId);
        const subfolders = files.filter(f => f.mimeType === 'application/vnd.google-apps.folder');
        const audioFiles = files.filter(f => f.mimeType.includes('audio'));

        // Add audio files to the list
        allFiles.push(...audioFiles);

        // Recursively traverse subfolders
        for (const folder of subfolders) {
            await traverse(folder.id);
        }
    }

    await traverse(folderId);
    return allFiles;
}

// Play all tracks in current folder and subfolders recursively
async function playCurrentFolderRecursive() {
    const currentFolderId = stack[stack.length - 1].id;

    try {
        showNotification('Loading all tracks...');
        const tracks = await getAllAudioFilesRecursive(currentFolderId);

        if (tracks.length === 0) {
            showNotification('No audio files found');
            return;
        }

        // Sort tracks by file name
        tracks.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));

        // Build queue
        queue = tracks.map(f => ({
            id: f.id,
            name: f.name
        }));

        qIndex = 0;
        currentQueueSource = 'folder';

        // Load all metadata in parallel
        loadMetadataSequentially(tracks, 0);

        await play(qIndex);
        renderQueue();

        showNotification(`Playing ${queue.length} tracks from folder`);
    } catch (error) {
        console.error('Error playing folder recursively:', error);
        showNotification('Error playing folder');
    }
}

// Shuffle and play all tracks in current folder and subfolders recursively
async function shuffleCurrentFolderRecursive() {
    const currentFolderId = stack[stack.length - 1].id;

    try {
        showNotification('Loading all tracks...');
        const tracks = await getAllAudioFilesRecursive(currentFolderId);

        if (tracks.length === 0) {
            showNotification('No audio files found');
            return;
        }

        // Sort tracks by file name first
        tracks.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));

        // Build queue
        queue = tracks.map(f => ({
            id: f.id,
            name: f.name
        }));

        // Shuffle queue
        for (let i = queue.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [queue[i], queue[j]] = [queue[j], queue[i]];
        }

        qIndex = 0;
        currentQueueSource = 'folder';

        // Load all metadata in parallel
        loadMetadataSequentially(tracks, 0);

        await play(qIndex);
        renderQueue();

        showNotification(`Shuffling ${queue.length} tracks from folder`);
    } catch (error) {
        console.error('Error shuffling folder recursively:', error);
        showNotification('Error playing folder');
    }
}

function renderPlaylists() {
    const grid = document.getElementById("playlistGrid");
    grid.innerHTML = "";

    // Add big square "New Playlist" card at the beginning
    const newCard = document.createElement("div");
    newCard.className = "folder-card playlist-card new-playlist-card";
    newCard.innerHTML = `
        <div class="new-playlist-icon">
            <i class="fa-solid fa-plus"></i>
        </div>
        <div class="new-playlist-label">New Playlist</div>
    `;
    newCard.onclick = () => createNewPlaylist(false);
    grid.appendChild(newCard);
    setTimeout(() => newCard.classList.add('loaded'), 0);

    Object.keys(playlists).sort().forEach(name => {
        const card = document.createElement("div");
        card.className = "folder-card playlist-card";
        card.dataset.name = name;
        const trackCount = Array.isArray(playlists[name]) ? playlists[name].length : 0;
        const pinned = isPinned('playlists', name);
        card.innerHTML = `
            <div class="folder-art">
                <i class="fa-solid fa-compact-disc" style="opacity:0.2;font-size:40px;"></i>
                ${pinned ? '<div class="pinned-badge" style="top:12px;right:12px;"><i class="fa-solid fa-heart"></i></div>' : ''}
            </div>
            <div class="folder-info"><span>${name}</span></div>
            <div class="play-overlay">
                <div class="control-group">
                    <div class="control-btn" onclick="playPlaylistFromCard(event)">
                        <i class="fa-solid fa-play"></i>
                    </div>
                    <div class="control-btn shuffle" onclick="shufflePlayFromCard(event)">
                        <i class="fa-solid fa-shuffle"></i>
                    </div>
                    <div class="btn-label">Shuffle Play</div>
                </div>
            </div>
            ${pinned ? '' : `<button class="pin-btn labeled-pin-btn" onclick="event.stopPropagation(); togglePinPlaylist('${name}')" title="Pin to Listen Again">
                <i class="fa-solid fa-heart"></i>
                <span>Pin</span>
            </button>`}
        `;
        const artContainer = card.querySelector('.folder-art');
        
        // Try to get art from folder cover first (auto-detected from Google Drive folders)
        let foundArt = false;
        if (playlistCovers[name]) {
            const img = new Image();
            img.onload = () => {
                img.classList.add('loaded');
                artContainer.innerHTML = '';
                artContainer.appendChild(img);
            };
            img.src = playlistCovers[name];
            foundArt = true;
        }
        
        if (!foundArt && Array.isArray(playlists[name]) && playlists[name].length > 0) {
            const firstId = playlists[name][0].id;
            const firstMeta = trackMetadata[firstId];
            const album = firstMeta?.album;
            
            // Check for album art in trackMetadata FIRST (loaded from IndexedDB)
            if (firstMeta?.albumArt) {
                artContainer.innerHTML = `<img src="${firstMeta.albumArt}" class="loaded" style="width:100%;height:100%;object-fit:cover;position:absolute;inset:0;">`;
                foundArt = true;
            }
            // Try to get art from album cache (any track in same album)
            else if (album && album !== "Unknown") {
                let albumArt = albumArtCache[album];
                if (albumArt) {
                    artContainer.innerHTML = `<img src="${albumArt}" class="loaded" style="width:100%;height:100%;object-fit:cover;position:absolute;inset:0;">`;
                    foundArt = true;
                } else {
                    // Try loading from IndexedDB asynchronously
                    loadAlbumArtFromDB(album).then(art => {
                        if (art) {
                            albumArtCache[album] = art;
                            artContainer.innerHTML = `<img src="${art}" class="loaded" style="width:100%;height:100%;object-fit:cover;position:absolute;inset:0;">`;
                        }
                    });
                    foundArt = true; // Mark as handled
                }
            }
            
            // Fallback to first track's individual art
            if (!foundArt && tempArtCache[firstId]) {
                artContainer.innerHTML = `<img src="${tempArtCache[firstId]}" class="loaded" style="width:100%;height:100%;object-fit:cover;position:absolute;inset:0;">`;
            }
        }
        card.onclick = () => {
            currentPlaylistName = name;
            document.getElementById("playlistGridContainer").style.display = "none";
            document.getElementById("playlistContentView").style.display = "block";
            document.getElementById("currentPlaylistTitle").innerText = name;
            document.getElementById("playlistBreadcrumb").innerHTML = `
                <div class="chip" onclick="backToPlaylistGrid()">Playlists</div>
                <i class="fa-solid fa-chevron-right" style="opacity:0.4;"></i>
                <div class="chip" style="background:var(--md-sys-color-primary-container);color:var(--md-sys-color-primary);">${name}</div>
            `;
            
            // Update pin button state
            updatePinPlaylistButton();
            
            const coverEl = document.getElementById("playlistCover");
            coverEl.innerHTML = '<div class="no-art"><i class="fa-solid fa-compact-disc"></i></div>';
            
            // Try to get art from folder cover first (auto-detected from Google Drive folders)
            if (playlistCovers[name]) {
                const img = new Image();
                img.onload = () => {
                    img.classList.add('loaded');
                    coverEl.innerHTML = '';
                    coverEl.appendChild(img);
                };
                img.src = playlistCovers[name];
            } else if (Array.isArray(playlists[name]) && playlists[name].length > 0) {
                const firstId = playlists[name][0].id;
                const firstMeta = trackMetadata[firstId];
                const album = firstMeta?.album;

                // Try to get art from album cache first (any track in same album)
                if (album && album !== "Unknown") {
                    let albumArt = albumArtCache[album];
                    if (albumArt) {
                        coverEl.innerHTML = `
                            <img src="${albumArt}" class="loaded" style="width:100%;height:100%;object-fit:cover;">
                        `;
                    } else {
                        // Try loading from IndexedDB asynchronously
                        loadAlbumArtFromDB(album).then(art => {
                            if (art) {
                                albumArtCache[album] = art;
                                coverEl.innerHTML = `
                                    <img src="${art}" class="loaded" style="width:100%;height:100%;object-fit:cover;">
                                `;
                            }
                        });
                        // Also trigger metadata load
                        loadMetaAndArt(firstId, '');
                    }
                } else {
                    // No album, try individual track art
                    if (tempArtCache[firstId]) {
                        coverEl.innerHTML = `
                            <img src="${tempArtCache[firstId]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">
                        `;
                    } else {
                        loadMetaAndArt(firstId, '');
                    }
                }
            }
            
            // Defer track table render for smoother UI (renderTrackTable handles staggered animation internally)
            setTimeout(() => {
                renderTrackTable(playlists[name], document.getElementById("playlistSongBody"), true, name);
                initPlaylistSortable();
            }, 0);
        };
        grid.appendChild(card);
        if (Array.isArray(playlists[name]) && playlists[name].length > 0) {
            loadMetaAndArt(playlists[name][0].id, '');
        }
    });
    // Animate existing playlist cards (skipping the new card at index 0)
    const existingCards = document.querySelectorAll('#playlistGrid .folder-card:not(.new-playlist-card)');
    existingCards.forEach((c, i) => setTimeout(() => c.classList.add('loaded'), 60 * i));
}

function backToPlaylistGrid() {
    document.getElementById("playlistGridContainer").style.display="block";
    document.getElementById("playlistContentView").style.display="none";
    if (playlistSortable) {
        playlistSortable.destroy();
        playlistSortable = null;
    }
}

function searchSongsToAdd(query) {
    const div = document.getElementById("searchResults");
    if (!query.trim()) {
        div.classList.remove("visible");
        div.style.display = "none";
        return;
    }
    query = query.toLowerCase();
    const matchingIds = Object.keys(trackMetadata).filter(id => {
        const m = trackMetadata[id];
        const allText = `${m.title || ""} ${m.artist || ""} ${m.album || ""} ${m.genre || ""} ${m.year || ""} ${m.composer || ""} ${m.track || ""}`.toLowerCase();
        return allText.includes(query);
    });
    if (matchingIds.length === 0) {
        div.innerHTML = `<div class="search-no-results">No results found in cache</div>`;
        div.classList.add("visible");
        div.style.display = "block";
        return;
    }
    const albumSet = new Set();
    matchingIds.forEach(id => {
        const alb = trackMetadata[id].album || "Unknown Album";
        albumSet.add(alb);
    });
    currentAlbumMap = {};
    Object.keys(trackMetadata).forEach(id => {
        const m = trackMetadata[id];
        const alb = m.album || "Unknown Album";
        if (albumSet.has(alb)) {
            if (!currentAlbumMap[alb]) {
                currentAlbumMap[alb] = {tracks: [], artists: new Set(), artId: null};
            }
            currentAlbumMap[alb].tracks.push({id, meta: m});
            currentAlbumMap[alb].artists.add(m.artist || "Unknown");
            if (!currentAlbumMap[alb].artId) {
                if (tempArtCache[id]) {
                    currentAlbumMap[alb].artId = id;
                } else if (alb !== "Unknown Album" && albumArtCache[alb]) {
                    currentAlbumMap[alb].artId = id;
                }
            }
        }
    });
    Object.values(currentAlbumMap).forEach(group => {
        group.tracks.sort((a, b) => {
            const ta = parseInt(a.meta.track?.split('/')[0] || "0") || Infinity;
            const tb = parseInt(b.meta.track?.split('/')[0] || "0") || Infinity;
            if (ta !== tb) return ta - tb;
            return a.meta.title.localeCompare(b.meta.title);
        });
    });
    const sortedAlbums = Object.keys(currentAlbumMap).sort((a, b) => a.localeCompare(b));
    div.innerHTML = sortedAlbums.map(alb => {
        const group = currentAlbumMap[alb];
        let art = null;
        let hasArtId = false;
        if (group.artId && tempArtCache[group.artId]) {
            art = tempArtCache[group.artId];
            hasArtId = true;
        } else if (alb !== "Unknown Album" && albumArtCache[alb]) {
            art = albumArtCache[alb];
            hasArtId = true;
        }
        
        // Try to load from IndexedDB if not in memory, and trigger metadata load
        if (!hasArtId && alb !== "Unknown Album") {
            loadAlbumArtFromDB(alb).then(dbArt => {
                if (dbArt) {
                    albumArtCache[alb] = dbArt;
                    // Update the art element
                    const artEl = div.querySelector(`[data-album-art="${alb.replace(/"/g, '\\"')}"]`);
                    if (artEl) {
                        artEl.innerHTML = `<img src="${dbArt}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                    }
                }
            });
            // Also trigger metadata load for first track
            if (group.tracks.length > 0) {
                loadMetaAndArt(group.tracks[0].id, '');
            }
        }
        
        const artistsStr = Array.from(group.artists).join(', ') || "Unknown Artist";
        const albEsc = alb.replace(/'/g, "\\'");
        const hasArt = art || alb !== "Unknown Album";
        const trackCount = group.tracks.length;
        const singleSongClick = trackCount === 1 ? `onclick="addSingleSongFromAlbum('${albEsc}'); event.stopPropagation();"` : `onclick="openAlbumChecklist('${albEsc}')"`;
        return `
            <div class="search-result-item" ${singleSongClick}>
                <div class="search-result-item-art">
                    ${hasArt ? (art ? `<img src="${art}" class="loaded">` : '<i class="fa-solid fa-compact-disc"></i>') : '<i class="fa-solid fa-music"></i>'}
                </div>
                <div class="search-result-content">
                    <div class="search-result-item-title">${alb === "Unknown Album" ? "Unknown Albums" : alb}</div>
                    <div class="search-result-item-artist">${artistsStr}  ${trackCount} song${trackCount !== 1 ? 's' : ''}</div>
                </div>
                ${trackCount === 1 
                    ? `<button class="search-result-add-btn" onclick="addSingleSongFromAlbum('${albEsc}'); event.stopPropagation();" title="Add song">
                        <i class="fa-solid fa-plus"></i>
                       </button>`
                    : `<button class="search-result-add-btn" onclick="addEntireAlbum('${albEsc}'); event.stopPropagation();" title="Add entire album">
                        <i class="fa-solid fa-plus"></i>
                       </button>`
                }
            </div>
        `;
    }).join('');
    
    div.classList.add("visible");
    div.style.display = "block";
}

function openAlbumChecklist(album) {
    if (!currentAlbumMap[album]) return;
    document.getElementById("albumModalTitle").innerText = album;
    const list = document.getElementById("albumSongList");
    list.innerHTML = "";
    const tracks = currentAlbumMap[album].tracks;
    
    // Try to load album art from IndexedDB if not in memory
    let albumArt = albumArtCache[album];
    if (!albumArt && album !== "Unknown") {
        loadAlbumArtFromDB(album).then(art => {
            if (art) {
                albumArtCache[album] = art;
                // Update all track art in the modal
                list.querySelectorAll('.album-modal-item-art').forEach(el => {
                    el.innerHTML = `<img src="${art}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                });
            }
        });
    }
    
    tracks.forEach(tr => {
        const m = tr.meta;
        const alb = m.album;
        let artHTML = '<div class="no-art"><i class="fa-solid fa-music"></i></div>';
        if (tempArtCache[tr.id]) {
            artHTML = `<img src="${tempArtCache[tr.id]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        } else if (alb && alb !== "Unknown" && albumArtCache[album]) {
            artHTML = `<img src="${albumArtCache[album]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
        } else if (!tempArtCache[tr.id]) {
            // Trigger metadata load
            loadMetaAndArt(tr.id, '');
        }
        
        const item = document.createElement("div");
        item.className = "album-modal-item selected";
        item.innerHTML = `
            <input type="checkbox" checked data-id="${tr.id}" style="display:none;">
            <div class="album-modal-checkbox">
                <i class="fa-solid fa-check"></i>
            </div>
            <div class="album-modal-item-art">${artHTML}</div>
            <div class="album-modal-item-info">
                <div class="album-modal-item-title">${tr.meta.title || "Unknown Title"}</div>
                <div class="album-modal-item-artist">${tr.meta.artist || "Unknown Artist"}</div>
            </div>
        `;
        
        // Add toggle functionality
        item.addEventListener('click', () => {
            const checkbox = item.querySelector('input[type="checkbox"]');
            checkbox.checked = !checkbox.checked;
            item.classList.toggle('selected', checkbox.checked);
        });
        
        list.appendChild(item);
        if (!tempArtCache[tr.id] && !(alb && albumArtCache[alb])) {
            loadMetaAndArt(tr.id, '');
        }
    });
        // Show modal with animation
    const overlay = document.getElementById("albumModalOverlay");
    overlay.style.display = "flex";
    // Small delay to allow display:flex to apply before adding visible class for transition
    setTimeout(() => overlay.classList.add('visible'), 10);
}

function selectAllAlbumSongs() {
    document.querySelectorAll("#albumSongList input[type=checkbox]").forEach(cb => cb.checked = true);
}

function deselectAllAlbumSongs() {
    document.querySelectorAll("#albumSongList input[type=checkbox]").forEach(cb => cb.checked = false);
}

function addSelectedAlbumSongs() {
    const checked = document.querySelectorAll("#albumSongList input[type=checkbox]:checked");
    checked.forEach(cb => {
        const id = cb.dataset.id;
        if (!playlists[currentPlaylistName].some(t => t.id === id)) {
            playlists[currentPlaylistName].push({id});
        }
    });
    localStorage.setItem('goot_playlists', JSON.stringify(playlists));
    
    const count = checked.length;
    showNotification(`Added ${count} song${count !== 1 ? 's' : ''} to "${currentPlaylistName}"`);
    closeAlbumModal();
    
    // Defer renders for smoother UI
    setTimeout(() => {
        renderTrackTable(playlists[currentPlaylistName], document.getElementById("playlistSongBody"), true, currentPlaylistName);
        renderPlaylists();
        if (currentQueueSource === `playlist:${currentPlaylistName}`) {
            queue = playlists[currentPlaylistName].map(e => ({id: e.id}));
            renderQueue();
        }
        initPlaylistSortable();
    }, 0);
}

function addSingleSongFromAlbum(album) {
    if (!currentAlbumMap[album]) return;
    const tracks = currentAlbumMap[album].tracks;
    if (tracks.length === 0) return;
    
    // Add the single track
    const track = tracks[0];
    if (!playlists[currentPlaylistName].some(t => t.id === track.id)) {
        playlists[currentPlaylistName].push({id: track.id});
    }
    localStorage.setItem('goot_playlists', JSON.stringify(playlists));
    
    const title = track.meta.title || 'Unknown Title';
    showNotification(`Added "${title}" to "${currentPlaylistName}"`);
    
    // Defer renders for smoother UI
    setTimeout(() => {
        renderTrackTable(playlists[currentPlaylistName], document.getElementById("playlistSongBody"), true, currentPlaylistName);
        renderPlaylists();
        if (currentQueueSource === `playlist:${currentPlaylistName}`) {
            queue = playlists[currentPlaylistName].map(e => ({id: e.id}));
            renderQueue();
        }
        initPlaylistSortable();
    }, 0);
}

function addEntireAlbum(album) {
    if (!currentAlbumMap[album]) return;
    const tracks = currentAlbumMap[album].tracks;
    const trackCount = tracks.length;
    tracks.forEach(tr => {
        if (!playlists[currentPlaylistName].some(t => t.id === tr.id)) {
            playlists[currentPlaylistName].push({id: tr.id});
        }
    });
    localStorage.setItem('goot_playlists', JSON.stringify(playlists));
    
    showNotification(`Added ${trackCount} song${trackCount !== 1 ? 's' : ''} from "${album}" to "${currentPlaylistName}"`);
    
    // Defer renders for smoother UI
    setTimeout(() => {
        renderTrackTable(playlists[currentPlaylistName], document.getElementById("playlistSongBody"), true, currentPlaylistName);
        renderPlaylists();
        if (currentQueueSource === `playlist:${currentPlaylistName}`) {
            queue = playlists[currentPlaylistName].map(e => ({id: e.id}));
            renderQueue();
        }
        initPlaylistSortable();
    }, 0);
}

function closeAlbumModal() {
    const overlay = document.getElementById("albumModalOverlay");
    overlay.classList.remove('visible');
    // Wait for animation to complete before hiding
    setTimeout(() => {
        overlay.style.display = "none";
    }, 300);
}

// ========== Folder Add to Playlist Modal ==========
let currentFolderTracks = [];
let selectedFolderTracks = new Set();

function openFolderAddModal() {
    const currentFolderId = stack[stack.length - 1].id;
    const currentFolderName = stack[stack.length - 1].name;

    document.getElementById('folderAddModalSubtitle').textContent = currentFolderName;

    // Get all audio files from current folder (not recursive for this modal)
    getFolderContents(currentFolderId).then(files => {
        const tracks = files.filter(f => f.mimeType.includes('audio'));
        tracks.sort((a,b) => a.name.localeCompare(b.name, undefined, {numeric: true}));

        currentFolderTracks = tracks;
        selectedFolderTracks.clear();

        const list = document.getElementById('folderSongList');
        list.innerHTML = '';

        if (tracks.length === 0) {
            list.innerHTML = '<div style="padding:32px;text-align:center;opacity:0.6;">No audio files in this folder</div>';
        } else {
            tracks.forEach((t, index) => {
                const m = trackMetadata[t.id] || {title: t.name || "...", artist: "...", album: "..."};
                const div = document.createElement('div');
                div.className = 'album-modal-item';
                
                // Get album for this track
                const album = trackMetadata[t.id]?.album;
                let artHTML = '';
                
                if (album && albumArtCache[album]) {
                    artHTML = `<img src="${albumArtCache[album]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                } else if (tempArtCache[t.id]) {
                    artHTML = `<img src="${tempArtCache[t.id]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
                } else {
                    artHTML = `<div class="no-art"><i class="fa-solid fa-music"></i></div>`;
                }
                
                div.innerHTML = `
                    <div class="album-modal-item-art">${artHTML}</div>
                    <div class="album-modal-item-info">
                        <div class="album-modal-item-title">${m.title}</div>
                        <div class="album-modal-item-artist">${m.artist}</div>
                    </div>
                    <div class="album-modal-checkbox" onclick="toggleFolderSong(this, '${t.id}')">
                        <i class="fa-solid fa-check"></i>
                    </div>
                `;
                // Store track id on the element for easy access
                div.dataset.trackId = t.id;
                list.appendChild(div);
            });

            // Load missing metadata
            tracks.forEach(t => {
                if (!trackMetadata[t.id]) {
                    loadMetaAndArt(t.id, t.name || '');
                }
            });
        }

        const overlay = document.getElementById("folderAddModalOverlay");
        overlay.style.display = 'flex';
        setTimeout(() => overlay.classList.add('visible'), 10);
    });
}

function toggleFolderSong(checkbox, trackId) {
    const item = checkbox.closest('.album-modal-item');
    if (selectedFolderTracks.has(trackId)) {
        selectedFolderTracks.delete(trackId);
        item.classList.remove('selected');
    } else {
        selectedFolderTracks.add(trackId);
        item.classList.add('selected');
    }
}

function selectAllFolderSongs() {
    document.querySelectorAll("#folderSongList .album-modal-item").forEach(item => {
        const trackId = item.dataset.trackId;
        selectedFolderTracks.add(trackId);
        item.classList.add('selected');
    });
}

function deselectAllFolderSongs() {
    document.querySelectorAll("#folderSongList .album-modal-item").forEach(item => {
        const trackId = item.dataset.trackId;
        selectedFolderTracks.delete(trackId);
        item.classList.remove('selected');
    });
}

function closeFolderAddModal() {
    const overlay = document.getElementById("folderAddModalOverlay");
    overlay.classList.remove("visible");
    setTimeout(() => {
        overlay.style.display = "none";
    }, 300);
    currentFolderTracks = [];
    selectedFolderTracks.clear();
}

// Update album art in folder add modal when metadata loads
function updateFolderModalArt(trackId) {
    const modalOverlay = document.getElementById("folderAddModalOverlay");
    if (modalOverlay.style.display !== "flex") return;

    const item = document.querySelector(`#folderSongList .album-modal-item[data-track-id="${trackId}"]`);
    if (!item) return;

    const artContainer = item.querySelector(".album-modal-item-art");
    if (!artContainer) return;

    const album = trackMetadata[trackId]?.album;
    let newArtHTML = "";

    if (album && albumArtCache[album]) {
        newArtHTML = `<img src="${albumArtCache[album]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
    } else if (tempArtCache[trackId]) {
        newArtHTML = `<img src="${tempArtCache[trackId]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">`;
    }

    if (newArtHTML && !artContainer.querySelector("img.loaded")) {
        artContainer.innerHTML = newArtHTML;
    }
}

function openPlaylistSelectionForFolder() {
    if (selectedFolderTracks.size === 0) {
        showNotification('No tracks selected');
        return;
    }

    // Show playlist selection modal
    const list = document.getElementById('playlistSelectList');
    const playlistNames = Object.keys(playlists);

    if (playlistNames.length === 0) {
        list.innerHTML = '<div style="text-align:center;padding:40px 20px;opacity:0.6;">No playlists yet</div>';
    } else {
        list.innerHTML = playlistNames.map(n => {
            const trackCount = Array.isArray(playlists[n]) ? playlists[n].length : 0;
            return `
                <div class="playlist-modal-item" onclick="addSelectedFolderTracksToPlaylist('${n}')">
                    <div class="playlist-modal-item-icon">
                        <i class="fa-solid fa-music"></i>
                    </div>
                    <div class="playlist-modal-item-info">
                        <div class="playlist-modal-item-name">${n}</div>
                        <div class="playlist-modal-item-count">${trackCount} track${trackCount !== 1 ? 's' : ''}</div>
                    </div>
                    <div class="playlist-modal-item-arrow">
                        <i class="fa-solid fa-chevron-right"></i>
                    </div>
                </div>
            `;
        }).join('');
    }

    const overlay = document.getElementById("playlistSelectModalOverlay");
    overlay.style.display = 'flex';
    setTimeout(() => overlay.classList.add('visible'), 10);
}

function closePlaylistSelectModal() {
    const overlay = document.getElementById("playlistSelectModalOverlay");
    overlay.classList.remove('visible');
    setTimeout(() => {
        overlay.style.display = "none";
    }, 300);
}

function addSelectedFolderTracksToPlaylist(playlistName) {
    if (!Array.isArray(playlists[playlistName])) playlists[playlistName] = [];

    selectedFolderTracks.forEach(trackId => {
        if (!playlists[playlistName].some(t => t.id === trackId)) {
            playlists[playlistName].push({id: trackId});
        }
    });

    localStorage.setItem('goot_playlists', JSON.stringify(playlists));
    renderPlaylists();
    closePlaylistSelectModal();
    closeFolderAddModal();
    showNotification(`Added ${selectedFolderTracks.size} track${selectedFolderTracks.size !== 1 ? 's' : ''} to "${playlistName}"`);
}

function createNewPlaylistForFolder() {
    const name = prompt("Enter playlist name:");
    if (name) {
        playlists[name] = [];
        localStorage.setItem('goot_playlists', JSON.stringify(playlists));
        renderPlaylists();
        addSelectedFolderTracksToPlaylist(name);
    }
}

document.addEventListener('click', function(e) {
    const searchContainer = document.querySelector('.search-container');
    if (!searchContainer || searchContainer.contains(e.target)) return;
    const results = document.getElementById("searchResults");
    results.classList.remove("visible");
    results.style.display = "none";
});

function addToQueue(trackId) {
    // Add track to end of queue
    queue.push({id: trackId});
    
    // Get track title for notification
    const m = trackMetadata[trackId];
    const title = m?.title || 'Unknown Title';
    showNotification(`Added "${title}" to queue`);
    
    // Visual feedback - briefly flash the queue button
    const trackRow = document.getElementById(`row-${trackId}`);
    if (trackRow) {
        trackRow.style.background = 'var(--md-sys-color-primary-container)';
        setTimeout(() => {
            trackRow.style.background = '';
        }, 300);
    }
    
    // Defer queue render for smoother UI
    setTimeout(() => renderQueue(), 0);
}

function removeFromQueue(trackId) {
    const idx = queue.findIndex(t => t.id === trackId);
    if (idx === -1) return;
    
    // Get track title for notification before removal
    const removedTrack = queue[idx];
    const m = trackMetadata[trackId];
    const title = m?.title || 'Unknown Title';
    
    // If removing the currently playing track, skip to next track
    if (idx === qIndex && player) {
        queue.splice(idx, 1);
        if (queue.length > 0) {
            // Calculate new index (next track or 0 if at end)
            const newIdx = idx < queue.length ? idx : 0;
            play(newIdx);
        } else {
            player.pause();
            document.body.classList.remove('playing');
        }
        showNotification(`Removed "${title}" from queue`);
    } else {
        // Just remove from queue
        queue.splice(idx, 1);
        // Adjust qIndex if needed
        if (idx < qIndex) {
            qIndex--;
        }
        showNotification(`Removed "${title}" from queue`);
        // Defer queue render for smoother UI
        setTimeout(() => renderQueue(), 0);
    }
}

function removeFromPlaylist(e, playlistName, trackId) {
    e.stopPropagation();
    const currentId = queue[qIndex]?.id;
    playlists[playlistName] = playlists[playlistName].filter(t => t.id !== trackId);
    localStorage.setItem('goot_playlists', JSON.stringify(playlists));
    
    // Get track title for notification
    const m = trackMetadata[trackId];
    const title = m?.title || 'Unknown Title';
    showNotification(`Removed "${title}" from "${playlistName}"`);
    
    // Defer renders for smoother UI but always use staggered animation
    setTimeout(() => {
        renderTrackTable(playlists[playlistName], document.getElementById("playlistSongBody"), true, playlistName, true, false);
        renderPlaylists();
    }, 0);
    
    const coverEl = document.getElementById("playlistCover");
    coverEl.innerHTML = '<div class="no-art"><i class="fa-solid fa-compact-disc"></i></div>';
    if (playlists[playlistName].length > 0) {
        const firstId = playlists[playlistName][0].id;
        const firstMeta = trackMetadata[firstId];
        const album = firstMeta?.album;

        if (tempArtCache[firstId]) {
            coverEl.innerHTML = `
                <img src="${tempArtCache[firstId]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">
                </div>
            `;
        } else if (album && album !== "Unknown" && albumArtCache[album]) {
            coverEl.innerHTML = `
                <img src="${albumArtCache[album]}" class="loaded" style="width:100%;height:100%;object-fit:cover;">
                </div>
            `;
        } else if (album && album !== "Unknown") {
            // Try loading from IndexedDB
            loadAlbumArtFromDB(album).then(art => {
                if (art) {
                    albumArtCache[album] = art;
                    coverEl.innerHTML = `
                        <img src="${art}" class="loaded" style="width:100%;height:100%;object-fit:cover;">
                        </div>
                    `;
                } else {
                    coverEl.innerHTML = `
                        <div class="no-art"><i class="fa-solid fa-compact-disc"></i></div>
                        </div>
                    `;
                    loadMetaAndArt(firstId, '');
                }
            });
        } else {
            coverEl.innerHTML = `
                <div class="no-art"><i class="fa-solid fa-compact-disc"></i></div>
                </div>
            `;
            loadMetaAndArt(firstId, '');
        }
    }
    if (currentQueueSource === `playlist:${playlistName}`) {
        queue = playlists[playlistName].map(e => ({id: e.id}));
        const newIdx = currentId ? queue.findIndex(t => t.id === currentId) : -1;
        if (newIdx !== -1) {
            qIndex = newIdx;
        } else {
            qIndex = Math.max(0, qIndex - 1);
            if (queue.length > 0) play(qIndex);
        }
        // Defer renderQueue for smoother UI
        setTimeout(() => renderQueue(), 0);
    }
    initPlaylistSortable();
}

function renameCurrentPlaylist() {
    let newName = prompt("Enter new playlist name:", currentPlaylistName);
    if (!newName || newName.trim() === "" || newName === currentPlaylistName) return;
    newName = newName.trim();
    if (playlists[newName]) {
        alert("A playlist with that name already exists.");
        return;
    }
    const oldName = currentPlaylistName;
    playlists[newName] = playlists[oldName];
    delete playlists[oldName];
    if (currentQueueSource === `playlist:${oldName}`) {
        currentQueueSource = `playlist:${newName}`;
    }
    currentPlaylistName = newName;
    localStorage.setItem('goot_playlists', JSON.stringify(playlists));
    document.getElementById("currentPlaylistTitle").innerText = newName;
    renderPlaylists();
}

function deleteCurrentPlaylist() {
    if (confirm(`Delete playlist "${currentPlaylistName}" permanently? This cannot be undone.`)) {
        if (currentQueueSource === `playlist:${currentPlaylistName}`) {
            currentQueueSource = null;
            queue = [];
            qIndex = -1;
            // Defer renderQueue for smoother UI
            setTimeout(() => renderQueue(), 0);
            player.pause();
            player.src = "";
        }
        delete playlists[currentPlaylistName];
        localStorage.setItem('goot_playlists', JSON.stringify(playlists));
        backToPlaylistGrid();
        renderPlaylists();
    }
}

// Toggle pin current playlist to Listen Again
function togglePinCurrentPlaylist() {
    const name = currentPlaylistName;
    if (!name) return;
    
    if (isPinned('playlists', name)) {
        unpinItem('playlists', name);
    } else {
        // Get playlist cover art
        let art = '';
        const firstId = playlists[name]?.[0]?.id;
        if (firstId) {
            const meta = trackMetadata[firstId];
            art = meta?.albumArt || meta?.art || '';
        }
        
        pinItem('playlists', name, {
            name: name,
            art: art,
            trackCount: Array.isArray(playlists[name]) ? playlists[name].length : 0
        });
    }
    
    // Update the button state
    updatePinPlaylistButton();
}

// Update the pin button in playlist detailed view
function updatePinPlaylistButton() {
    const btn = document.getElementById('pinToListenAgainBtn');
    const label = document.getElementById('pinToListenAgainLabel');
    if (!btn || !label) return;
    
    const isPinnedPlaylist = currentPlaylistName && isPinned('playlists', currentPlaylistName);
    
    if (isPinnedPlaylist) {
        btn.innerHTML = '<i class="fa-solid fa-xmark"></i><span>Remove</span>';
    } else {
        btn.innerHTML = '<i class="fa-solid fa-heart"></i><span>Pin to Listen Again</span>';
    }
}

function importPlaylists(input) {
    const file = input.files[0];
    if (!file) return;
    const r = new FileReader();
    r.onload = e => {
        try {
            const imported = JSON.parse(e.target.result);
            let changed = false;
            for (const name in imported) {
                const data = imported[name];
                if (!playlists[name]) {
                    playlists[name] = data;
                    changed = true;
                } else {
                    const existing = playlists[name];
                    if (!Array.isArray(existing)) existing = [];
                    const existingIds = new Set(existing.map(t => t.id));
                    const importedTracks = Array.isArray(data) ? data : [];
                    for (const track of importedTracks) {
                        if (track.id && !existingIds.has(track.id)) {
                            existing.push(track);
                            changed = true;
                        }
                    }
                    if (data.customCover) {
                        existing.customCover = data.customCover;
                        changed = true;
                    }
                }
            }
            if (changed) {
                localStorage.setItem('goot_playlists', JSON.stringify(playlists));
                renderPlaylists();
                
                // If the currently open playlist was imported/merged, update its view
                if (currentPlaylistName && playlists[currentPlaylistName]) {
                    renderTrackTable(playlists[currentPlaylistName], document.getElementById("playlistSongBody"), true, currentPlaylistName);
                }
                alert("Playlists imported and merged successfully.");
            } else {
                alert("No new playlists or tracks found to import.");
            }
        } catch (err) {
            alert("Invalid playlist file.");
        }
        input.value = "";
    };
    r.readAsText(file);
}

async function loadAllTrackInfo() {
    const btn = document.getElementById("loadAllBtn");
    const cancelBtn = document.getElementById("cancelBtn");
    const progressContainer = document.getElementById("progressContainer");
    const progressBar = document.getElementById("progressBar");
    const progressText = document.getElementById("progressText");
    const loadControls = document.getElementById("loadControls");
    if (isLoadingAll) return;
    isLoadingAll = true;
    shouldCancelLoad = false;
    loadLog = [];
    processedFiles = 0;
    totalFilesToLoad = 0;
    btn.disabled = true;
    btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Loading...';
    progressContainer.style.display = "block";
    loadControls.style.display = "flex";
    progressBar.style.width = "0%";
    progressText.textContent = "Scanning files...";
    const currentFolderId = stack[stack.length-1].id;
    await countFilesRecursive(currentFolderId);
    if (totalFilesToLoad === 0) {
        progressText.textContent = "No audio files found.";
        resetLoadUI();
        return;
    }
    progressText.textContent = `0 / ${totalFilesToLoad} (0%)`;
    updateLogDisplay();
    await processFilesRecursive(currentFolderId);
    if (shouldCancelLoad) {
        progressText.textContent = "Loading cancelled.";
        addToLog("Loading cancelled by user.");
    } else {
        progressText.textContent = `Done! ${processedFiles} / ${totalFilesToLoad} processed.`;
        addToLog("Loading completed.");
    }
    setTimeout(resetLoadUI, 3000);
}

async function countFilesRecursive(folderId) {
    if (shouldCancelLoad) return;
    try {
        const files = await getFolderContents(folderId);
        totalFilesToLoad += files.filter(f => f.mimeType.includes('audio')).length;
        const folders = files.filter(f => f.mimeType === 'application/vnd.google-apps.folder');
        for (const f of folders) {
            await countFilesRecursive(f.id);
        }
    } catch(e) {
        console.error('Error counting files:', e);
        addToLog(`Error counting in folder ${folderId}`);
    }
}

async function processFilesRecursive(folderId) {
    if (shouldCancelLoad) return;
    try {
        const files = await getFolderContents(folderId);
        const tracks = files.filter(f => f.mimeType.includes('audio'));
        for (const t of tracks) {
            if (shouldCancelLoad) break;
            addToLog(`Processing: ${t.name} (ID: ${t.id})`);
            await loadMetaAndArt(t.id, t.name);
            processedFiles++;
            const percent = Math.round((processedFiles / totalFilesToLoad) * 100);
            document.getElementById("progressBar").style.width = percent + "%";
            document.getElementById("progressText").textContent = `${processedFiles} / ${totalFilesToLoad} (${percent}%)`;
            updateLogDisplay();
        }
        const folders = files.filter(f => f.mimeType === 'application/vnd.google-apps.folder');
        for (const f of folders) {
            if (shouldCancelLoad) break;
            await processFilesRecursive(f.id);
        }
    } catch(e) {
        console.error('Error processing files:', e);
        addToLog(`Error processing folder ${folderId}`);
    }
}

function addToLog(message) {
    const timestamp = new Date().toLocaleTimeString([], {hour12: false});
    loadLog.push(`[${timestamp}] ${message}`);
    if (logModalOpen) updateLogDisplay();
}

function updateLogDisplay() {
    const content = document.getElementById("logContent");
    const status = document.getElementById("logStatus");
    content.textContent = loadLog.join("\n");
    status.textContent = isLoadingAll ? "(Loading in progress)" : "(Completed)";
    if (document.getElementById("autoScroll").checked) {
        content.scrollTop = content.scrollHeight;
    }
}

function cancelLoad() {
    shouldCancelLoad = true;
    document.getElementById("progressText").textContent = "Cancelling...";
    addToLog("Cancel requested...");
}

function resetLoadUI() {
    const btn = document.getElementById("loadAllBtn");
    const progressContainer = document.getElementById("progressContainer");
    const loadControls = document.getElementById("loadControls");
    if(btn) {
        btn.disabled = false;
        btn.innerHTML = '<i class="fa-solid fa-download"></i> Load All Track Info';
    }
    progressContainer.style.display = "none";
    loadControls.style.display = "none";
    isLoadingAll = false;
}

function showLog() {
    logModalOpen = true;
    updateLogDisplay();
    document.getElementById("logOverlay").style.display = "flex";
}

function closeLog() {
    logModalOpen = false;
    document.getElementById("logOverlay").style.display = "none";
}

function clearAllCache() {
    if (confirm("This will delete ALL cached metadata, album art, and reset related settings.\nAre you sure?")) {
        localStorage.removeItem('goot_meta_cache');
        trackMetadata = {};
        tempArtCache = {};
        albumArtCache = {};
        alert("Cache cleared! Refresh the page to see full effect.");
    }
}

function hardReset() {
    if (!confirm("WARNING: This will DELETE ALL Goot data including:\n All metadata and album art\n Play counts and Listen Again history\n All playlists\n Theme and settings\n\nThis cannot be undone!\n\nAre you absolutely sure?")) {
        return;
    }
    
    // Double confirmation for safety
    if (!confirm("Are you REALLY sure? All your data will be permanently deleted.")) {
        return;
    }
    
    // Clear all localStorage items first
    const keysToRemove = [
        'goot_meta_cache',
        'goot_play_counts',
        'goot_playlists',
        'goot_most_played',
        'goot_pinned_items',
        'goot_accent',
        'goot_album_color',
        'goot_theme',
        'goot_hide_played',
        'goot_sort_order',
        'goot_auto_play',
        'goot_volume',
        'goot_queue',
        'goot_listen_again_cache',
        'goot_folder_state'
    ];
    
    keysToRemove.forEach(key => {
        localStorage.removeItem(key);
    });
    
    // Clear in-memory data
    trackMetadata = {};
    tempArtCache = {};
    albumArtCache = {};
    playCounts = {};
    playlists = {};
    pinnedItems = { tracks: [], folders: [] };
    mostPlayedCache = [];
    allTracks = [];
    currentFolderTracks = [];
    selectedFolderTracks.clear();
    
    // Reset IndexedDB state
    metaDB = null;
    metaDBReady = false;
    
    // Delete IndexedDB and wait for it to complete
    const dbName = 'GootPlayerDB';
    const deleteRequest = indexedDB.deleteDatabase(dbName);
    
    deleteRequest.onsuccess = function() {
        console.log('[HardReset] IndexedDB deleted successfully');
        // Reload after deletion completes
        setTimeout(() => {
            location.reload(true); // true = force reload from server
        }, 100);
    };
    
    deleteRequest.onerror = function() {
        console.error('[HardReset] Failed to delete IndexedDB');
        // Still reload even if there was an error
        setTimeout(() => {
            location.reload(true);
        }, 100);
    };
    
    deleteRequest.onblocked = function() {
        console.log('[HardReset] IndexedDB deletion blocked, still reloading...');
        setTimeout(() => {
            location.reload(true);
        }, 100);
    };
}

function isColorTooLight(r, g, b) {
    // Check if a color is too light (close to white)
    // Using relative luminance formula
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    // If luminance is above 0.85, the color is too light/close to white
    return luminance > 0.85;
}

function ensureReadableColor(hex) {
    // Ensure the accent color is readable - not too dark
    const rgb = hexToRgb(hex);
    if (!rgb) return hex;
    
    const luminance = (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255;
    
    // If color is too dark (luminance < 0.2), lighten it
    if (luminance < 0.2) {
        // Lighten the color by mixing with white
        const factor = 0.3; // How much to mix with white
        const r = Math.round(rgb.r + (255 - rgb.r) * factor);
        const g = Math.round(rgb.g + (255 - rgb.g) * factor);
        const b = Math.round(rgb.b + (255 - rgb.b) * factor);
        return rgbToHex([r, g, b]);
    }
    
    return hex;
}

function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
    } : null;
}

function updateTheme(hex) {
    // Check if the color is too light (white or near-white)
    const rgb = hexToRgb(hex);
    if (rgb && isColorTooLight(rgb.r, rgb.g, rgb.b)) {
        // Skip updating if color is too light - keep the current theme
        // Optionally update the picker to show the current valid color
        const picker = document.getElementById('accentPicker');
        if (picker) {
            const currentColor = localStorage.getItem('goot_accent') || '#ff0000';
            picker.value = currentColor;
        }
        return;
    }
    
    // Ensure color is readable (not too dark)
    hex = ensureReadableColor(hex);
    
    document.documentElement.style.setProperty('--md-sys-color-primary', hex);
    document.documentElement.style.setProperty('--md-sys-color-primary-container', hex+'26');
    // Calculate darker version for expanded view gradient
    document.documentElement.style.setProperty('--md-sys-color-primary-dark', adjustColor(hex, -100));
    localStorage.setItem('goot_accent', hex);
    
    // Update color picker if it exists
    const picker = document.getElementById('accentPicker');
    if (picker) picker.value = hex;
    
    // Update custom color preview
    updateCustomColorPreview(hex);
}

function updateCustomColorPreview(hex) {
    const customPreset = document.getElementById('customColorPreset');
    if (customPreset) {
        customPreset.style.background = hex;
        customPreset.style.animation = 'none';
    }
}

function toggleAlbumColorMode() {
    const enabled = document.getElementById('albumColorToggle').checked;
    localStorage.setItem('goot_album_color', enabled);
    
    // If disabled, restore the custom accent color
    if (!enabled) {
        const customColor = localStorage.getItem('goot_accent') || '#ff0000';
        updateTheme(customColor);
    } else if (queue[qIndex]?.id) {
        // If enabled and a track is playing, extract color from its art
        extractColorFromAlbumArt(queue[qIndex].id);
    }
}

function extractColorFromAlbumArt(id) {
    // Skip during bulk metadata loading to prevent lag
    if (isBulkMetadataLoading) return;
    
    // Check if album color mode is enabled
    if (localStorage.getItem('goot_album_color') !== 'true') return;
    
    // Get album name for caching
    const album = trackMetadata[id]?.album;
    if (!album || album === "Unknown") {
        // Fallback if no album metadata
        const customColor = localStorage.getItem('goot_accent') || '#ff0000';
        if (queue[qIndex]?.id === id) {
            updateTheme(customColor);
        }
        return;
    }
    
    // Check localStorage cache first
    const albumAccentCache = JSON.parse(localStorage.getItem('goot_album_accent_cache') || '{}');
    if (albumAccentCache[album]) {
        // Use cached color for this album
        if (queue[qIndex]?.id === id) {
            updateTheme(albumAccentCache[album]);
        }
        return;
    }
    
    // Get the art source - prefer individual track art, then album art
    let artSrc = tempArtCache[id];
    if (!artSrc) {
        artSrc = albumArtCache[album];
    }
    
    if (!artSrc) return;
    
    // Create an image to extract color
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    
    img.onload = function() {
        // Find the most vibrant color using the new algorithm
        const vibrantColor = findMostVibrant(img);
        if (vibrantColor && queue[qIndex]?.id === id) {
            const hexColor = rgbToHex(vibrantColor.rgb);
            
            // Check if the color is essentially grayscale (black/white/gray album art)
            const rgb = vibrantColor.rgb;
            const isGrayscale = isColorGrayscale(rgb[0], rgb[1], rgb[2]);
            
            // Use #666666 for grayscale albums, otherwise use the extracted color
            const finalColor = isGrayscale ? '#666666' : hexColor;
            updateTheme(finalColor);
            
            // Cache this color for the album
            const cache = JSON.parse(localStorage.getItem('goot_album_accent_cache') || '{}');
            cache[album] = finalColor;
            localStorage.setItem('goot_album_accent_cache', JSON.stringify(cache));
        }
    };
    
    img.onerror = function() {
        // Fallback to custom color if extraction fails
        const customColor = localStorage.getItem('goot_accent') || '#ff0000';
        if (queue[qIndex]?.id === id) {
            updateTheme(customColor);
        }
    };
    
    img.src = artSrc;
}

function findMostCommonVibrantColor(img) {
    try {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        
        // Sample pixels with larger step for performance
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        const data = imageData.data;
        const w = imageData.width;
        const h = imageData.height;
        
        // Quantize colors to group similar ones together
        const colorCounts = {};
        const quantization = 16; // Smaller quantization for more precise color grouping
        
        // Sample every 20th pixel for performance, but focus on center area to avoid borders
        const startX = Math.floor(w * 0.1);
        const endX = Math.floor(w * 0.9);
        const startY = Math.floor(h * 0.1);
        const endY = Math.floor(h * 0.9);
        
        for (let y = startY; y < endY; y += 4) {
            for (let x = startX; x < endX; x += 20) {
                const i = (y * w + x) * 4;
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];
                
                // Skip transparent or very dark pixels
                if (a < 128) continue;
                
                // Calculate brightness - skip very dark and very light pixels
                const brightness = (r + g + b) / 3;
                if (brightness < 50 || brightness > 240) continue;
                
                // Calculate saturation
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const saturation = max === 0 ? 0 : (max - min) / max;
                
                // Only consider very vibrant colors (saturation > 0.5)
                if (saturation < 0.5) continue;
                
                // Quantize the color to group similar ones
                const qr = Math.round(r / quantization) * quantization;
                const qg = Math.round(g / quantization) * quantization;
                const qb = Math.round(b / quantization) * quantization;
                
                const key = `${qr},${qg},${qb}`;
                
                if (!colorCounts[key]) {
                    colorCounts[key] = { count: 0, r: qr, g: qg, b: qb, brightness, saturation };
                }
                colorCounts[key].count++;
            }
        }
        
        // Find the color with highest saturation weighted by frequency
        // Formula: sqrt(count) * saturation^3 - heavily prioritizes vibrancy
        let maxScore = 0;
        let bestColor = null;
        
        Object.values(colorCounts).forEach(color => {
            const score = Math.sqrt(color.count) * Math.pow(color.saturation, 3);
            if (score > maxScore) {
                maxScore = score;
                bestColor = color;
            }
        });
        
        if (!bestColor || maxScore < 0.1) {
            // Fallback: try with more lenient filtering but still prioritize saturation
            for (let i = 0; i < data.length; i += 16) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const a = data[i + 3];
                
                if (a < 128) continue;
                
                const brightness = (r + g + b) / 3;
                if (brightness < 40) continue;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                const saturation = max === 0 ? 0 : (max - min) / max;
                
                if (saturation < 0.4) continue;
                
                const qr = Math.round(r / quantization) * quantization;
                const qg = Math.round(g / quantization) * quantization;
                const qb = Math.round(b / quantization) * quantization;
                const key = `${qr},${qg},${qb}`;
                
                if (!colorCounts[key]) {
                    colorCounts[key] = { count: 0, r: qr, g: qg, b: qb, brightness, saturation };
                }
                colorCounts[key].count++;
            }
            
            Object.values(colorCounts).forEach(color => {
                const score = Math.sqrt(color.count) * Math.pow(color.saturation, 3);
                if (score > maxScore) {
                    maxScore = score;
                    bestColor = color;
                }
            });
        }
        
        if (!bestColor) {
            // Final fallback to orange if no vibrant colors found
            return '#ff6600';
        }
        
        // Convert to hex
        const hex = '#' + [bestColor.r, bestColor.g, bestColor.b].map(x => {
            const hex = x.toString(16);
            return hex.length === 1 ? '0' + hex : hex;
        }).join('');
        
        return hex;
    } catch (e) {
        return '#ff6600'; // Default to orange on error
    }
}

function findMostVibrant(img) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    const maxSize = 200;
    let width = img.width;
    let height = img.height;
    
    if (width > height) {
        if (width > maxSize) {
            height = Math.round((height * maxSize) / width);
            width = maxSize;
        }
    } else {
        if (height > maxSize) {
            width = Math.round((width * maxSize) / height);
            height = maxSize;
        }
    }
    
    canvas.width = width;
    canvas.height = height;
    ctx.drawImage(img, 0, 0, width, height);
    
    const imageData = ctx.getImageData(0, 0, width, height);
    const pixels = imageData.data;
    
    // Collect vibrant colors
    const colorGroups = {};
    const binSize = 15;
    
    for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        const a = pixels[i + 3];
        
        if (a < 128) continue;
        
        const hsl = rgbToHsl(r, g, b);
        
        // Skip very dark or very desaturated colors
        if (hsl.l < 0.15 || hsl.s < 0.15) continue;
        
        // Quantize
        const qr = Math.round(r / binSize) * binSize;
        const qg = Math.round(g / binSize) * binSize;
        const qb = Math.round(b / binSize) * binSize;
        
        const key = `${qr},${qg},${qb}`;
        
        if (!colorGroups[key]) {
            colorGroups[key] = {
                r: 0, g: 0, b: 0,
                h: 0, s: 0, l: 0,
                count: 0, score: 0
            };
        }
        
        colorGroups[key].r += r;
        colorGroups[key].g += g;
        colorGroups[key].b += b;
        colorGroups[key].h += hsl.h;
        colorGroups[key].s += hsl.s;
        colorGroups[key].l += hsl.l;
        colorGroups[key].count++;
    }
    
    // Calculate scores
    let bestColor = null;
    let bestScore = -1;
    
    for (const key in colorGroups) {
        const color = colorGroups[key];
        const avgR = Math.round(color.r / color.count);
        const avgG = Math.round(color.g / color.count);
        const avgB = Math.round(color.b / color.count);
        const avgH = color.h / color.count;
        const avgS = color.s / color.count;
        const avgL = color.l / color.count;
        
        // VIBE SCORE CALCULATION
        let score = 0;
        
        // Saturation weight: 3x (MOST IMPORTANT)
        score += avgS * 300;
        
        // Brightness bonus: sweet spot between 40% and 80%
        if (avgL >= 0.4 && avgL <= 0.8) {
            score += 80;
        } else if (avgL >= 0.3 && avgL <= 0.85) {
            score += 40;
        } else if (avgL < 0.25) {
            score -= 50; // Too dark
        } else if (avgL > 0.9) {
            score -= 30; // Too washed out
        }
        
        // Cool color bonus (blues and purples are preferred)
        const hue = avgH;
        if (hue >= 180 && hue < 280) {
            // Blues, cyans
            score += 50;
        } else if (hue >= 280 && hue < 320) {
            // Purples, magentas (valued higher than blues)
            score += 60;
        } else if (hue >= 320 || hue < 30) {
            // Pinks, reds (same priority as blues)
            score += 50;
        } else if (hue >= 30 && hue < 60) {
            // Oranges (same priority as blues)
            score += 50;
        } else {
            // Yellows, greens (less preferred)
            score += 10;
        }
        
        // Frequency bonus (but not too much)
        score += Math.log(color.count + 1) * 10;
        
        color.score = score;
        
        if (score > bestScore) {
            bestScore = score;
            bestColor = {
                rgb: [avgR, avgG, avgB],
                hsl: { h: avgH, s: avgS, l: avgL },
                score: score
            };
        }
    }
    
    // Fallback if no vibrant colors found
    if (!bestColor) {
        bestColor = findBrightestFallback(img);
    }
    
    return bestColor;
}

function findBrightestFallback(img) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    
    canvas.width = 100;
    canvas.height = 100;
    ctx.drawImage(img, 0, 0, 100, 100);
    
    const imageData = ctx.getImageData(0, 0, 100, 100);
    const pixels = imageData.data;
    
    let brightest = [255, 255, 255];
    let maxBright = 0;
    
    for (let i = 0; i < pixels.length; i += 4) {
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        const a = pixels[i + 3];
        
        if (a < 128) continue;
        
        const brightness = (r + g + b) / 3;
        if (brightness > maxBright) {
            maxBright = brightness;
            brightest = [r, g, b];
        }
    }
    
    return {
        rgb: brightest,
        hsl: rgbToHsl(brightest[0], brightest[1], brightest[2]),
        score: 0
    };
}

function rgbToHsl(r, g, b) {
    r /= 255;
    g /= 255;
    b /= 255;
    
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const delta = max - min;
    
    let h, s;
    const l = (max + min) / 2;
    
    if (delta === 0) {
        h = 0;
        s = 0;
    } else {
        s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);
        
        switch (max) {
            case r:
                h = ((g - b) / delta + (g < b ? 6 : 0)) / 6;
                break;
            case g:
                h = ((b - r) / delta + 2) / 6;
                break;
            case b:
                h = ((r - g) / delta + 4) / 6;
                break;
        }
    }
    
    return { h: h * 360, s, l };
}

function isColorGrayscale(r, g, b) {
    // Check if color is essentially grayscale (R  G  B)
    // A color is grayscale if the difference between channels is very small
    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const diff = max - min;
    
    // If the difference is less than 10% of the range, consider it grayscale
    // Also check if the saturation is very low
    const brightness = (r + g + b) / 3;
    const saturation = max === 0 ? 0 : diff / max;
    
    // A color is grayscale if saturation is very low (< 10%)
    return saturation < 0.1;
}

function rgbToHex(rgb) {
    return '#' + rgb.map(c => {
        const hex = c.toString(16);
        return hex.length === 1 ? '0' + hex : hex;
    }).join('').toUpperCase();
}

// ==================== VOLUME NORMALIZATION ====================

/**
 * Initialize Web Audio API context for normalization
 * Uses the same context as the equalizer
 */
function initNormalizationAudio() {
    // Initialize the audio context (will use existing one if already created)
    const ctx = initAudioContext();
    if (ctx) {
        audioContext = ctx;
        // normGainNode is already created in initAudioContext
        return ctx;
    }
    return null;
}

/**
 * Toggle volume normalization on/off
 */
function toggleNormalization() {
    const toggle = document.getElementById('normToggle');
    normEnabled = toggle.checked;
    localStorage.setItem('goot_norm_enabled', normEnabled);
    
    // Initialize audio context if not already done
    initAudioContext();
    initNormalizationAudio();
    
    // Update status text
    updateNormStatus();
    
    // Apply gain to current track if playing
    if (queue[qIndex]?.id) {
        applyNormalization(queue[qIndex].id);
    }
}

/**
 * Update target loudness value
 */
/**
 * Update LUFS display during slider drag
 */
function updateLufsDisplay(value) {
    const displayEl = document.getElementById('normTargetValue');
    if (displayEl) {
        displayEl.textContent = value + ' LUFS';
    }
    
    // Update progress bar
    const progressEl = document.getElementById('lufsProgress');
    if (progressEl) {
        const min = -23;
        const max = -8;
        const percentage = ((value - min) / (max - min)) * 100;
        progressEl.style.width = percentage + '%';
    }
    
    // Update active marker
    document.querySelectorAll('.lufs-marker').forEach(marker => {
        marker.classList.toggle('active', parseInt(marker.dataset.value) === parseInt(value));
    });
}

function updateNormTarget(value) {
    normTargetLUFS = parseInt(value);
    document.getElementById('normTargetValue').textContent = normTargetLUFS + ' LUFS';
    localStorage.setItem('goot_norm_target', normTargetLUFS);
    
    // Update progress bar
    const progressEl = document.getElementById('lufsProgress');
    if (progressEl) {
        const min = -23;
        const max = -8;
        const percentage = ((normTargetLUFS - min) / (max - min)) * 100;
        progressEl.style.width = percentage + '%';
    }
    
    // Apply new target to current track
    if (queue[qIndex]?.id) {
        applyNormalization(queue[qIndex].id);
    }
}

/**
 * Update normalization status display
 */
function updateNormStatus() {
    const statusText = document.getElementById('normStatusText');
    if (!statusText) return;
    
    if (!normEnabled) {
        statusText.textContent = 'Enable to play all tracks at consistent volume';
    } else if (currentNormGain === 1.0) {
        statusText.textContent = 'All tracks will play at similar volume levels';
    } else {
        const gainDb = (20 * Math.log10(currentNormGain)).toFixed(1);
        const sign = gainDb >= 0 ? '+' : '';
        statusText.textContent = `Volume adjusted by ${sign}${gainDb} dB`;
    }
}

/**
 * Get cached loudness for a track
 */
function getTrackLoudness(trackId) {
    // Check memory cache first
    if (trackLoudnessCache[trackId] !== undefined) {
        return trackLoudnessCache[trackId];
    }
    
    // Check localStorage
    const cacheKey = `goot_loudness_${trackId}`;
    const cached = localStorage.getItem(cacheKey);
    if (cached !== null) {
        const loudness = parseFloat(cached);
        trackLoudnessCache[trackId] = loudness;
        return loudness;
    }
    
    return null;
}

/**
 * Cache track loudness
 */
function cacheTrackLoudness(trackId, loudness) {
    trackLoudnessCache[trackId] = loudness;
    const cacheKey = `goot_loudness_${trackId}`;
    localStorage.setItem(cacheKey, loudness.toFixed(2));
}

/**
 * Analyze track loudness using Web Audio API
 * Returns loudness in LUFS (integrated)
 */
async function analyzeTrackLoudness(trackId, audioUrl) {
    return new Promise(async (resolve, reject) => {
        try {
            const ctx = initAudioContext();
            
            // Fetch the audio file
            const response = await fetch(audioUrl);
            const arrayBuffer = await response.arrayBuffer();
            
            // Decode the audio data
            const audioBuffer = await ctx.decodeAudioData(arrayBuffer.slice(0));
            
            // Calculate loudness using EBU R128 algorithm approximation
            // This uses a gated loudness measurement approach
            const loudness = calculateLoudness(audioBuffer);
            
            resolve(loudness);
        } catch (error) {
            console.error('Error analyzing loudness:', error);
            // Fallback: return target loudness (no adjustment needed)
            resolve(normTargetLUFS);
        }
    });
}

/**
 * Calculate loudness of audio buffer using gated LUFS approximation
 */
function calculateLoudness(audioBuffer) {
    const channelData = audioBuffer.getChannelData(0); // Use first channel
    const sampleRate = audioBuffer.sampleRate;
    
    // Calculate RMS for each 3-second window (block size ~400ms for more precision)
    const blockSize = Math.floor(sampleRate * 0.4); // 400ms blocks
    const hopSize = Math.floor(sampleRate * 3); // 3-second gating blocks
    const gatingThreshold = -70; // LUFS
    
    let energyValues = [];
    
    // Calculate absolute RMS for each sample
    for (let i = 0; i < channelData.length; i += hopSize) {
        let sum = 0;
        let count = 0;
        
        for (let j = i; j < Math.min(i + blockSize, channelData.length); j++) {
            sum += channelData[j] * channelData[j];
            count++;
        }
        
        if (count > 0) {
            const rms = Math.sqrt(sum / count);
            // Convert to LUFS approximation (relative to full scale)
            // For simplicity, we use RMS relative to a reference level
            let db = 20 * Math.log10(rms + 1e-10); // Avoid log(0)
            let lufs = db - 0.691; // Account for relative scale
            energyValues.push(lufs);
        }
    }
    
    if (energyValues.length === 0) {
        return normTargetLUFS; // Fallback
    }
    
    // Filter out samples below gating threshold
    const gatedValues = energyValues.filter(e => e >= gatingThreshold);
    
    if (gatedValues.length === 0) {
        return normTargetLUFS; // Fallback
    }
    
    // Calculate mean energy
    const meanEnergy = gatedValues.reduce((a, b) => a + Math.pow(10, b / 10), 0) / gatedValues.length;
    const integratedLoudness = 10 * Math.log10(meanEnergy);
    
    // Adjust for channel count (simple mono/stereo correction)
    const channelCount = audioBuffer.numberOfChannels;
    const channelCorrection = channelCount > 2 ? 0 : 0; // Simplified
    
    return integratedLoudness + channelCorrection;
}

/**
 * Queue for tracks that need loudness analysis
 */
let queueLoudnessAnalysis = [];
let loudnessAnalysisRunning = false;

/**
 * Process the loudness analysis queue in the background
 */
async function processLoudnessQueue() {
    if (loudnessAnalysisRunning || queueLoudnessAnalysis.length === 0) return;
    
    loudnessAnalysisRunning = true;
    const ctx = initAudioContext();
    
    while (queueLoudnessAnalysis.length > 0) {
        const item = queueLoudnessAnalysis.shift();
        
        // Skip if already analyzed
        if (getTrackLoudness(item.trackId) !== null) continue;
        
        try {
            const loudness = await analyzeTrackLoudness(item.trackId, item.url);
            cacheTrackLoudness(item.trackId, loudness);
            
            // If this is the current playing track, apply the correct gain
            if (queue[qIndex]?.id === item.trackId && normEnabled) {
                applyNormalization(item.trackId);
            }
        } catch (error) {
            console.warn('Failed to analyze loudness for track:', item.trackId, error);
        }
        
        // Small delay between analyses to not overwhelm the system
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    loudnessAnalysisRunning = false;
}

/**
 * Force analyze loudness of current track
 */
async function analyzeCurrentTrack() {
    if (!queue[qIndex]?.id) return null;
    
    const track = queue[qIndex];
    
    // Use the same URL format as the player
    const url = WORKER_URL + "?id=" + track.id;
    
    try {
        // Test if we can fetch the audio
        const testResponse = await fetch(url, { method: 'HEAD' });
        if (!testResponse.ok) {
            return null;
        }
        
        const loudness = await analyzeTrackLoudness(track.id, url);
        cacheTrackLoudness(track.id, loudness);
        
        return loudness;
    } catch (error) {
        console.warn('Failed to analyze loudness:', track.id, error);
        return null;
    }
}

/**
 * Manual analysis wrapper that shows notification
 */
async function manualAnalyzeCurrentTrack() {
    if (!queue[qIndex]?.id) return;
    
    showNotification('Analyzing loudness...');
    
    const loudness = await analyzeCurrentTrack();
    
    if (loudness !== null) {
        // Apply the corrected normalization
        applyNormalization(queue[qIndex].id);
        
        const diff = normTargetLUFS - loudness;
        const sign = diff >= 0 ? '+' : '';
        showNotification(`Loudness: ${loudness.toFixed(1)} LUFS (${sign}${diff.toFixed(1)} dB)`);
    } else {
        showNotification('Analysis failed - audio may be protected');
    }
}

/**
 * Analyze and apply normalization for current track
 * Called automatically when a track starts playing with normalization enabled
 */
async function analyzeAndApplyNormalization(trackId) {
    // First, check if we already have loudness cached
    let trackLoudness = getTrackLoudness(trackId);
    
    // If not cached and normalization is enabled, analyze immediately
    if (trackLoudness === null && normEnabled) {
        // Show subtle notification for analysis
        const loudness = await analyzeCurrentTrack();
        if (loudness !== null) {
            trackLoudness = loudness;
        }
    }
    
    // Now apply normalization with the (potentially updated) loudness value
    applyNormalization(trackId);
}

/**
 * Calculate and apply normalization gain for a track
 */
async function applyNormalization(trackId) {
    // Ensure audio context is initialized
    initAudioContext();
    initNormalizationAudio();
    
    const ctx = audioCtx || audioContext;
    
    if (!normEnabled) {
        currentNormGain = 1.0;
        if (normGainNode && ctx) {
            // Reset to unity gain when disabled
            normGainNode.gain.setTargetAtTime(1.0, ctx.currentTime, 0.02);
            // Also relax the limiter when normalization is off
            if (limiterNode) {
                limiterNode.threshold.setValueAtTime(0, ctx.currentTime);
                limiterNode.ratio.setValueAtTime(1, ctx.currentTime);
            }
        }
        updateNormStatus();
        updateNormIndicator(null);
        return;
    }
    
    // Configure limiter for protection when normalization is active
    if (limiterNode && ctx) {
        limiterNode.threshold.setValueAtTime(-1, ctx.currentTime);
        limiterNode.knee.setValueAtTime(0, ctx.currentTime);
        limiterNode.ratio.setValueAtTime(20, ctx.currentTime);
    }
    
    // Get cached loudness or analyze
    let trackLoudness = getTrackLoudness(trackId);
    
    if (trackLoudness === null) {
        // Need to analyze this track - queue it for background analysis
        const track = queue.find(t => t.id === trackId);
        if (track && (track.googleUrl || track.path)) {
            // Queue for background analysis
            const analysisUrl = track.googleUrl || track.path;
            
            // Check if already queued
            const alreadyQueued = queueLoudnessAnalysis.some(q => q.trackId === trackId);
            if (!alreadyQueued) {
                queueLoudnessAnalysis.push({ trackId, url: analysisUrl });
            }
            
            // Trigger background analysis if not running
            if (!loudnessAnalysisRunning && ctx) {
                processLoudnessQueue();
            }
            
            // Use target loudness as temporary estimate
            // This will be corrected after analysis
            trackLoudness = normTargetLUFS;
        } else {
            trackLoudness = normTargetLUFS;
        }
    }
    
    // Calculate gain needed to reach target
    // LUFS difference directly translates to dB gain needed
    const loudnessDiff = normTargetLUFS - trackLoudness;
    const gain = Math.pow(10, loudnessDiff / 20); // Convert dB to linear
    
    // Allow wider gain range for better normalization
    // Use 0.25x (-12 dB) to 4x (+12 dB) for extreme loudness differences
    const clampedGain = Math.max(0.25, Math.min(4.0, gain));
    
    currentNormGain = clampedGain;
    
    // Apply gain smoothly using existing ctx variable
    if (normGainNode && ctx) {
        normGainNode.gain.setTargetAtTime(clampedGain, ctx.currentTime, 0.1);
    }
    
    updateNormStatus();
    updateNormIndicator(loudnessDiff);
}

/**
 * Update the normalization indicator on the player
 */
function updateNormIndicator(loudnessDiff) {
    let indicator = document.getElementById('normIndicator');
    
    if (!indicator) {
        // Create indicator if it doesn't exist
        const playerBar = document.querySelector('.player-bar');
        if (playerBar) {
            indicator = document.createElement('div');
            indicator.id = 'normIndicator';
            indicator.className = 'norm-indicator';
            indicator.innerHTML = '<i class="fa-solid fa-wave-square"></i><span id="normIndicatorText"></span>';
            playerBar.appendChild(indicator);
        }
    }
    
    if (!indicator) return;
    
    if (!normEnabled) {
        indicator.classList.remove('visible');
        return;
    }
    
    const indicatorText = document.getElementById('normIndicatorText');
    if (loudnessDiff !== null) {
        const absDiff = Math.abs(loudnessDiff).toFixed(1);
        const sign = loudnessDiff >= 0 ? '+' : '-';
        indicatorText.textContent = `${sign}${absDiff} dB`;
    } else {
        indicatorText.textContent = 'Norm';
    }
    
    indicator.classList.add('visible');
}

/**
 * Load normalization settings from localStorage
 */
function loadNormSettings() {
    // Load enabled state (default to true if not set)
    const savedEnabled = localStorage.getItem('goot_norm_enabled');
    if (savedEnabled !== null) {
        normEnabled = savedEnabled === 'true';
    }
    // Always set checkbox to match normEnabled state
    document.getElementById('normToggle').checked = normEnabled;
    
    // Load target loudness
    const savedTarget = localStorage.getItem('goot_norm_target');
    if (savedTarget !== null) {
        normTargetLUFS = parseInt(savedTarget);
        document.getElementById('normTargetSlider').value = normTargetLUFS;
        const normTargetValue = document.getElementById('normTargetValue');
        if (normTargetValue) normTargetValue.textContent = normTargetLUFS;
    }
    
    // Initialize LUFS progress bar
    const progressEl = document.getElementById('lufsProgress');
    if (progressEl) {
        const min = -23;
        const max = -8;
        const percentage = ((normTargetLUFS - min) / (max - min)) * 100;
        progressEl.style.width = percentage + '%';
    }
    
    // Initialize LUFS marker states
    document.querySelectorAll('.lufs-marker').forEach(marker => {
        marker.classList.toggle('active', parseInt(marker.dataset.value) === normTargetLUFS);
    });
    
    // Apply normalization to current track if playing
    if (queue[qIndex]?.id) {
        setTimeout(() => applyNormalization(queue[qIndex].id), 100);
    }
    
    updateNormStatus();
    updateCacheStats();
}

/**
 * Update cache statistics display
 */
function updateCacheStats() {
    const metaCount = document.getElementById('cacheMetaCount');
    const artCount = document.getElementById('cacheArtCount');
    
    if (metaCount) {
        const metaCache = JSON.parse(localStorage.getItem('goot_meta_cache') || '{}');
        metaCount.textContent = Object.keys(metaCache).length;
    }
    
    if (artCount) {
        const artCache = JSON.parse(localStorage.getItem('goot_album_art_cache') || '{}');
        artCount.textContent = Object.keys(artCache).length;
    }
}

// ==================== PLAY COUNT TRACKING ====================

let playCounts = {};
let albumPlayCounts = {}; // Track album-level plays for consolidation
let pinnedItems = { albums: [], playlists: [], tracks: [] }; // Pinned items for Listen Again
let lastTrackedPosition = {};
const PLAY_COUNT_THRESHOLD = 0.25; // Track after 25% listened

// Load play counts from IndexedDB (called after DB is ready)
async function loadPlayCounts() {
    try {
        const counts = await loadPlayCountsFromDB();
        if (Object.keys(counts).length > 0) {
            playCounts = counts;
            console.log('[PlayTracking] Loaded play counts from IndexedDB:', JSON.stringify(playCounts));
        } else {
            console.log('[PlayTracking] No play counts found in IndexedDB');
            playCounts = {};
        }
    } catch (e) {
        console.log('[PlayTracking] Error loading from IndexedDB:', e);
        playCounts = {};
    }
    lastTrackedPosition = {};
    
    // Reset Listen Again rendered flag to allow re-render with new data
    listenAgainRendered = false;
    
    // Note: loadPinnedItems() and loadAlbumCounts() are now called from init()
    // after initAllDatabases() completes to ensure database is ready
    
    console.log('[PlayTracking] loadPlayCounts complete, playCounts:', JSON.stringify(playCounts));
}

// Load album counts from IndexedDB
async function loadAlbumCounts() {
    try {
        // Check if database is ready
        if (!metaDB || !metaDBReady) {
            console.log('[AlbumTracking] Database not ready, skipping load');
            return;
        }
        const tx = metaDB.transaction('albumCounts', 'readonly');
        const data = await tx.objectStore('albumCounts').get('counts');
        await tx.done;
        if (data && Object.keys(data).length > 0) {
            // Convert tracks Sets back to arrays for JSON
            Object.values(data).forEach(album => {
                if (album.tracks && Array.isArray(album.tracks)) {
                    album.tracks = new Set(album.tracks);
                }
            });
            albumPlayCounts = data;
            console.log('[AlbumTracking] Loaded album counts:', Object.keys(albumPlayCounts).length, 'albums');
            
            // Reset Listen Again rendered flag to allow re-render with new album data
            listenAgainRendered = false;
        }
    } catch (e) {
        console.log('[AlbumTracking] Error loading:', e);
    }
}

// Save album counts to IndexedDB
async function saveAlbumCounts() {
    try {
        // Convert Sets to arrays for JSON storage
        const data = {};
        Object.entries(albumPlayCounts).forEach(([name, album]) => {
            data[name] = {
                ...album,
                tracks: Array.from(album.tracks || [])
            };
        });
        const tx = metaDB.transaction('albumCounts', 'readwrite');
        await tx.objectStore('albumCounts').put(data);
        await tx.done;
    } catch (e) {
        console.warn('[AlbumTracking] Failed to save:', e);
    }
}

// Load pinned items from localStorage
function loadPinnedItems() {
    try {
        const saved = localStorage.getItem('goot_pinned_items');
        if (saved) {
            pinnedItems = JSON.parse(saved);
            
            // Migration: Update existing pinned tracks with missing playback data
            if (pinnedItems.tracks && Array.isArray(pinnedItems.tracks)) {
                pinnedItems.tracks = pinnedItems.tracks.map(pinnedTrack => {
                    // Only update if path/googleUrl is missing
                    if (!pinnedTrack.path && !pinnedTrack.googleUrl) {
                        // Try to find the full track data
                        const queueTrack = queue.find(t => t.id === pinnedTrack.id);
                        const meta = trackMetadata[pinnedTrack.id];
                        const allTrack = (typeof allTracks !== 'undefined' && allTracks) ? allTracks.find(t => t.id === pinnedTrack.id) : null;
                        
                        if (queueTrack) {
                            return {
                                ...pinnedTrack,
                                path: queueTrack.path || '',
                                googleUrl: queueTrack.googleUrl || queueTrack.url || ''
                            };
                        } else if (meta) {
                            return {
                                ...pinnedTrack,
                                path: meta.path || '',
                                googleUrl: meta.googleUrl || ''
                            };
                        } else if (allTrack) {
                            return {
                                ...pinnedTrack,
                                path: allTrack.path || '',
                                googleUrl: allTrack.googleUrl || allTrack.url || ''
                            };
                        }
                    }
                    return pinnedTrack;
                });
                
                // Save the updated data
                localStorage.setItem('goot_pinned_items', JSON.stringify(pinnedItems));
            }
            
            // Reset Listen Again rendered flag to allow re-render with new pinned items
            listenAgainRendered = false;
            
            console.log('[Pinned] Loaded pinned items:', pinnedItems);
        }
    } catch (e) {
        console.error('[Pinned] Failed to load:', e);
    }
}

// Save pinned items to localStorage
function savePinnedItems() {
    try {
        localStorage.setItem('goot_pinned_items', JSON.stringify(pinnedItems));
    } catch (e) {
        console.error('[Pinned] Failed to save:', e);
    }
}

// Add item to pinned list
function pinItem(type, id, data) {
    const list = pinnedItems[type] || [];
    
    // Check if already pinned
    const existingIndex = list.findIndex(item => item.id === id);
    if (existingIndex >= 0) {
        // Move to top
        const item = list.splice(existingIndex, 1)[0];
        list.unshift({ ...item, pinnedAt: Date.now() });
    } else {
        // Add new
        list.unshift({
            id: id,
            ...data,
            pinnedAt: Date.now()
        });
    }
    
    pinnedItems[type] = list;
    savePinnedItems();
    
    // Show notification
    const name = data.title || data.name || 'Item';
    showNotification(`Pinned "${name}" to Listen Again`);
    
    console.log('[Pinned] Pinning item, pinnedItems:', pinnedItems);
    
    // Reset to first page and refresh Listen Again section immediately
    listenAgainCurrentPage = 0;
    renderListenAgainSection(true).then(() => {
        console.log('[Pinned] Listen Again section re-rendered');
    }).catch(err => {
        console.error('[Pinned] Error re-rendering Listen Again:', err);
    });
}

// Remove item from pinned list
function unpinItem(type, id) {
    const list = pinnedItems[type] || [];
    // For tracks, compare by id. For albums/playlists, compare by name (since id is the name for these types)
    const index = type === 'tracks' 
        ? list.findIndex(item => item.id === id)
        : list.findIndex(item => item.name === id);
    if (index >= 0) {
        const item = list.splice(index, 1)[0];
        pinnedItems[type] = list;
        savePinnedItems();
        
        // Show notification
        const name = item.title || item.name || 'Item';
        showNotification(`Unpinned "${name}" from Listen Again`);
        
        console.log('[Pinned] Unpinning item, pinnedItems:', pinnedItems);
        
        // Reset to first page and refresh Listen Again section immediately
        listenAgainCurrentPage = 0;
        renderListenAgainSection(true).then(() => {
            console.log('[Pinned] Listen Again section re-rendered');
        }).catch(err => {
            console.error('[Pinned] Error re-rendering Listen Again:', err);
        });
    }
}

// Check if item is pinned
function isPinned(type, id) {
    const list = pinnedItems[type] || [];
    // For tracks, compare by id. For albums/playlists, compare by name (since id is the name for these types)
    return type === 'tracks'
        ? list.some(item => item.id === id)
        : list.some(item => item.name === id);
}

async function savePlayCounts() {
    // Save each play count to IndexedDB
    for (const [trackId, count] of Object.entries(playCounts)) {
        await savePlayCountToDB(trackId, count).catch(err => {
            console.warn('[PlayTracking] Failed to save count for', trackId, ':', err);
        });
    }
    console.log('[PlayTracking] Saved play counts to IndexedDB:', JSON.stringify(playCounts));
    
    // Also save the sorted most played list to IndexedDB for faster loading
    await saveMostPlayedListToDB();
}

async function saveMostPlayedListToDB() {
    const tracks = [];
    
    Object.entries(playCounts).forEach(([trackId, count]) => {
        if (count > 0) {
            const meta = trackMetadata[trackId];
            tracks.push({
                id: trackId,
                title: meta?.title || 'Unknown Track',
                artist: meta?.artist || 'Unknown Artist',
                album: meta?.album || '',
                albumArt: meta?.albumArt || meta?.art || '',
                playCount: count
            });
        }
    });
    
    // Sort by play count descending
    tracks.sort((a, b) => b.playCount - a.playCount);
    
    // Save to IndexedDB
    await saveMostPlayedToDB(tracks);
}

function getMostPlayedTracks(limit = 8) {
    console.log('[PlayTracking] getMostPlayedTracks called, limit:', limit);
    
    const tracks = [];
    
    // Fetch fresh metadata from trackMetadata and queue
    Object.entries(playCounts).forEach(([trackId, count]) => {
        if (count > 0) {
            // Get FULL metadata from trackMetadata
            const meta = trackMetadata[trackId];
            
            // Also try to get from queue for current playing info
            const queueTrack = queue.find(t => t.id === trackId);
            
            // Combine all sources for complete track info
            tracks.push({
                id: trackId,
                title: meta?.title || queueTrack?.title || queueTrack?.name || 'Unknown Track',
                artist: meta?.artist || queueTrack?.artist || queueTrack?.artistName || 'Unknown Artist',
                album: meta?.album || queueTrack?.album || '',
                albumArt: meta?.albumArt || meta?.art || queueTrack?.albumArt || queueTrack?.art || '',
                path: meta?.path || queueTrack?.path || '',
                googleUrl: meta?.googleUrl || queueTrack?.googleUrl || queueTrack?.url || '',
                playCount: count
            });
        }
    });
    
    console.log('[PlayTracking] Built tracks list from playCounts:', tracks.length, 'tracks');
    
    // Sort by play count descending
    const sortedTracks = tracks
        .filter(t => t.playCount > 0)
        .sort((a, b) => b.playCount - a.playCount)
        .slice(0, limit);
    
    console.log('[PlayTracking] Sorted tracks:', JSON.stringify(sortedTracks));
    
    return sortedTracks;
}

async function incrementPlayCount(trackId) {
    console.log('[PlayTracking] Attempting to increment count for:', trackId);
    
    // Get track metadata for album tracking
    const meta = trackMetadata[trackId];
    const queueTrack = queue.find(t => t.id === trackId);
    const track = meta || queueTrack || {};
    
    // Track album plays
    const albumName = track.album;
    if (albumName && albumName !== 'Unknown' && albumName) {
        if (!albumPlayCounts[albumName]) {
            albumPlayCounts[albumName] = {
                name: albumName,
                art: track.albumArt || track.art || '',
                tracks: new Set(),
                playCount: 0
            };
        }
        albumPlayCounts[albumName].tracks.add(trackId);
        albumPlayCounts[albumName].playCount++;
        
        // Save album counts in background
        saveAlbumCounts().catch(() => {});
    }
    
    if (!playCounts[trackId]) {
        playCounts[trackId] = 0;
        console.log('[PlayTracking] Created new entry for track');
    }
    
    playCounts[trackId]++;
    await savePlayCounts();

    // INSTANT UPDATE: Re-render Listen Again section immediately
    await renderListenAgainSection(true);
    await updateAllPlayedTracksSection();
    
    // Also refresh the cache in background
    refreshMostPlayedCache().catch(() => {});
}

async function decrementPlayCount(trackId) {
    console.log('[PlayTracking] Decrementing count for:', trackId);
    
    // Get track metadata for album tracking
    const meta = trackMetadata[trackId];
    const queueTrack = queue.find(t => t.id === trackId);
    const track = meta || queueTrack || {};
    
    // Track album plays - decrement
    const albumName = track.album;
    if (albumName && albumName !== 'Unknown' && albumName && albumPlayCounts[albumName]) {
        albumPlayCounts[albumName].playCount--;
        if (albumPlayCounts[albumName].playCount <= 0) {
            albumPlayCounts[albumName].playCount = 0;
        }
        // Save album counts in background
        saveAlbumCounts().catch(() => {});
    }
    
    if (playCounts[trackId] && playCounts[trackId] > 0) {
        playCounts[trackId]--;
        await savePlayCounts();

        // INSTANT UPDATE: Re-render Listen Again section immediately
        await renderListenAgainSection(true);
        await updateAllPlayedTracksSection();
        
        // Also refresh the cache in background
        refreshMostPlayedCache().catch(() => {});
    }
    
    // Reset tracking position
    delete lastTrackedPosition[trackId];
}

// Update Listen Again section - now just calls renderListenAgainSection for full pagination support
async function updateListenAgainSection(updatedTrackId = null) {
    await renderListenAgainSection();
}

async function refreshMostPlayedCache() {
    // Update the most_played cache with fresh metadata (including album art)
    const tracks = [];
    
    Object.entries(playCounts).forEach(([trackId, count]) => {
        if (count > 0) {
            const meta = trackMetadata[trackId];
            const queueTrack = queue.find(t => t.id === trackId);
            
            tracks.push({
                id: trackId,
                title: meta?.title || queueTrack?.title || queueTrack?.name || 'Unknown Track',
                artist: meta?.artist || queueTrack?.artist || queueTrack?.artistName || 'Unknown Artist',
                album: meta?.album || queueTrack?.album || '',
                albumArt: meta?.albumArt || meta?.art || queueTrack?.albumArt || queueTrack?.art || '',
                playCount: count
            });
        }
    });
    
    // Sort by play count descending
    tracks.sort((a, b) => b.playCount - a.playCount);
    
    // Save to IndexedDB (primary storage for Listen Again feature)
    try {
        await saveMostPlayedToDB(tracks);
    } catch (idbError) {
        console.warn('[PlayTracking] Failed to save to IndexedDB:', idbError);
    }
    
    // Re-render the section only if not already rendered (prevents double animation)
    if (!listenAgainRendered) {
        await renderListenAgainSection();
        listenAgainRendered = true;
    }
}

async function renderListenAgainSection(skipSave = false) {
    // Handle both Listen Again section elements
    const containers = document.querySelectorAll('#listenAgainSection');
    if (containers.length === 0) return;
    
    // Only show on home page (root folder), not subfolders
    const isHomePage = stack.length <= 1;
    
    if (!isHomePage) {
        // Still update pinnedItems data but hide the section
        containers.forEach(c => c.style.display = 'none');
        return;
    }
    
    // Show the containers on home page
    containers.forEach(c => c.style.display = '');
    
    // Load cached track data from IndexedDB first (sync, fast)
    const cachedTracks = loadMostPlayedFromDB() || [];
    
    // Get top tracks from playCounts for ordering
    const tracks = [];
    const trackIds = Object.keys(playCounts);
    
    // Sort trackIds by play count (highest first) - CRITICAL for correct ordering
    trackIds.sort((a, b) => playCounts[b] - playCounts[a]);
    
    // Only process up to 50 tracks for initial load
    const maxTracks = Math.min(trackIds.length, 50);
    
    for (let i = 0; i < maxTracks; i++) {
        const trackId = trackIds[i];
        const count = playCounts[trackId];
        if (count > 0) {
            let cachedTrack = null;
            if (cachedTracks.length > 0) {
                cachedTrack = cachedTracks.find(t => t.id === trackId);
            }
            
            const meta = trackMetadata[trackId];
            const queueTrack = queue.find(t => t.id === trackId);
            
            // Fallback: also check allTracks if metadata not available yet
            let allTracksMeta = null;
            if (!meta && !queueTrack && allTracks && allTracks.length > 0) {
                allTracksMeta = allTracks.find(t => t.id === trackId);
            }
            
            // Priority: cached > trackMetadata > queue > allTracks
            const title = cachedTrack?.title || meta?.title || queueTrack?.title || queueTrack?.name || allTracksMeta?.title || allTracksMeta?.name || 'Unknown Track';
            const artist = cachedTrack?.artist || meta?.artist || queueTrack?.artist || queueTrack?.artistName || allTracksMeta?.artist || 'Unknown Artist';
            const album = cachedTrack?.album || meta?.album || queueTrack?.album || allTracksMeta?.album || '';
            const albumArt = cachedTrack?.albumArt || cachedTrack?.art || meta?.albumArt || meta?.art || queueTrack?.albumArt || queueTrack?.art || allTracksMeta?.albumArt || allTracksMeta?.art || '';
            
            tracks.push({
                id: trackId,
                title: title,
                artist: artist,
                album: album,
                albumArt: albumArt,
                playCount: count
            });
        }
    }
    
    // Sort tracks by play count
    tracks.sort((a, b) => b.playCount - a.playCount);
    
    // Build album consolidation - albums with 4+ unique tracks played
    const albumConsolidations = [];
    const albumsUsed = new Set();
    
    Object.values(albumPlayCounts).forEach(album => {
        const uniqueTracks = album.tracks?.size || 0;
        if (uniqueTracks >= 4) {
            // Find tracks from this album in our sorted tracks list
            const albumTracks = tracks.filter(t => {
                if (albumsUsed.has(t.id)) return false;
                return t.album === album.name;
            });
            
            if (albumTracks.length >= 4) {
                albumTracks.forEach(t => albumsUsed.add(t.id));
                albumConsolidations.push({
                    type: 'album',
                    id: `album_${album.name}`,
                    name: album.name,
                    art: album.art || '',
                    trackCount: albumTracks.length,
                    totalPlays: albumTracks.reduce((sum, t) => sum + t.playCount, 0),
                    tracks: albumTracks.slice(0, 4) // Sample tracks to play
                });
            }
        }
    });
    
    // Sort album consolidations by total plays
    albumConsolidations.sort((a, b) => b.totalPlays - a.totalPlays);
    
    // Get non-album tracks (excluding those consolidated)
    const regularTracks = tracks.filter(t => !albumsUsed.has(t.id));
    
    // Build final items list: Pinned items first, then albums, then tracks
    const displayItems = [];
    const fallbackImg = 'https://www.gstatic.com/classroom/logo_square_rounded.svg';
    const isExpanded = containers[0]?.classList.contains('expanded');
    // Fixed total items regardless of page size - smaller page size = more pages
    const maxItems = isExpanded ? 40 : 24; // Fixed total items to display
    
    // Add pinned tracks (ALWAYS add these)
    
    // Add pinned tracks (ALWAYS add these)
    pinnedItems.tracks?.forEach(pinned => {
        // Find track data
        const trackData = tracks.find(t => t.id === pinned.id) || {
            id: pinned.id,
            title: pinned.title || 'Unknown Track',
            artist: pinned.artist || 'Unknown Artist',
            album: pinned.album || '',
            albumArt: pinned.albumArt || pinned.art || '',
            playCount: 0
        };
        displayItems.push({
            type: 'pinned-track',
            ...trackData,
            pinnedAt: pinned.pinnedAt
        });
    });
    
    // Add pinned albums (ALWAYS add these)
    pinnedItems.albums?.forEach(pinned => {
        console.log('[ListenAgain] Adding pinned album:', pinned.name);
        displayItems.push({
            type: 'pinned-album',
            id: `album_${pinned.name}`,
            name: pinned.name,
            art: pinned.art || '',
            trackCount: pinned.trackCount || 0,
            totalPlays: pinned.totalPlays || 0,
            pinnedAt: pinned.pinnedAt,
            folderId: pinned.folderId || null // Include folderId for pinned folders
        });
    });
    
    // Add pinned playlists (ALWAYS add these)
    pinnedItems.playlists?.forEach(pinned => {
        displayItems.push({
            type: 'pinned-playlist',
            id: `playlist_${pinned.name}`,
            name: pinned.name,
            art: pinned.art || '',
            trackCount: pinned.trackCount || 0,
            pinnedAt: pinned.pinnedAt
        });
    });
    
    console.log('[ListenAgain] displayItems:', displayItems.map(i => ({type: i.type, name: i.name})));
    
    // Add album consolidations
    albumConsolidations.forEach(album => {
        if (displayItems.length >= maxItems) return;
        displayItems.push(album);
    });
    
    // Add regular tracks
    regularTracks.forEach(track => {
        if (displayItems.length >= maxItems) return;
        displayItems.push({
            type: 'track',
            ...track
        });
    });
    
    const hasContent = displayItems.length > 0;
    const pageSize = getListenAgainPageSize();
    const totalPages = Math.ceil(displayItems.length / pageSize);
    listenAgainTotalPages = totalPages; // Store globally for pagination navigation
    
    // Reset to first page when pinned items change (to show new pins immediately)
    if (listenAgainCurrentPage >= totalPages || listenAgainCurrentPage < 0) {
        listenAgainCurrentPage = 0;
    }
    
    // Get items for current page
    const startIndex = listenAgainCurrentPage * pageSize;
    const endIndex = Math.min(startIndex + pageSize, displayItems.length);
    const currentPageItems = displayItems.slice(startIndex, endIndex);
    
    // Render immediately - using horizontal scroll instead of pagination
    containers.forEach(container => {
        // Find or create content container
        let contentContainer = container.querySelector('#listenAgainContent');
        if (!contentContainer) {
            // Create content container if it doesn't exist
            contentContainer = document.createElement('div');
            contentContainer.id = 'listenAgainContent';
            contentContainer.style.display = '';
            container.appendChild(contentContainer);
        }
        
        contentContainer.innerHTML = `
            <div class="listen-again-header">
                <h2 class="listen-again-title">Listen Again</h2>
                <div class="listen-again-actions">
                    ${hasContent ? `
                    <button class="listen-again-expand-btn" onclick="showAllPlayedTracks()">
                        <span>Show all</span>
                        <i class="fa-solid fa-chevron-right"></i>
                    </button>
                    ` : ''}
                </div>
            </div>
            ${hasContent ? `
            <div class="listen-again-carousel">
                <button class="listen-again-carousel-btn listen-again-carousel-prev" onclick="scrollListenAgain(-1)" id="listenAgainPrevBtn" style="visibility: hidden;">
                    <i class="fa-solid fa-chevron-left"></i>
                </button>
                <div class="listen-again-scroll-wrapper">
                    <div class="listen-again-scroll-container" id="listenAgainScrollContainer" onscroll="updateListenAgainScrollState()">
                        ${displayItems.map((item, index) => {
                        if (item.type === 'album' || item.type === 'pinned-album') {
                            // Album consolidation card or pinned album/folder
                            const albumArtUrl = item.art || fallbackImg;
                            const pinned = item.type === 'pinned-album';
                            const isFolder = pinned && item.folderId;
                            const clickHandler = isFolder 
                                ? `openPinnedFolderFromCard('${item.folderId}')`
                                : `playAlbumConsolidation('${encodeURIComponent(item.name)}')`;
                            const label = isFolder ? 'Pinned Folder' : "You've been replaying";
                            const globalIndex = startIndex + index;
                            
                            // For pinned folders, add hover play/shuffle overlay - SAME as playlist screen
                            const hoverOverlay = isFolder ? `
                                <div class="play-overlay">
                                    <button class="listen-again-pin-btn" data-type="albums" data-name="${encodeURIComponent(item.name)}" title="Remove from Listen Again">
                                        <i class="fa-solid fa-xmark"></i>
                                    </button>
                                    <div class="control-group">
                                        <div class="control-btn" onclick="event.stopPropagation(); playPinnedFolder('${item.folderId}')">
                                            <i class="fa-solid fa-play"></i>
                                        </div>
                                        <div class="control-btn shuffle" onclick="event.stopPropagation(); shufflePinnedFolder('${item.folderId}')">
                                            <i class="fa-solid fa-shuffle"></i>
                                        </div>
                                        <div class="btn-label">Play</div>
                                    </div>
                                </div>
                            ` : `
                                <div class="listen-again-play-overlay">
                                    <div class="listen-again-count">${item.trackCount} songs</div>
                                </div>
                            `;
                            
                            return `
                            <div class="listen-again-track-card ${pinned ? 'pinned-item' : ''}" 
                                 data-type="folder" data-folder-id="${item.folderId}" data-name="${encodeURIComponent(item.name)}"
                                 id="listen-album-${globalIndex}"
                                 data-album="${item.name}">
                                <div class="listen-again-track-art">
                                    <img src="${albumArtUrl}" 
                                         alt="${item.name}"
                                         onload="this.classList.add('fade-in'); this.classList.add('loaded');"
                                         onerror="this.src='${fallbackImg}'">
                                    ${pinned ? `<div class="pinned-badge"><i class="fa-solid fa-heart"></i></div>` : ''}
                                </div>
                                ${hoverOverlay}
                                <div class="listen-again-track-info">
                                    <div class="listen-again-track-title">${item.name}</div>
                                    <div class="listen-again-track-artist" style="color: white !important;">${label}</div>
                                </div>
                            </div>
                            `;
                        } else if (item.type === 'pinned-playlist') {
                            // Pinned playlist card - click opens detailed view, hover shows play controls
                            const artUrl = item.art || fallbackImg;
                            const globalIndex = startIndex + index;
                            return `
                            <div class="listen-again-track-card pinned-item" 
                                 data-type="playlist" data-name="${encodeURIComponent(item.name)}"
                                 id="listen-playlist-${globalIndex}"
                                 data-playlist="${item.name}">
                                <div class="listen-again-track-art">
                                    <img src="${artUrl}" 
                                         alt="${item.name}"
                                         onload="this.classList.add('fade-in'); this.classList.add('loaded');"
                                         onerror="this.src='${fallbackImg}'">
                                    <div class="pinned-badge">
                                        <i class="fa-solid fa-heart"></i>
                                    </div>
                                </div>
                                <div class="play-overlay">
                                    <button class="listen-again-pin-btn" data-type="playlists" data-name="${encodeURIComponent(item.name)}" title="Remove from Listen Again">
                                        <i class="fa-solid fa-xmark"></i>
                                    </button>
                                    <div class="control-group">
                                        <div class="control-btn" onclick="event.stopPropagation(); playPinnedPlaylistFromCard(event, '${encodeURIComponent(item.name)}')">
                                            <i class="fa-solid fa-play"></i>
                                        </div>
                                        <div class="control-btn shuffle" onclick="event.stopPropagation(); shufflePinnedPlaylistFromCard(event, '${encodeURIComponent(item.name)}')">
                                            <i class="fa-solid fa-shuffle"></i>
                                        </div>
                                        <div class="btn-label">Play</div>
                                    </div>
                                </div>
                                <div class="listen-again-track-info">
                                    <div class="listen-again-track-title">${item.name}</div>
                                    <div class="listen-again-track-artist">Pinned Playlist</div>
                                </div>
                            </div>
                            `;
                        } else {
                            // Regular or pinned track card
                            const albumArtUrl = item.albumArt || fallbackImg;
                            const isPinnedTrack = item.type === 'pinned-track';
                            const globalIndex = startIndex + index;
                            return `
                            <div class="listen-again-track-card ${isPinnedTrack ? 'pinned-item' : ''}" 
                                 onclick="playMostPlayedTrack('${item.id}')" 
                                 id="listen-track-${globalIndex}">
                                <div class="listen-again-track-art">
                                    <img src="${albumArtUrl}" 
                                         alt="${item.title}"
                                         onload="this.classList.add('fade-in'); this.classList.add('loaded');"
                                         onerror="this.src='${fallbackImg}'">
                                    ${isPinnedTrack ? '<div class="pinned-badge"><i class="fa-solid fa-heart"></i></div>' : ''}
                                </div>
                                ${isPinnedTrack ? `
                                <div class="play-overlay">
                                    <button class="listen-again-pin-btn" data-type="tracks" data-id="${item.id}" title="Remove from Listen Again">
                                        <i class="fa-solid fa-xmark"></i>
                                    </button>
                                    <div class="control-group">
                                        <div class="control-btn" onclick="event.stopPropagation(); playMostPlayedTrack('${item.id}')">
                                            <i class="fa-solid fa-play"></i>
                                        </div>
                                        <div class="btn-label">Play</div>
                                    </div>
                                </div>
                                ` : `
                                <div class="play-overlay">
                                    <div class="listen-again-count">${formatPlayCount(item.playCount)}</div>
                                </div>
                                `}
                                <div class="listen-again-track-info">
                                    <div class="listen-again-track-title">${item.title}</div>
                                    <div class="listen-again-track-artist">${item.artist}</div>
                                </div>
                            </div>
                            `;
                        }
                    }).join('')}
                </div>
            </div>
            <button class="listen-again-carousel-btn listen-again-carousel-next" onclick="scrollListenAgain(1)" id="listenAgainNextBtn">
                <i class="fa-solid fa-chevron-right"></i>
            </button>
            </div>
            ` : `
            <div class="listen-again-empty">
                <i class="fa-solid fa-repeat listen-again-empty-icon"></i>
                <p class="listen-again-empty-text">Play some music to see your most played tracks here</p>
                <p class="listen-again-empty-text" style="margin-top: 12px; opacity: 0.6;">
                    Pin playlists and albums by clicking the pin icon on their cards
                </p>
            </div>
            `}
        `;
        
        // Trigger staggered animation for cards
        setTimeout(() => {
            container.querySelectorAll('.listen-again-track-card').forEach((card, index) => {
                setTimeout(() => card.classList.add('loaded'), 50 * index);
            });
        }, 50);
    });
    
    // Defer background work
    setTimeout(() => {
        if (tracks.length > 0 && !skipSave) {
            saveMostPlayedToDB(tracks).catch(() => {});
        }
        
        // Load missing album art
        tracks.slice(0, 16).forEach(track => {
            if (!track.albumArt && track.album && track.album !== 'Unknown') {
                loadImageFromDB(`album_${track.album}`).then(art => {
                    if (art) {
                        track.albumArt = art;
                        const artEl = document.querySelector(`.listen-again-track-card[onclick*="playMostPlayedTrack('${track.id}')"] .listen-again-track-art img`);
                        if (artEl) {
                            artEl.src = art;
                            artEl.classList.add('fade-in');
                        }
                    }
                }).catch(() => {});
            }
        });
        
        const allPlayedScreen = document.getElementById('all-played-screen');
        if (allPlayedScreen?.classList.contains('active')) {
            updateAllPlayedTracksSection();
        }
    }, 100);
    
    // Add event delegation for Listen Again unpin buttons and card clicks (outside setTimeout)
    containers.forEach(container => {
        // Use setTimeout to ensure DOM is rendered
        setTimeout(() => {
            container.querySelectorAll('.listen-again-track-card[data-type]').forEach(card => {
                card.addEventListener('click', (e) => {
                    // Don't navigate if clicking on any button
                    if (e.target.closest('button')) return;
                    
                    const type = card.dataset.type;
                    if (type === 'folder') {
                        const folderId = card.dataset.folderId;
                        openPinnedFolderFromCard(folderId);
                    } else if (type === 'playlist') {
                        const name = decodeURIComponent(card.dataset.name);
                        openPinnedPlaylistFromCard(name);
                    }
                });
            });
            
            // Handle unpin buttons
            container.querySelectorAll('.listen-again-pin-btn[data-type]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    e.preventDefault();
                    const type = btn.dataset.type;
                    const name = btn.dataset.name ? decodeURIComponent(btn.dataset.name) : btn.dataset.id;
                    console.log('[ListenAgain] Unpinning:', type, name);
                    unpinItem(type, name);
                });
            });
        }, 50);
    });
    
    listenAgainRendered = true;
}

// Play album consolidation - plays all tracks from the album
async function playAlbumConsolidation(albumName) {
    const decodedName = decodeURIComponent(albumName);
    
    // Find all tracks from this album in trackMetadata
    const albumTracks = [];
    Object.entries(trackMetadata).forEach(([id, meta]) => {
        if (meta.album === decodedName) {
            albumTracks.push({
                id: id,
                title: meta.title || 'Unknown Track',
                artist: meta.artist || 'Unknown Artist',
                album: meta.album,
                albumArt: meta.albumArt || meta.art,
                path: meta.path,
                googleUrl: meta.googleUrl
            });
        }
    });
    
    if (albumTracks.length > 0) {
        // Build queue from album tracks
        const tracksToPlay = albumTracks.map(t => ({
            id: t.id,
            title: t.title,
            artist: t.artist,
            album: t.album,
            art: t.albumArt || t.art,
            path: t.path,
            googleUrl: t.googleUrl,
            url: t.googleUrl || t.path
        }));
        
        queue = tracksToPlay;
        qIndex = 0;
        play(0);
        showNotification(`Playing ${albumTracks.length} songs from "${decodedName}"`);
    } else {
        showNotification('Album tracks not found');
    }
}

// Play pinned playlist
function playPinnedPlaylist(playlistName) {
    const decodedName = decodeURIComponent(playlistName);
    const playlist = playlists[decodedName];
    
    if (playlist && Array.isArray(playlist) && playlist.length > 0) {
        // Build queue from playlist
        const tracksToPlay = [];
        playlist.forEach(entry => {
            const meta = trackMetadata[entry.id];
            const queueTrack = queue.find(t => t.id === entry.id);
            const track = meta || queueTrack || {};
            
            tracksToPlay.push({
                id: entry.id,
                title: meta?.title || queueTrack?.title || queueTrack?.name || 'Unknown Track',
                artist: meta?.artist || queueTrack?.artist || queueTrack?.artistName || 'Unknown Artist',
                album: meta?.album || queueTrack?.album || '',
                art: meta?.albumArt || meta?.art || queueTrack?.albumArt || queueTrack?.art,
                path: meta?.path || queueTrack?.path,
                googleUrl: meta?.googleUrl || queueTrack?.googleUrl || queueTrack?.url,
                url: meta?.googleUrl || queueTrack?.googleUrl || queueTrack?.url || meta?.path || queueTrack?.path
            });
        });
        
        if (tracksToPlay.length > 0) {
            queue = tracksToPlay;
            qIndex = 0;
            play(0);
            showNotification(`Playing playlist "${decodedName}"`);
        }
    } else {
        showNotification('Playlist is empty or not found');
    }
}

// Play pinned playlist from card (with event stopPropagation)
function playPinnedPlaylistFromCard(e, playlistName) {
    e.stopPropagation();
    playPinnedPlaylist(playlistName);
}

// Shuffle and play pinned playlist from card
function shufflePinnedPlaylistFromCard(e, playlistName) {
    e.stopPropagation();
    const decodedName = decodeURIComponent(playlistName);
    const playlist = playlists[decodedName];
    
    if (playlist && Array.isArray(playlist) && playlist.length > 0) {
        // Build queue from playlist
        const tracksToPlay = [];
        playlist.forEach(entry => {
            const meta = trackMetadata[entry.id];
            const queueTrack = queue.find(t => t.id === entry.id);
            
            tracksToPlay.push({
                id: entry.id,
                title: meta?.title || queueTrack?.title || queueTrack?.name || 'Unknown Track',
                artist: meta?.artist || queueTrack?.artist || queueTrack?.artistName || 'Unknown Artist',
                album: meta?.album || queueTrack?.album || '',
                art: meta?.albumArt || meta?.art || queueTrack?.albumArt || queueTrack?.art,
                path: meta?.path || queueTrack?.path,
                googleUrl: meta?.googleUrl || queueTrack?.googleUrl || queueTrack?.url,
                url: meta?.googleUrl || queueTrack?.googleUrl || queueTrack?.url || meta?.path || queueTrack?.path
            });
        });
        
        // Shuffle
        for (let i = tracksToPlay.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [tracksToPlay[i], tracksToPlay[j]] = [tracksToPlay[j], tracksToPlay[i]];
        }
        
        if (tracksToPlay.length > 0) {
            queue = tracksToPlay;
            qIndex = 0;
            play(0);
            showNotification(`Shuffling playlist "${decodedName}"`);
        }
    } else {
        showNotification('Playlist is empty or not found');
    }
}

// Navigate Listen Again section to next/previous page
function navigateListenAgainPage(direction) {
    const newPage = listenAgainCurrentPage + direction;
    if (newPage >= 0 && newPage < listenAgainTotalPages) {
        animatePageTransition(listenAgainCurrentPage, newPage, () => {
            listenAgainCurrentPage = newPage;
            renderListenAgainSection(true); // skipSave=true for pagination navigation
        });
    }
}

// Go to specific page in Listen Again section
function goToListenAgainPage(page) {
    if (page >= 0 && page < listenAgainTotalPages && page !== listenAgainCurrentPage) {
        animatePageTransition(listenAgainCurrentPage, page, () => {
            listenAgainCurrentPage = page;
            renderListenAgainSection(true); // skipSave=true for pagination navigation
        });
    }
}

// Animate page transition with slide effect
function animatePageTransition(fromPage, toPage, callback) {
    const containers = document.querySelectorAll('#listenAgainSection');
    const direction = toPage > fromPage ? "forward" : "back";
    containers.forEach(container => {
        const grid = container.querySelector('.listen-again-grid');
        if (!grid) return;
        
        // Set direction-based exit class
        grid.classList.add(direction === "forward" ? "exit-forward" : "exit-back");
        
        // Wait for exit animation
        setTimeout(() => {
            // Execute the callback to change page and re-render
            callback();
            
            // After re-render, add enter class
            setTimeout(() => {
                const newGrid = container.querySelector('.listen-again-grid');
                if (newGrid) {
                    newGrid.classList.add(direction === "forward" ? "enter-back" : "enter-forward");
                    newGrid.classList.add('enter-active');
                    
                    // Remove animation classes after completion
                    setTimeout(() => {
                        newGrid.classList.remove("enter-forward", "enter-back", "enter-active", "exit-forward", "exit-back");
                    }, 200);
                }
            }, 20);
        }, 200);
    });
}

// Render Listen Again section with provided tracks (used for instant updates)
async function renderListenAgainSectionWithTracks(providedTracks) {
    // Handle both Listen Again section elements
    const containers = document.querySelectorAll('#listenAgainSection');
    if (containers.length === 0) return;
    
    // Only show on home page (root folder)
    const isHomePage = stack.length <= 1;
    
    containers.forEach(container => {
        if (!isHomePage) {
            container.style.display = 'none';
            return;
        }
        
        container.style.display = 'block';
        
        const hasTracks = providedTracks.length > 0;
        const isExpanded = container.classList.contains('expanded');
        const rawDisplayCount = isExpanded ? 16 : 5;
        const displayCount = hasTracks ? Math.min(rawDisplayCount, providedTracks.length) : 0;
        const topTracks = providedTracks.slice(0, displayCount);
        
        const fallbackImg = 'https://www.gstatic.com/classroom/logo_square_rounded.svg';
        
        // Pre-load missing album art from IndexedDB in parallel
        topTracks.forEach(track => {
            if (!track._resolvedArt) {
                track._resolvedArt = track.albumArt || '';
            }
        });
        
        container.innerHTML = `
            <div class="listen-again-header">
                <h2 class="listen-again-title">Listen Again</h2>
                <div class="listen-again-actions">
                    ${hasTracks ? `
                    <button class="listen-again-expand-btn" onclick="showAllPlayedTracks()">
                        <span>Show all</span>
                        <i class="fa-solid fa-chevron-right"></i>
                    </button>
                    ` : ''}
                </div>
            </div>
            ${hasTracks ? `
            <div class="listen-again-grid listen-again-grid-slide">
                ${topTracks.map((track, index) => {
                    const albumArtUrl = track._resolvedArt || track.albumArt || fallbackImg;
                    return `
                    <div class="listen-again-track-card" onclick="playMostPlayedTrack('${track.id}')" id="listen-track-${index}">
                        <div class="listen-again-track-art">
                            <img src="${albumArtUrl}" 
                                 alt="${track.title}"
                                 onload="this.classList.add('fade-in'); this.classList.add('loaded');"
                                 onerror="this.src='${fallbackImg}'">
                        </div>
                        <div class="listen-again-play-overlay">
                            <div class="listen-again-count">${formatPlayCount(track.playCount)}</div>
                        </div>
                        <div class="listen-again-track-info">
                            <div class="listen-again-track-title">${track.title}</div>
                            <div class="listen-again-track-artist">${track.artist}</div>
                        </div>
                    </div>
                    `;
                }).join('')}
            </div>
            ` : `
            <div class="listen-again-empty">
                <i class="fa-solid fa-repeat listen-again-empty-icon"></i>
                <p class="listen-again-empty-text">Play some music to see your most played tracks here</p>
            </div>
            `}
        `;
        
        // Trigger staggered animation for cards
        setTimeout(() => {
            container.querySelectorAll('.listen-again-track-card').forEach((card, index) => {
                setTimeout(() => card.classList.add('loaded'), 30 * index);
            });
        }, 50);
    });
    
    listenAgainRendered = true;
}

function toggleListenAgainExpanded() {
    // Now redirects to the all played tracks view
    showAllPlayedTracks();
}

// Show all played tracks in a new full screen view
async function showAllPlayedTracks() {
    // Hide all screens first
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    
    // Show the all played tracks screen
    const screen = document.getElementById('all-played-screen');
    if (screen) {
        screen.classList.add('active');
    }
    
    // Check if already rendered - if so, just update in-place
    const container = document.getElementById('allPlayedTracksContainer');
    const existingContainer = container?.querySelector('.all-played-tracks-container');
    
    if (existingContainer && existingContainer.children.length > 0) {
        // Already rendered - update in-place without animation
        await updateAllPlayedTracksSection();
    } else {
        // First render - do full render with animation
        await renderAllPlayedTracksGrid();
    }
    
    // Update breadcrumb
    updateAllPlayedBreadcrumb();
}

// Back to Listen Again from all played tracks view
function backToListenAgain() {
    // Hide the all played tracks screen
    const screen = document.getElementById('all-played-screen');
    if (screen) {
        screen.classList.remove('active');
    }
    
    // Show the library screen
    const libraryScreen = document.getElementById('library-screen');
    if (libraryScreen) {
        libraryScreen.classList.add('active');
    }
}

// Update breadcrumb for all played tracks view
function updateAllPlayedBreadcrumb() {
    const breadcrumb = document.getElementById('allPlayedBreadcrumb');
    if (!breadcrumb) return;
    
    // Use same format as main breadcrumbs - Home -> All Played Tracks
    breadcrumb.innerHTML = `
        <div class="breadcrumb-chip" onclick="backToListenAgain()" style="cursor:pointer;">
            <i class="fa-solid fa-chevron-left" style="margin-right:6px;"></i>
            Listen Again
        </div>
        <i class="fa-solid fa-chevron-right" style="opacity:0.2;font-size:10px;"></i>
        <div class="breadcrumb-chip" style="background:var(--md-sys-color-primary-container);color:var(--md-sys-color-primary);">
            All Played Tracks
        </div>
    `;
}

// Render the all played tracks grid
async function renderAllPlayedTracksGrid() {
    const container = document.getElementById('allPlayedTracksContainer');
    if (!container) return;
    
    container.innerHTML = '<div style="text-align:center;padding:40px;opacity:0.6;"><i class="fa-solid fa-circle-notch fa-spin" style="font-size:32px;margin-bottom:12px;"></i><br>Loading...</div>';
    
    // Get all played tracks - prioritize IndexedDB, then localStorage
    let tracks = [];
    
    // First, try IndexedDB (primary storage)
    try {
        tracks = await loadMostPlayedFromDB();
        console.log('[PlayTracking] All Played Grid - Loaded from IndexedDB:', tracks.length, 'tracks');
    } catch (e) {
        console.log('[PlayTracking] All Played Grid - Failed to load from IndexedDB:', e);
    }
    
    // If still no cached data, try to load from playCounts with fresh metadata
    // But ONLY if playCounts actually has data - don't overwrite with empty!
    const hasPlayCountsData = Object.keys(playCounts).some(k => playCounts[k] > 0);
    if (tracks.length === 0 && hasPlayCountsData) {
        Object.entries(playCounts).forEach(([trackId, count]) => {
            if (count > 0) {
                const meta = trackMetadata[trackId];
                const queueTrack = queue.find(t => t.id === trackId);
                tracks.push({
                    id: trackId,
                    title: meta?.title || queueTrack?.title || queueTrack?.name || 'Unknown Track',
                    artist: meta?.artist || queueTrack?.artist || queueTrack?.artistName || 'Unknown Artist',
                    album: meta?.album || queueTrack?.album || '',
                    albumArt: meta?.albumArt || meta?.art || queueTrack?.albumArt || queueTrack?.art || '',
                    playCount: count
                });
            }
        });
    }
    
    // ALWAYS sort by play count descending
    tracks.sort((a, b) => b.playCount - a.playCount);
    
    const fallbackImg = 'https://www.gstatic.com/classroom/logo_square_rounded.svg';
    
    if (tracks.length === 0) {
        container.innerHTML = `
            <div style="text-align:center;padding:60px;opacity:0.5;">
                <i class="fa-solid fa-music" style="font-size:48px;margin-bottom:16px;"></i>
                <p>No played tracks yet</p>
                <p style="font-size:14px;opacity:0.7;">Play some music to see your most played tracks here</p>
            </div>
        `;
        return;
    }
    
    // Pre-load missing album art from IndexedDB in parallel
    const albumArtPromises = tracks.map(async (track) => {
        const meta = trackMetadata[track.id];
        if (meta?.albumArt) {
            track._resolvedArt = meta.albumArt;
            return;
        }
        
        if (track.album && track.album !== 'Unknown') {
            try {
                const dbArt = await loadImageFromDB(`album_${track.album}`);
                if (dbArt) {
                    track._resolvedArt = dbArt;
                    // Update trackMetadata for future reference
                    if (meta) {
                        meta.albumArt = dbArt;
                        saveTrackMetadataToDB(track.id, meta).catch(() => {});
                    }
                }
            } catch (e) {
                console.warn('[PlayTracking] Failed to load album art for:', track.album);
            }
        }
    });
    
    await Promise.all(albumArtPromises);
    
    // Render horizontal rows sorted by play count
    container.innerHTML = `
        <div class="all-played-tracks-container">
            ${tracks.map((track, index) => {
                const albumArtUrl = track._resolvedArt || track.albumArt || fallbackImg;
                const rank = index + 1;
                
                return `
                <div class="all-played-track-row" onclick="playMostPlayedTrack('${track.id}')" id="all-played-track-${index}">
                    <div class="rank">#${rank}</div>
                    <div class="art">
                        <img src="${albumArtUrl}" 
                             alt="${track.title}"
                             onload="this.classList.add('fade-in'); this.classList.add('loaded');"
                             onerror="this.src='${fallbackImg}'">
                    </div>
                    <div class="info">
                        <div class="title">${track.title}</div>
                        <div class="artist">${track.artist}</div>
                    </div>
                    <div class="plays">${formatPlayCount(track.playCount)} plays</div>
                    <div class="actions">
                        <button class="m3-btn m3-btn-tonal" onclick="event.stopPropagation(); playMostPlayedTrack(${index})">
                            <i class="fa-solid fa-play"></i>
                            <span>Play</span>
                        </button>
                    </div>
                </div>
                `;
            }).join('')}
        </div>
    `;
    
    // Trigger staggered animation for rows
    setTimeout(() => {
        container.querySelectorAll('.all-played-track-row').forEach((row, index) => {
            setTimeout(() => row.classList.add('loaded'), 40 * index);
        });
    }, 50);
    
    console.log('[PlayTracking] Rendered all played tracks with', tracks.length, 'tracks in horizontal rows');
}

// Update All Played Tracks view in-place without re-animating
async function updateAllPlayedTracksSection() {
    const container = document.getElementById('allPlayedTracksContainer');
    if (!container) return;
    
    // Check if the view is visible - use correct screen ID
    const allPlayedScreen = document.getElementById('all-played-screen');
    if (!allPlayedScreen || !allPlayedScreen.classList.contains('active')) return;
    
    // Get fresh tracks from playCounts
    const tracks = [];
    Object.entries(playCounts).forEach(([trackId, count]) => {
        if (count > 0) {
            const meta = trackMetadata[trackId];
            const queueTrack = queue.find(t => t.id === trackId);
            tracks.push({
                id: trackId,
                title: meta?.title || queueTrack?.title || queueTrack?.name || 'Unknown Track',
                artist: meta?.artist || queueTrack?.artist || queueTrack?.artistName || 'Unknown Artist',
                album: meta?.album || queueTrack?.album || '',
                albumArt: meta?.albumArt || meta?.art || queueTrack?.albumArt || queueTrack?.art || '',
                playCount: count
            });
        }
    });
    
    // Sort by play count descending
    tracks.sort((a, b) => b.playCount - a.playCount);
    
    const fallbackImg = 'https://www.gstatic.com/classroom/logo_square_rounded.svg';
    
    if (tracks.length === 0) {
        container.innerHTML = `
            <div style="text-align:center;padding:60px;opacity:0.5;">
                <i class="fa-solid fa-music" style="font-size:48px;margin-bottom:16px;"></i>
                <p>No played tracks yet</p>
                <p style="font-size:14px;opacity:0.7;">Play some music to see your most played tracks here</p>
            </div>
        `;
        return;
    }
    
    // Build a map of track ID to track data for quick lookup
    const trackMap = new Map();
    tracks.forEach((track, index) => {
        trackMap.set(track.id, { ...track, rank: index + 1 });
    });
    
    // Get existing rows and build a map by track ID
    const existingRows = Array.from(container.querySelectorAll('.all-played-track-row'));
    const rowByTrackId = new Map();
    existingRows.forEach(row => {
        const trackId = row.dataset.trackId;
        if (trackId) {
            rowByTrackId.set(trackId, row);
        }
    });
    
    // Create a document fragment for batch DOM operations
    const fragment = document.createDocumentFragment();
    
    // Process all tracks in sorted order
    tracks.forEach((track, index) => {
        let row = rowByTrackId.get(track.id);
        const rank = index + 1;
        
        if (row) {
            // Update existing row in-place
            const rankEl = row.querySelector('.rank');
            const titleEl = row.querySelector('.title');
            const artistEl = row.querySelector('.artist');
            const playsEl = row.querySelector('.plays');
            const artImg = row.querySelector('.art img');
            
            if (rankEl) rankEl.textContent = '#' + rank;
            if (titleEl) titleEl.textContent = track.title;
            if (artistEl) artistEl.textContent = track.artist;
            if (playsEl) playsEl.textContent = formatPlayCount(track.playCount) + ' plays';
            if (artImg && track.albumArt) artImg.src = track.albumArt;
            
            row.style.display = '';
            // Move to end of fragment (preserves DOM order)
            fragment.appendChild(row);
        } else {
            // Create new row
            const albumArtUrl = track.albumArt || fallbackImg;
            row = document.createElement('div');
            row.className = 'all-played-track-row loaded';
            row.dataset.trackId = track.id;
            row.onclick = function() { playMostPlayedTrack(track.id); };
            row.innerHTML = `
                <div class="rank">#${rank}</div>
                <div class="art"><img src="${albumArtUrl}" alt="${track.title}" class="loaded" onerror="this.src='${fallbackImg}'"></div>
                <div class="info"><div class="title">${track.title}</div><div class="artist">${track.artist}</div></div>
                <div class="plays">${formatPlayCount(track.playCount)} plays</div>
            `;
            fragment.appendChild(row);
        }
    });
    
    // Hide any extra rows that are no longer needed (not in sorted tracks)
    const trackIds = new Set(tracks.map(t => t.id));
    existingRows.forEach(row => {
        if (!trackIds.has(row.dataset.trackId)) {
            row.style.display = 'none';
        }
    });
    
    // Apply all changes at once
    container.appendChild(fragment);
}

function playMostPlayedShuffle() {
    const tracks = getMostPlayedTracks(16).filter(t => t.playCount > 0);
    
    if (tracks.length === 0) {
        showNotification('No played tracks yet');
        return;
    }
    
    // Shuffle the tracks
    for (let i = tracks.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [tracks[i], tracks[j]] = [tracks[j], tracks[i]];
    }
    
    // Load into queue and play
    queue = [...tracks];
    qIndex = 0;
    currentQueueSource = 'most-played';
    console.log('[PlayTracking] Shuffled, loading track:', queue[0].id, queue[0].title);
    play(qIndex);
    showNotification('Shuffling your most played');
}

function playMostPlayed() {
    console.log('[PlayTracking] playMostPlayed called');
    const tracks = getMostPlayedTracks(16).filter(t => t.playCount > 0);
    
    console.log('[PlayTracking] Found', tracks.length, 'most played tracks');
    
    if (tracks.length === 0) {
        showNotification('No played tracks yet');
        return;
    }
    
    queue = [...tracks];
    qIndex = 0;
    currentQueueSource = 'most-played';
    console.log('[PlayTracking] Loading track:', queue[0].id, queue[0].title);
    play(qIndex);
    showNotification('Playing your most played');
}

function playMostPlayedTrack(trackId) {
    console.log('[PlayTracking] playMostPlayedTrack called with trackId:', trackId);
    
    // Check if we're in the "All Played Tracks" view
    const allPlayedView = document.getElementById('allPlayedTracksView');
    const isAllPlayedView = allPlayedView?.style.display !== 'none';
    
    // Get display count based on view state
    let displayCount = 6;
    if (isAllPlayedView) {
        displayCount = 9999;
    } else {
        const container = document.getElementById('listenAgainSection');
        const isExpanded = container?.classList.contains('expanded');
        displayCount = isExpanded ? 16 : 6;
    }
    
    // Get fresh track data by rebuilding from playCounts and trackMetadata
    const tracks = [];
    Object.entries(playCounts).forEach(([id, count]) => {
        if (count > 0) {
            const meta = trackMetadata[id];
            const queueTrack = queue.find(t => t.id === id);
            tracks.push({
                id: id,
                title: meta?.title || queueTrack?.title || queueTrack?.name || 'Unknown Track',
                artist: meta?.artist || queueTrack?.artist || queueTrack?.artistName || 'Unknown Artist',
                album: meta?.album || queueTrack?.album || '',
                albumArt: meta?.albumArt || meta?.art || queueTrack?.albumArt || queueTrack?.art || '',
                path: meta?.path || queueTrack?.path || '',
                googleUrl: meta?.googleUrl || queueTrack?.googleUrl || queueTrack?.url || '',
                playCount: count
            });
        }
    });
    
    // Sort by play count descending
    tracks.sort((a, b) => b.playCount - a.playCount);
    
    // Find the track by ID (not by index - this ensures correct track plays regardless of sort order changes)
    let track = tracks.find(t => t.id === trackId);
    
    // FALLBACK: If track not found (e.g., pinned track with 0 plays), search in pinnedItems, allTracks, and trackMetadata
    if (!track) {
        console.log('[PlayTracking] Track not found in playCounts, searching fallback sources for ID:', trackId);
        
        // Try to find in queue first (has full URLs for playback)
        let queueTrack = queue.find(t => t.id === trackId);
        if (queueTrack) {
            track = {
                id: queueTrack.id,
                title: queueTrack.title || queueTrack.name || 'Unknown Track',
                artist: queueTrack.artist || queueTrack.artistName || 'Unknown Artist',
                album: queueTrack.album || '',
                albumArt: queueTrack.albumArt || queueTrack.art || '',
                path: queueTrack.path || '',
                googleUrl: queueTrack.googleUrl || queueTrack.url || '',
                playCount: 0
            };
            console.log('[PlayTracking] Found track in queue:', track.title);
        } else {
            // Try to find in pinnedItems.tracks
            let pinnedTrack = pinnedItems.tracks?.find(t => t.id === trackId);
            
            if (pinnedTrack) {
                track = {
                    id: pinnedTrack.id,
                    title: pinnedTrack.title || pinnedTrack.name || 'Unknown Track',
                    artist: pinnedTrack.artist || 'Unknown Artist',
                    album: pinnedTrack.album || '',
                    albumArt: pinnedTrack.albumArt || pinnedTrack.art || '',
                    path: pinnedTrack.path || '',
                    googleUrl: pinnedTrack.googleUrl || '',
                    playCount: 0
                };
                console.log('[PlayTracking] Found track in pinnedItems:', track.title);
            } else {
                // Try to find in trackMetadata
                const meta = trackMetadata[trackId];
                if (meta) {
                    track = {
                        id: trackId,
                        title: meta.title || 'Unknown Track',
                        artist: meta.artist || 'Unknown Artist',
                        album: meta.album || '',
                        albumArt: meta.albumArt || meta.art || '',
                        path: meta.path || '',
                        googleUrl: meta.googleUrl || '',
                        playCount: 0
                    };
                    console.log('[PlayTracking] Found track in trackMetadata:', track.title);
                } else {
                    // Last resort: try to find in allTracks
                    const allTrack = allTracks.find(t => t.id === trackId);
                    if (allTrack) {
                        track = {
                            id: allTrack.id,
                            title: allTrack.title || allTrack.name || 'Unknown Track',
                            artist: allTrack.artist || allTrack.artistName || 'Unknown Artist',
                            album: allTrack.album || '',
                            albumArt: allTrack.albumArt || allTrack.art || '',
                            path: allTrack.path || '',
                            googleUrl: allTrack.googleUrl || allTrack.url || '',
                            playCount: 0
                        };
                        console.log('[PlayTracking] Found track in allTracks:', track.title);
                    }
                }
            }
        }
        
        // If we still don't have a track, give up
        if (!track) {
            console.log('[PlayTracking] Still no track found after checking all sources:', trackId);
            return;
        }
        
        // Add the fallback track to the tracks array so qIndex can find it
        tracks.push(track);
    }
    
    console.log('[PlayTracking] Playing track:', track.id, track.title);
    
    // Load the full track info from queue if available for playback URLs
    // First try to find in current queue (has full URLs)
    let queueTrack = queue.find(t => t.id === track.id);
    
    // If not in queue, we need to get the track info from the current folder
    // Check if we're at a folder level where this track might exist
    if (!queueTrack && currentQueueSource && currentQueueSource.startsWith('folder:')) {
        // Get the current folder tracks
        const currentFolderId = currentQueueSource.split(':')[1];
        // The track info should be in trackMetadata or we need to look it up
    }
    
    const fullTrack = queueTrack || {
        id: track.id,
        title: track.title,
        artist: track.artist,
        album: track.album,
        albumArt: track.albumArt,
        googleUrl: track.googleUrl,
        path: track.path
    };
    
    // Set queue and play
    queue = [...tracks];
    qIndex = tracks.findIndex(t => t.id === track.id);
    currentQueueSource = 'most-played';
    
    // Try to load track - use the ID to trigger proper loading
    if (fullTrack.googleUrl || fullTrack.path) {
        play(qIndex);
    } else {
        // If no URL available, we need to get it from the file system
        console.log('[PlayTracking] No URL available for track, attempting to reload from metadata');
        // The play function should handle this via the ID in queue
        play(qIndex);
    }
    
    // Ensure audio context is initialized
    initAudioContext();
    
    player.play().catch(err => {
        console.log('[PlayTracking] Play failed:', err);
    });
}

// Shuffle and play from most played tracks
function playMostPlayedTrackShuffle(trackId) {
    console.log('[PlayTracking] playMostPlayedTrackShuffle called with trackId:', trackId);
    
    // Build tracks list from playCounts
    const tracks = [];
    Object.entries(playCounts).forEach(([id, count]) => {
        if (count > 0) {
            const meta = trackMetadata[id];
            const queueTrack = queue.find(t => t.id === id);
            tracks.push({
                id: id,
                title: meta?.title || queueTrack?.title || queueTrack?.name || 'Unknown Track',
                artist: meta?.artist || queueTrack?.artist || queueTrack?.artistName || 'Unknown Artist',
                album: meta?.album || queueTrack?.album || '',
                albumArt: meta?.albumArt || meta?.art || queueTrack?.albumArt || queueTrack?.art || '',
                path: meta?.path || queueTrack?.path || '',
                googleUrl: meta?.googleUrl || queueTrack?.googleUrl || queueTrack?.url || '',
                playCount: count
            });
        }
    });
    
    // Sort by play count descending
    tracks.sort((a, b) => b.playCount - a.playCount);
    
    // FALLBACK: If trackId not found in tracks (e.g., pinned track with 0 plays), add it
    if (!tracks.find(t => t.id === trackId)) {
        console.log('[PlayTracking] Shuffle: Track not found in playCounts, adding from fallback sources:', trackId);
        
        // Try to find in queue first (has full URLs for playback)
        let queueTrack = queue.find(t => t.id === trackId);
        if (queueTrack) {
            tracks.push({
                id: queueTrack.id,
                title: queueTrack.title || queueTrack.name || 'Unknown Track',
                artist: queueTrack.artist || queueTrack.artistName || 'Unknown Artist',
                album: queueTrack.album || '',
                albumArt: queueTrack.albumArt || queueTrack.art || '',
                path: queueTrack.path || '',
                googleUrl: queueTrack.googleUrl || queueTrack.url || '',
                playCount: 0
            });
            console.log('[PlayTracking] Shuffle: Added track from queue:', queueTrack.title);
        } else {
            // Try to find in pinnedItems.tracks
            let pinnedTrack = pinnedItems.tracks?.find(t => t.id === trackId);
            
            if (pinnedTrack) {
                tracks.push({
                    id: pinnedTrack.id,
                    title: pinnedTrack.title || pinnedTrack.name || 'Unknown Track',
                    artist: pinnedTrack.artist || 'Unknown Artist',
                    album: pinnedTrack.album || '',
                    albumArt: pinnedTrack.albumArt || pinnedTrack.art || '',
                    path: pinnedTrack.path || '',
                    googleUrl: pinnedTrack.googleUrl || '',
                    playCount: 0
                });
                console.log('[PlayTracking] Shuffle: Added track from pinnedItems:', pinnedTrack.title);
            } else {
                // Try to find in trackMetadata
                const meta = trackMetadata[trackId];
                if (meta) {
                    tracks.push({
                        id: trackId,
                        title: meta.title || 'Unknown Track',
                        artist: meta.artist || 'Unknown Artist',
                        album: meta.album || '',
                        albumArt: meta.albumArt || meta.art || '',
                        path: meta.path || '',
                        googleUrl: meta.googleUrl || '',
                        playCount: 0
                    });
                    console.log('[PlayTracking] Shuffle: Added track from trackMetadata:', meta.title);
                } else {
                    // Last resort: try to find in allTracks
                    const allTrack = allTracks.find(t => t.id === trackId);
                    if (allTrack) {
                        tracks.push({
                            id: allTrack.id,
                            title: allTrack.title || allTrack.name || 'Unknown Track',
                            artist: allTrack.artist || allTrack.artistName || 'Unknown Artist',
                            album: allTrack.album || '',
                            albumArt: allTrack.albumArt || allTrack.art || '',
                            path: allTrack.path || '',
                            googleUrl: allTrack.googleUrl || allTrack.url || '',
                            playCount: 0
                        });
                        console.log('[PlayTracking] Shuffle: Added track from allTracks:', allTrack.title);
                    }
                }
            }
        }
    }
    
    if (tracks.length === 0) return;
    
    // Shuffle the tracks (keeping trackId first)
    const trackIndex = tracks.findIndex(t => t.id === trackId);
    if (trackIndex > 0) {
        [tracks[0], tracks[trackIndex]] = [tracks[trackIndex], tracks[0]];
    }
    
    // Fisher-Yates shuffle from index 1 onwards
    for (let i = tracks.length - 1; i > 1; i--) {
        const j = Math.floor(Math.random() * (i - 1)) + 1;
        [tracks[i], tracks[j]] = [tracks[j], tracks[i]];
    }
    
    // Set queue and play
    queue = [...tracks];
    qIndex = 0;
    currentQueueSource = 'most-played-shuffle';
    
    // Ensure audio context is initialized
    initAudioContext();
    
    play(0);
}

function formatPlayCount(count) {
    if (count >= 1000) {
        return (count / 1000).toFixed(1) + 'K';
    }
    return count.toString();
}

// Track play progress for counting
function trackPlayProgress() {
    console.log('[PlayTracking] trackPlayProgress called');
    
    if (!queue[qIndex]?.id) {
        console.log('[PlayTracking] No current track in queue (qIndex:', qIndex, ', queue.length:', queue.length, ')');
        return;
    }
    
    const trackId = queue[qIndex].id;
    const duration = player.duration;
    const currentTime = player.currentTime;
    
    console.log('[PlayTracking] Track:', trackId, '| Duration:', duration, '| Current:', currentTime, '| Progress:', ((currentTime / duration) * 100).toFixed(1) + '%');
    
    if (!duration || duration === 0 || isNaN(duration)) {
        console.log('[PlayTracking] Invalid duration, skipping');
        return;
    }
    
    const progress = currentTime / duration;
    const previousPosition = lastTrackedPosition[trackId] || 0;
    
    console.log('[PlayTracking] Progress:', (progress * 100).toFixed(1) + '%', '| Threshold:', (PLAY_COUNT_THRESHOLD * 100) + '%', '| Previous:', (previousPosition * 100).toFixed(1) + '%');
    
    // Check if we've crossed the 25% threshold
    if (progress >= PLAY_COUNT_THRESHOLD) {
        console.log('[PlayTracking] Crossed 25% threshold');
        
        // Only count if we haven't already counted this track
        // and we just crossed the threshold
        if (previousPosition < PLAY_COUNT_THRESHOLD && progress >= PLAY_COUNT_THRESHOLD) {
            console.log('[PlayTracking] Calling incrementPlayCount for:', trackId);
            incrementPlayCount(trackId);
        } else {
            console.log('[PlayTracking] Already counted or threshold not newly crossed');
        }
        
        lastTrackedPosition[trackId] = progress;
        console.log('[PlayTracking] Updated lastTrackedPosition for', trackId, 'to', progress);
    } else {
        console.log('[PlayTracking] Not yet at 25% threshold');
    }
}

/**
 * Update the player audio source to include normalization gain node
 */
function setupNormalizedAudio() {
    if (!normEnabled || !audioContext) return;
    
    // The gain node should be connected between source and destination
    // This is handled by the createMediaElementSource setup
}

	function adjustColor(hex, amount) {
	    const num = parseInt(hex.slice(1), 16);
	    const r = Math.min(255, Math.max(0, (num >> 16) + amount));
	    const g = Math.min(255, Math.max(0, ((num >> 8) & 0x00FF) + amount));
	    const b = Math.min(255, Math.max(0, (num & 0x0000FF) + amount));
	    return '#' + (b | (g << 8) | (r << 16)).toString(16).padStart(6, '0').toUpperCase();
	}

function goHome(el) { stack=[{id:ROOT_ID,name:"Home"}]; loadFolders(ROOT_ID); nav(el); }

function nav(el) {
    const screen = el.dataset.screen;
    document.querySelectorAll('.nav-item').forEach(x => {
        x.classList.toggle('active', x.dataset.screen === screen);
    });
    document.querySelectorAll('.mobile-nav-item').forEach(x => {
        if(x.dataset.screen) x.classList.toggle('active', x.dataset.screen === screen);
    });
    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const target = document.getElementById(screen + '-screen');
    if(target) target.classList.add('active');
}

function toggleSidebar() { 
    document.getElementById("sidebar").classList.toggle("collapsed");
    
    // Re-render Listen Again section to adjust for new width
    // Use setTimeout to allow the CSS transition to complete first
    setTimeout(() => {
        if (typeof refreshMostPlayedCache === 'function') {
            refreshMostPlayedCache();
        }
    }, 420);
}

function openMobilePlayer() {
    if (window.innerWidth <= 768) {
        document.getElementById("mobilePlayer").classList.add("active");
    }
}

function closeMobilePlayer() {
    document.getElementById("mobilePlayer").classList.remove("active");
}

function shuffleQueue() {
    for(let i=queue.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [queue[i], queue[j]] = [queue[j], queue[i]];
    }
}

function toggleShuffle() {
    shuffleMode = !shuffleMode;
    const mini = document.getElementById("btnShuffle");
    const fs = document.getElementById("fsBtnShuffle");
    const cleanBtn = document.getElementById("deShuffleBtn");
    
    mini.style.opacity = shuffleMode ? "1" : "0.5";
    mini.style.color = shuffleMode ? "var(--md-sys-color-primary)" : "inherit";
    
    fs.style.opacity = shuffleMode ? "1" : "0.5";
    fs.style.color = shuffleMode ? "var(--md-sys-color-primary)" : "inherit";
    
    if(cleanBtn) cleanBtn.classList.toggle('active', shuffleMode);
    
    if (shuffleMode) {
        if (queue.length < 2) return;
        const currentId = queue[qIndex]?.id;
        if (!currentId) return;
        originalQueue = [...queue];
        shuffleQueue();
        const pos = queue.findIndex(t => t.id === currentId);
        if (pos !== 0) {
            [queue[0], queue[pos]] = [queue[pos], queue[0]];
        }
        qIndex = 0;
        currentQueueSource = null;
    } else {
        const currentId = queue[qIndex]?.id;
        queue = [...originalQueue];
        qIndex = originalQueue.findIndex(t => t.id === currentId);
        if (qIndex === -1) qIndex = 0;
        currentQueueSource = null;
    }
    // Defer renderQueue for smoother UI
    setTimeout(() => renderQueue(), 0);
}

function skip(direction) {
    // Check if current track crossed the 25% threshold - if so, discard the play
    const currentTrack = queue[qIndex];
    if (currentTrack?.id) {
        const duration = player.duration;
        const currentTime = player.currentTime;
        if (duration && currentTime) {
            const progress = currentTime / duration;
            // If track has been counted (crossed 25% threshold) and we're skipping forward
            if (progress >= PLAY_COUNT_THRESHOLD && direction > 0) {
                console.log('[PlayTracking] Skipping after threshold - discarding play for:', currentTrack.id);
                decrementPlayCount(currentTrack.id);
            }
        }
    }
    
    let next = qIndex + direction;
    if (shuffleMode) {
        if (repeatMode === 1 && next >= queue.length) {
            shuffleQueue();
            next = 0;
        } else if (next >= queue.length || next < 0) return;
    } else {
        if (repeatMode === 1) {
            if (next >= queue.length) next = 0;
            if (next < 0) next = queue.length-1;
        } else if (next >= queue.length || next < 0) return;
    }
    play(next);
    renderQueue(); // Update queue highlighting immediately
}

function togglePlay() {
    // Initialize audio context before playing (required for Web Audio API)
    if (player.paused) {
        initAudioContext();
        // Resume context if suspended (browser autoplay policy)
        if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume();
        }
    }
    if (player.paused) {
        player.play().then(() => {
            // Automatically open queue sidebar when music starts playing
            const sidebar = document.getElementById("sidebar");
            if (sidebar) {
                sidebar.classList.remove("collapsed");
            }
        }).catch(()=>{});
    } else {
        player.pause();
    }
}

function scrub(v) { if (player.duration) player.currentTime = (v/100)*player.duration; }

function updateBreadcrumbs() {
    document.getElementById('breadcrumb').innerHTML = stack.map((s,i)=>`
        <div class="breadcrumb-chip" onclick="stack.splice(${i+1});loadFolders(stack[${i}].id)">${s.name}</div>
    `).join('<i class="fa-solid fa-chevron-right" style="opacity:0.2;font-size:10px;"></i>');
}

function openPlaylistModal(e,id) {
    e.stopPropagation();
    const playlistNames = Object.keys(playlists);
    if (playlistNames.length === 0) {
        document.getElementById("modalList").innerHTML = '<div style="text-align:center;padding:40px 20px;opacity:0.6;">No playlists yet</div>';
    } else {
        document.getElementById("modalList").innerHTML = playlistNames.map(n => {
            const trackCount = Array.isArray(playlists[n]) ? playlists[n].length : 0;
            return `
                <div class="playlist-modal-item" onclick="addToPlaylist('${n}','${id}')">
                    <div class="playlist-modal-item-icon">
                        <i class="fa-solid fa-music"></i>
                    </div>
                    <div class="playlist-modal-item-info">
                        <div class="playlist-modal-item-name">${n}</div>
                        <div class="playlist-modal-item-count">${trackCount} track${trackCount !== 1 ? 's' : ''}</div>
                    </div>
                    <div class="playlist-modal-item-arrow">
                        <i class="fa-solid fa-chevron-right"></i>
                    </div>
                </div>
            `;
        }).join('');
    }
    document.getElementById("modalOverlay").style.display = "flex";
}

function addToPlaylist(p,id) {
    if (!Array.isArray(playlists[p])) playlists[p] = [];
    playlists[p].push({id});
    localStorage.setItem('goot_playlists', JSON.stringify(playlists));
    closeModal();
    
    // Get track title for notification
    const m = trackMetadata[id];
    const title = m?.title || m?.album || 'Unknown Title';
    showNotification(`Added "${title}" to "${p}"`);
    
    // If the currently open playlist is the one we just modified, update its view
    if (currentPlaylistName === p) {
        // Defer track table render for smoother UI
        setTimeout(() => {
            renderTrackTable(playlists[p], document.getElementById("playlistSongBody"), true, p);
        }, 0);
    }
    
    // Defer playlist grid render for smoother UI
    setTimeout(() => renderPlaylists(), 0);
}

function closeModal() { document.getElementById("modalOverlay").style.display="none"; }

function createNewPlaylist(fm) {
    const n = prompt("Name:");
    if(n){
        playlists[n]=[];
        localStorage.setItem('goot_playlists', JSON.stringify(playlists));
        renderPlaylists();
    }
    if(fm) closeModal();
}

function exportPlaylists() {
    const blob = new Blob([JSON.stringify(playlists)],{type:"application/json"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = "backup.goot2";
    a.click();
}

function toggleRepeat() {
    repeatMode = repeatMode === 0 ? 1 : 0;
    const mini = document.getElementById("btnRepeat");
    const fs = document.getElementById("fsBtnRepeat");
    const cleanBtn = document.getElementById("deRepeatBtn");
    
    mini.style.opacity = repeatMode === 1 ? "1" : "0.5";
    mini.style.color = repeatMode === 1 ? "var(--md-sys-color-primary)" : "inherit";
    
    fs.style.opacity = repeatMode === 1 ? "1" : "0.5";
    fs.style.color = repeatMode === 1 ? "var(--md-sys-color-primary)" : "inherit";
    
    if(cleanBtn) cleanBtn.classList.toggle('active', repeatMode === 1);
}

function setVolume(val) {
    player.volume = val;
    if (player.muted && val > 0) player.muted = false;
    
    // Update main volume slider
    const volSlider = document.getElementById('volSlider');
    if (volSlider) volSlider.value = val;
    
    // Update desktop extended volume slider
    const deVolSlider = document.getElementById('deVolSlider');
    if (deVolSlider) deVolSlider.value = val;
    
    updateVolIcon(val);
}

function toggleMute() {
    player.muted = !player.muted;
    updateVolIcon(player.muted ? 0 : player.volume);
    
    // Update both sliders
    const deVolSlider = document.getElementById('deVolSlider');
    const volSlider = document.getElementById('volSlider');
    
    if (!player.muted && player.volume === 0) {
        player.volume = 0.5;
        if (volSlider) volSlider.value = 0.5;
        if (deVolSlider) deVolSlider.value = 0.5;
        updateVolIcon(0.5);
    }
}

function updateVolIcon(val) {
    const icon = document.getElementById('volIcon');
    const deVolIcon = document.getElementById('deVolIcon');
    const slider = document.getElementById('volSlider');
    
    if (!player.muted) slider.value = val;
    
    if (player.muted || val == 0) {
        icon.className = 'fa-solid fa-volume-xmark';
        icon.style.opacity = "0.5";
        if (deVolIcon) {
            deVolIcon.className = 'fa-solid fa-volume-xmark';
            deVolIcon.style.opacity = "0.5";
        }
    } else {
        icon.style.opacity = "0.8";
        if (val < 0.5) {
            icon.className = 'fa-solid fa-volume-low';
            if (deVolIcon) {
                deVolIcon.className = 'fa-solid fa-volume-low';
                deVolIcon.style.opacity = "0.7";
            }
        } else {
            icon.className = 'fa-solid fa-volume-high';
            if (deVolIcon) {
                deVolIcon.className = 'fa-solid fa-volume-high';
                deVolIcon.style.opacity = "0.7";
            }
        }
    }
}

function updateBuffer() {
    if (player.duration > 0) {
        for (let i = 0; i < player.buffered.length; i++) {
            if (player.buffered.start(i) <= player.currentTime && player.buffered.end(i) >= player.currentTime) {
                const p = (player.buffered.end(i) / player.duration) * 100;
                (document.getElementById("buffFill") || {}).style.width = p + "%";
                (document.getElementById("fsBuffFill") || {}).style.width = p + "%";
                break;
            }
        }
    }
}

player.ontimeupdate = () => {
    const p = player.duration ? (player.currentTime / player.duration) * 100 : 0;
    const cur = Math.floor(player.currentTime/60) + ":" + Math.floor(player.currentTime%60).toString().padStart(2,'0');
    const dur = Math.floor(player.duration/60||0) + ":" + Math.floor(player.duration%60||0).toString().padStart(2,'0');

    (document.getElementById("progFill") || {}).style.width = p + "%";
    (document.getElementById("curTime") || {}).textContent = cur;
    (document.getElementById("durTime") || {}).textContent = dur;
    
    // Clean View Updates
    const deFill = document.getElementById("deProgFill");
    if(deFill) {
        deFill.style.width = p + "%";
        document.getElementById("deCurTime").textContent = cur;
        document.getElementById("deDurTime").textContent = dur;
        document.getElementById("deProgScrub").value = p;
    }
    
    document.getElementById("fsProgFill").style.width = p + "%";
    document.getElementById("fsCurTime").textContent = cur;
    document.getElementById("fsDurTime").textContent = dur;
    document.getElementById("fsProgScrub").value = p;
    document.getElementById("progScrub").value = p;
    
    updateBuffer();
    
    // Track play progress for counting plays
    trackPlayProgress();
};

document.addEventListener('input', (e) => {
    if (e.target.id === 'deProgScrub') {
        scrub(e.target.value);
    }
});

player.addEventListener('progress', updateBuffer);

player.onplay = () => {
    // Resume audio context if suspended (browser autoplay policy)
    if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume();
    }
    if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    if (audioCtx && audioCtx.state === 'suspended') {
        audioCtx.resume();
    }
    
    // Analyze and apply normalization to current track with slight delay to ensure audio graph is ready
    if (queue[qIndex]?.id) {
        setTimeout(() => analyzeAndApplyNormalization(queue[qIndex].id), 10);
    }
    
    document.getElementById("playIcon").className = "fa-solid fa-pause";
    document.getElementById("fsPlayIcon").className = "fa-solid fa-pause";
    const dePlay = document.getElementById("dePlayIcon");
    if(dePlay) dePlay.className = "fa-solid fa-pause";
    document.body.classList.add('playing');
};

player.onpause = () => {
    document.getElementById("playIcon").className = "fa-solid fa-play";
    document.getElementById("fsPlayIcon").className = "fa-solid fa-play";
    const dePlay = document.getElementById("dePlayIcon");
    if(dePlay) dePlay.className = "fa-solid fa-play";
    document.body.classList.remove('playing');
};

player.onended = () => {
    // Get the next track index before skipping
    let next = qIndex + 1;
    if (shuffleMode) {
        if (repeatMode === 1 && next >= queue.length) {
            shuffleQueue();
            next = 0;
        } else if (next >= queue.length || next < 0) return;
    } else {
        if (repeatMode === 1) {
            if (next >= queue.length) next = 0;
            if (next < 0) next = queue.length-1;
        } else if (next >= queue.length || next < 0) return;
    }
    
    // Skip to next track (which will call play and analyze/apply normalization)
    skip(1);
    
    // Also analyze and apply normalization again after a short delay to ensure it's applied
    if (queue[qIndex]?.id) {
        setTimeout(() => analyzeAndApplyNormalization(queue[qIndex].id), 100);
    }
};

// Extended View Toggle Logic
function toggleDesktopExtended() {
    const panel = document.getElementById("desktopExtended");
    panel.classList.toggle("collapsed");
    // Ensure queue is rendered if opening
    if (!panel.classList.contains("collapsed")) {
        // Defer renderQueue for smoother UI
        setTimeout(() => renderQueue(), 0);
    }
}

document.getElementById('bassSlider').addEventListener('input', (e) => {
    updateBass(e.target.value);
});

document.getElementById('trebleSlider').addEventListener('input', (e) => {
    updateTreble(e.target.value);
});

// Desktop extended volume slider
document.getElementById('deVolSlider').addEventListener('input', (e) => {
    setVolume(e.target.value);
});

// ==================== Cover Picker ====================

// Configuration





// ==================== Notification Helper ====================

/**
 * Shows a notification to the user
 */
function showNotification(message) {
    // Create notification element
    const notification = document.createElement('div');
    notification.style.cssText = `
        position: fixed;
        bottom: 140px;
        left: 50%;
        transform: translateX(-50%);
        background: var(--md-sys-color-primary);
        color: white;
        padding: 12px 24px;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 500;
        z-index: 5000;
        animation: fadeInOut 2.5s ease-in-out forwards;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    `;
    notification.textContent = message;

    document.body.appendChild(notification);

    // Remove after animation
    setTimeout(() => {
        notification.remove();
    }, 2500);
}

if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init);
} else {
    init();
}
</script>
</body>
</html>
